<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discretization · ReachabilityAnalysis.jl</title><meta name="title" content="Discretization · ReachabilityAnalysis.jl"/><meta property="og:title" content="Discretization · ReachabilityAnalysis.jl"/><meta property="twitter:title" content="Discretization · ReachabilityAnalysis.jl"/><meta name="description" content="Documentation for ReachabilityAnalysis.jl."/><meta property="og:description" content="Documentation for ReachabilityAnalysis.jl."/><meta property="twitter:description" content="Documentation for ReachabilityAnalysis.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ReachabilityAnalysis.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ReachabilityAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Set representations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/set_representations/zonotopes/">Zonotopic sets</a></li><li><a class="tocitem" href="../../tutorials/set_representations/polyhedral_computations/">Polyhedral computations</a></li><li><a class="tocitem" href="../../tutorials/set_representations/distances/">Metric notions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/linear_methods/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/linear_methods/discrete_time/">Discrete time reachability</a></li><li><a class="tocitem" href="../../tutorials/linear_methods/dense_time/">Dense time reachability</a></li><li><a class="tocitem" href="../../generated_examples/ISS/">International Space Station</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Modeling uncertain inputs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated_examples/Building/">Building model</a></li><li><a class="tocitem" href="../../generated_examples/OpAmp/">Operational amplifier</a></li><li><a class="tocitem" href="../../generated_examples/TransmissionLine/">Transmission line</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Taylor methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/taylor_methods/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/taylor_methods/domain_splitting/">Domain splitting</a></li><li><a class="tocitem" href="../../tutorials/taylor_methods/gotchas/">Common gotchas</a></li><li><a class="tocitem" href="../../generated_examples/LotkaVolterra/">Lotka-Volterra</a></li><li><a class="tocitem" href="../../generated_examples/VanDerPol/">Van der Pol oscillator</a></li><li><a class="tocitem" href="../../generated_examples/Lorenz/">Lorenz system</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Parametric systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/parametric/">Parametric reachability</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Hybrid systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated_examples/SquareWaveOscillator/">Square wave oscillator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Clocked systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated_examples/Platoon/">Platoon</a></li><li><a class="tocitem" href="../../generated_examples/EMBrake/">Electromechanical brake</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/systems/">Systems</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Linear solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/algorithms/A20/">A20</a></li><li><a class="tocitem" href="../../man/algorithms/ASB07/">ASB07</a></li><li><a class="tocitem" href="../../man/algorithms/BFFPSV18/">BFFPSV18</a></li><li><a class="tocitem" href="../../man/algorithms/BOX/">BOX</a></li><li><a class="tocitem" href="../../man/algorithms/GLGM06/">GLGM06</a></li><li><a class="tocitem" href="../../man/algorithms/INT/">INT</a></li><li><a class="tocitem" href="../../man/algorithms/LGG09/">LGG09</a></li><li><a class="tocitem" href="../../man/algorithms/ORBIT/">ORBIT</a></li><li><a class="tocitem" href="../../man/algorithms/VREP/">VREP</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Parametric solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/algorithms/HLBS25/">HLBS25</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/benchmarks/repeatability/">Repeatability evaluations</a></li><li><a class="tocitem" href="../../man/benchmarks/model_library/">Model library</a></li><li><a class="tocitem" href="../../man/benchmarks/benchmarks/">Benchmark repository</a></li><li><a class="tocitem" href="../../man/benchmarks/filtered_oscillator/">Filtered oscillator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Further examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/examples_overview/">Overview</a></li><li><a class="tocitem" href="../../generated_examples/DuffingOscillator/">Duffing oscillator</a></li><li><a class="tocitem" href="../../generated_examples/LaubLoomis/">Laub-Loomis</a></li><li><a class="tocitem" href="../../generated_examples/ProductionDestruction/">Production-Destruction</a></li><li><a class="tocitem" href="../../generated_examples/Brusselator/">Brusselator</a></li><li><a class="tocitem" href="../../generated_examples/Quadrotor/">Quadrotor</a></li><li><a class="tocitem" href="../../generated_examples/SEIR/">Epidemic (SEIR) model</a></li><li><a class="tocitem" href="../../generated_examples/Spacecraft/">Spacecraft</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../reachsets/">Reach-sets</a></li><li><a class="tocitem" href="../flowpipes/">Flowpipes</a></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Linear solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../algorithms/A20/">A20</a></li><li><a class="tocitem" href="../algorithms/ASB07/">ASB07</a></li><li><a class="tocitem" href="../algorithms/BFFPSV18/">BFFPSV18</a></li><li><a class="tocitem" href="../algorithms/BOX/">BOX</a></li><li><a class="tocitem" href="../algorithms/GLGM06/">GLGM06</a></li><li><a class="tocitem" href="../algorithms/INT/">INT</a></li><li><a class="tocitem" href="../algorithms/LGG09/">LGG09</a></li><li><a class="tocitem" href="../algorithms/ORBIT/">ORBIT</a></li><li><a class="tocitem" href="../algorithms/VREP/">VREP</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Nonlinear solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../algorithms/CARLIN/">CARLIN</a></li><li><a class="tocitem" href="../algorithms/QINT/">QINT</a></li><li><a class="tocitem" href="../algorithms/TMJets/">TMJets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Parametric solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../algorithms/HLBS25/">HLBS25</a></li></ul></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li class="is-active"><a class="tocitem" href>Discretization</a><ul class="internal"><li><a class="tocitem" href="#Discretize-API"><span>Discretize API</span></a></li><li><a class="tocitem" href="#Approximation-models"><span>Approximation models</span></a></li><li><a class="tocitem" href="#Exponentiation"><span>Exponentiation</span></a></li></ul></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../clustering/">Clustering</a></li><li><a class="tocitem" href="../operations/">Further set operations</a></li><li><a class="tocitem" href="../distributed/">Distributed computations</a></li><li><a class="tocitem" href="../internals/">Internal functions and macros</a></li></ul></li><li><a class="tocitem" href="../../man/faq/">Frequently Asked Questions (FAQ)</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../about/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Discretization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Discretization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/docs/src/lib/discretize.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h1><ul><li><a href="#Discretization">Discretization</a></li><li class="no-marker"><ul><li><a href="#Discretize-API">Discretize API</a></li><li><a href="#Approximation-models">Approximation models</a></li><li><a href="#Exponentiation">Exponentiation</a></li></ul></li></ul><h2 id="Discretize-API"><a class="docs-heading-anchor" href="#Discretize-API">Discretize API</a><a id="Discretize-API-1"></a><a class="docs-heading-anchor-permalink" href="#Discretize-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.DiscretizationModule" href="#ReachabilityAnalysis.DiscretizationModule"><code>ReachabilityAnalysis.DiscretizationModule</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Interface for conservative time discretization methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/DiscretizationModule.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize(system::AbstractSystem)</code></pre><p>Transform a mathematical system to a normalized (or canonical) form.</p><p><strong>Input</strong></p><ul><li><code>system</code> – system; it can be discrete or continuous</li></ul><p><strong>Output</strong></p><p>Either the same system if it already conforms to a canonical form, or a new system otherwise.</p><p><strong>Notes</strong></p><p>The normalization procedure consists of transforming a given system type into a &quot;canonical&quot; format that is used internally. More details are given below.</p><p><strong>Algorithm</strong></p><p>The implementation of <code>normalize</code> exploits <code>MathematicalSystems</code>&#39;s&#39; types, which carry information about the problem as a type parameter.</p><p>Homogeneous ODEs of the form <span>$x&#39; = Ax, x ∈ \mathcal{X}$</span> are canonical if the associated problem is a <code>ConstrainedLinearContinuousSystem</code> and <code>A</code> is a matrix. This type does not handle non-deterministic inputs.</p><p>Note that a <code>LinearContinuousSystem</code> does not consider constraints on the state-space (such as an invariant); to specify state constraints, use a <code>ConstrainedLinearContinuousSystem</code>. If the passed system is a <code>LinearContinuousSystem</code> (i.e. no constraints) then the normalization fixes a universal set (<code>Universe</code>) as the constraint set.</p><p>The generalization to canonical systems with constraints and possibly time-varying non-deterministic inputs is considered next. These systems are of the form <span>$x&#39; = Ax + u, u ∈ \mathcal{U}, x ∈ \mathcal{X}$</span>. The system type is <code>ConstrainedLinearControlContinuousSystem</code>, where <code>A</code> is a matrix, <code>X</code> is a set and <code>U</code> is an input, that is, any concrete subtype of <code>AbstractInput</code>.</p><p>If <code>U</code> is not given as an input, normalization accepts either a <code>LazySet</code>, or a vector of <code>LazySet</code>s. In these cases, the sets are wrapped around an appropriate concrete input type.</p><p>If the system does not conform to a canonical form, the implementation tries to make the transformation; otherwise an error is thrown. In particular, ODEs of the form <span>$x&#39; = Ax + Bu$</span> are mapped into <span>$x&#39; = Ax + u, u ∈ B\mathcal{U}$</span>, where now <span>$u$</span> has the same dimensions as <span>$x$</span>.</p><p>The transformations described above are analogous in the discrete case, i.e. <span>$x_{k+1} = A x_k$</span> and <span>$x_{k+1} = Ax_{k} + u_k, u_k ∈ \mathcal{U}, x_k ∈ \mathcal{X}$</span> for the linear and affine cases respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Continuous/normalization.jl#L237-L289">source</a></section><section><div><pre><code class="language-julia hljs">normalize(ivp::InitialValueProblem)</code></pre><p>Transform an initial-value problem into a normalized (or canonical) form.</p><p><strong>Input</strong></p><ul><li><code>ivp</code> – initial-value problem</li></ul><p><strong>Output</strong></p><p>Either the same initial-value problem if it already conforms to a canonical form, or a new one otherwise.</p><p><strong>Notes</strong></p><p>This function extends <a href="../systems/#LinearAlgebra.normalize-Tuple{AbstractSystem}"><code>normalize</code></a> for initial-value problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Continuous/normalization.jl#L294-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MathematicalSystems.discretize" href="#MathematicalSystems.discretize"><code>MathematicalSystems.discretize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discretize(ivp::IVP, δ, alg::AbstractApproximationModel)</code></pre><p>Set-based conservative discretization of a continuous-time initial value problem into a discrete-time problem.</p><p><strong>Input</strong></p><ul><li><code>ivp</code>   – initial value problem for a linear ODE in canonical form (see <code>Notes</code> below)</li><li><code>δ</code>     – step size</li><li><code>alg</code>   – algorithm used to compute the approximation model</li></ul><p><strong>Output</strong></p><p>The initial value problem of a discrete system.</p><p><strong>Notes</strong></p><p>Different approximation algorithms and their respective options are described in the docstring of each method. Here is a list of all the available approximation models:</p><pre><code class="language-julia-repl hljs">julia&gt; subtypes(ReachabilityAnalysis.DiscretizationModule.AbstractApproximationModel)
10-element Vector{Any}:
 Backward
 CorrectionHull
 CorrectionHullMatrixZonotope
 FirstOrder
 FirstOrderZonotope
 Forward
 ForwardBackward
 NoBloating
 SecondOrderddt
 StepIntersect</code></pre><p>Initial-value problems considered in this function are of the form</p><p class="math-container">\[x&#39; = Ax(t) + u(t),\qquad x(0) ∈ \mathcal{X}_0,\qquad (1)\]</p><p>and where <span>$u(t) ∈ U(k)$</span> add where <span>$\{U(k)\}_k$</span> is a sequence of sets of non-deterministic inputs and <span>$\mathcal{X}_0$</span> is the set of initial states. Other problems, e.g. <span>$x&#39; = Ax(t) + Bu(t)$</span> can be brought to the canonical form with the function <a href="#LinearAlgebra.normalize"><code>normalize</code></a>.</p><p>For references to the original papers introducing each algorithm, see the docstrings, e.g. <code>?Forward</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/DiscretizationModule.jl#L50-L98">source</a></section></article><h2 id="Approximation-models"><a class="docs-heading-anchor" href="#Approximation-models">Approximation models</a><a id="Approximation-models-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.NoBloatingModule.NoBloating" href="#ReachabilityAnalysis.NoBloatingModule.NoBloating"><code>ReachabilityAnalysis.NoBloatingModule.NoBloating</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoBloating{EM, SO, IT} &lt;: AbstractApproximationModel</code></pre><p>No bloating, or discrete-time, approximation model.</p><p><strong>Fields</strong></p><ul><li><code>exp</code>     – exponentiation method</li><li><code>setops</code>  – set operations method</li><li><code>inv</code>     – (optional, default: <code>false</code>) if <code>true</code>, assume that the state matrix              is invertible and use its inverse in the <code>Φ</code> functions</li></ul><p><strong>Algorithm</strong></p><p>The transformations are:</p><ul><li><span>$Φ ← \exp(Aδ)$</span></li><li><span>$Ω_0 ← \mathcal{X}_0$</span></li><li><span>$V(k) ← Φ₁(A, δ)U(k)$</span>, <span>$k ≥ 0$</span>.</li></ul><p>The function <span>$Φ₁(A, δ)$</span> is defined in <a href="#ReachabilityAnalysis.Exponentiation.Φ₁"><code>Φ₁</code></a>. We allow <span>$U$</span> to be a sequence of time varying non-deterministic input sets.</p><p>See also <a href="../../bibliography/#BogomolovFFVPS18">Bogomolov <em>et al.</em> [BFF+18]</a>, Eq. (14).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/NoBloatingModule.jl#L20-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.ForwardModule.Forward" href="#ReachabilityAnalysis.ForwardModule.Forward"><code>ReachabilityAnalysis.ForwardModule.Forward</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Forward{EM, SO, SI, IT, BT} &lt;: AbstractApproximationModel</code></pre><p>Forward approximation model.</p><p><strong>Fields</strong></p><ul><li><code>exp</code>     – exponentiation method</li><li><code>setops</code>  – set operations method</li><li><code>sih</code>     – symmetric interval hull</li><li><code>inv</code>     – (optional, default: <code>false</code>) if <code>true</code>, assume that the state matrix              is invertible and use its inverse in the <code>Φ</code> functions</li><li><code>backend</code> – (optional, default: <code>nothing</code>) used if the algorithm needs to apply              concrete polyhedral computations</li></ul><p><strong>Algorithm</strong></p><p>The transformations are:</p><ul><li><span>$Φ ← \exp(Aδ)$</span>,</li><li><span>$Ω_0 ← CH(\mathcal{X}_0, Φ\mathcal{X}_0 ⊕ δU(0) ⊕ E_ψ(U(0), δ) ⊕ E^+(\mathcal{X}_0, δ))$</span>,</li><li><span>$V(k) ← δU(k) ⊕ E_ψ(U(k), δ)$</span>.</li></ul><p>Here we allow <span>$U$</span> to be a sequence of time varying non-deterministic input sets.</p><p>For the definition of the sets <span>$E_ψ$</span> and <span>$E^+$</span> see [<a href="../../bibliography/#FrehseGDCRLRGDM11">FLD+11</a>]. The <code>Backward</code> method uses <span>$E^-$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/ForwardModule.jl#L21-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.BackwardModule.Backward" href="#ReachabilityAnalysis.BackwardModule.Backward"><code>ReachabilityAnalysis.BackwardModule.Backward</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Backward{EM, SO, SI, IT, BT} &lt;: AbstractApproximationModel</code></pre><p>Backward approximation model.</p><p><strong>Fields</strong></p><ul><li><code>exp</code>     – exponentiation method</li><li><code>setops</code>  – set operations method</li><li><code>sih</code>     – symmetric interval hull</li><li><code>inv</code>     – (optional, default: <code>false</code>) if <code>true</code>, assume that the state matrix              is invertible and use its inverse in the <code>Φ</code> functions</li><li><code>backend</code> – (optional, default: <code>nothing</code>) used if the algorithm needs to apply              concrete polyhedral computations</li></ul><p><strong>Algorithm</strong></p><p>The transformations are:</p><ul><li><span>$Φ ← \exp(Aδ)$</span>,</li><li><span>$Ω_0 ← CH(\mathcal{X}_0, Φ\mathcal{X}_0 ⊕ δU(0) ⊕ E_ψ(U(0), δ) ⊕ E^-(\mathcal{X}_0, δ))$</span>,</li><li><span>$V(k) ← δU(k) ⊕ E_ψ(U(k), δ)$</span>.</li></ul><p>Here we allow <span>$U$</span> to be a sequence of time varying non-deterministic input sets.</p><p>For the definition of the sets <span>$E_ψ$</span> and <span>$E^-$</span> see [<a href="../../bibliography/#FrehseGDCRLRGDM11">FLD+11</a>]. The <code>Forward</code> method uses <span>$E^+$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/BackwardModule.jl#L11-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.FirstOrderModule.FirstOrder" href="#ReachabilityAnalysis.FirstOrderModule.FirstOrder"><code>ReachabilityAnalysis.FirstOrderModule.FirstOrder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FirstOrder{EM} &lt;: AbstractApproximationModel</code></pre><p>First-order approximation model.</p><p><strong>Fields</strong></p><ul><li><code>exp</code> – (optional, default: <code>BaseExp</code>) exponentiation method</li></ul><p><strong>Algorithm</strong></p><p>The transformations are [<a href="../../bibliography/#LeGuernicG10">LG10</a>]:</p><ul><li><span>$Φ ← \exp(Aδ)$</span>,</li><li><span>$Ω_0 ← CH(\mathcal{X}_0, Φ\mathcal{X}_0 ⊕ δU ⊕ B_ε)$</span></li></ul><p>where <span>$B_ε$</span> is the input ball of radius <span>$ε$</span> centered in the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/FirstOrderModule.jl#L22-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.FirstOrderZonotopeModule.FirstOrderZonotope" href="#ReachabilityAnalysis.FirstOrderZonotopeModule.FirstOrderZonotope"><code>ReachabilityAnalysis.FirstOrderZonotopeModule.FirstOrderZonotope</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FirstOrderZonotope{EM} &lt;: AbstractApproximationModel</code></pre><p>First order approximation model that works with zonotopes.</p><p><strong>Fields</strong></p><ul><li><code>exp</code> – (optional, default: <code>BaseExp</code>) exponentiation method</li></ul><p><strong>Algorithm</strong></p><p>The transformations are:</p><ul><li><span>$Φ ← \exp(Aδ)$</span>,</li><li><span>$Ω_0 ← bloat(zono(CH(\mathcal{X}_0, Φ\mathcal{X}_0)), α + β)$</span></li></ul><p>where <span>$bloat(\mathcal{X}, ε)$</span> bloats the set <span>$\mathcal{X}$</span> with the value <span>$ε$</span>, <span>$zono(·)$</span> overapproximates its argument with a zonotope, and <span>$α$</span> and <span>$β$</span> are factors computed for the homogeneous system and the inputs, respectively.</p><p><strong>Reference</strong></p><p>A. Girard: Reachability of uncertain linear systems using zonotopes. HSCC 2005.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/FirstOrderZonotopeModule.jl#L21-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.SecondOrderddtModule.SecondOrderddt" href="#ReachabilityAnalysis.SecondOrderddtModule.SecondOrderddt"><code>ReachabilityAnalysis.SecondOrderddtModule.SecondOrderddt</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SecondOrderddt{EM, SO, SI, IT, BT} &lt;: AbstractApproximationModel</code></pre><p>Second-order approximation model used in the tool <code>d/dt</code>. It can be used for overapproximation and underapproximation.</p><p><strong>Fields</strong></p><ul><li><code>oa</code>      – (optional, default: <code>true</code>) flag to choose between              overapproximation and underapproximation</li><li><code>exp</code>     – (optional, default: <code>BaseExp</code>) exponentiation method</li><li><code>setops</code>  – (optional, default: <code>:lazy</code>) set operations method</li><li><code>sih</code>     – (optional, default: <code>:concrete</code>) way to compute the symmetric              interval hull</li><li><code>inv</code>     – (optional, default: <code>false</code>) if <code>true</code>, assume that the state              matrix is invertible and use its inverse in the <code>Φ</code> functions</li><li><code>backend</code> – (optional, default: <code>nothing</code>) used if the algorithm needs to              apply concrete polyhedral computations</li></ul><p><strong>Algorithm</strong></p><p>The transformations are:</p><ul><li><span>$Φ ← \exp(Aδ)$</span>,</li><li><span>$Ω_0 ← bloat(CH(\mathcal{X}_0, Φ\mathcal{X}_0), ε)$</span></li></ul><p>where <span>$bloat(\mathcal{X}, ε)$</span> bloats the set <span>$\mathcal{X}$</span> with the value <span>$ε$</span>. If <code>oa == false</code>, the bloating acts in an inverted way and shrinks the set.</p><p><strong>Reference</strong></p><p>E. Asarin, T. Dang, O. Maler, O. Bournez: <em>Approximate reachability analysis of piecewise-linear dynamical systems</em>. HSCC 2000.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/SecondOrderddtModule.jl#L20-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.CorrectionHullModule.CorrectionHull" href="#ReachabilityAnalysis.CorrectionHullModule.CorrectionHull"><code>ReachabilityAnalysis.CorrectionHullModule.CorrectionHull</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CorrectionHull{EM} &lt;: AbstractApproximationModel</code></pre><p>Discretization using the correction hull of the matrix exponential.</p><p><strong>Fields</strong></p><ul><li><code>exp</code>   – exponentiation method</li><li><code>order</code> – order of the Taylor series expansion of the matrix exponential</li></ul><p><strong>Algorithm</strong></p><p>For the homogeneous case, this method implements the transformation:</p><p class="math-container">\[Ω_0 = CH(X_0, e^{Aδ}  X_0) ⊕ FX_0\]</p><p>where <span>$F$</span> is the correction (interval) matrix.</p><p>For the inhomogeneous case, <span>$x&#39; = Ax + u$</span>,  <span>$x ∈ X, u ∈ U$</span>, implements <span>$Ω_0 = CH(X_0, exp(Aδ)  X0) ⊕ FX0$</span> where <span>$F$</span> is the correction (interval) matrix.</p><p>In both cases, if <span>$A$</span> is an interval matrix, the exponential is overapproximated using methods from <code>IntervalMatrices.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/CorrectionHullModule.jl#L25-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.StepIntersectModule.StepIntersect" href="#ReachabilityAnalysis.StepIntersectModule.StepIntersect"><code>ReachabilityAnalysis.StepIntersectModule.StepIntersect</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StepIntersect{DM&lt;:AbstractApproximationModel} &lt;: AbstractApproximationModel</code></pre><p>Approximation model that composes (intersecting) one step Forward of a given model with one step backward of the same model.</p><p><strong>Fields</strong></p><ul><li><code>model</code>  – approximation model</li><li><code>setops</code> – set operations method</li></ul><p><strong>Notes</strong></p><p>Let <span>$x&#39; = Ax$</span> with <span>$x(0) ∈ X₀$</span>. This methods consists of:</p><ul><li><p>Compute the discretized system with step-size <span>$δ$</span> obtaining <span>$Ω0$</span> and the given approximation model <code>method</code>.</p></li><li><p>Compute the (lazy) linear map <span>$ΦX₀$</span>. This set consists of the (exact) reachable states at the time point <span>$δ$</span>.</p></li><li><p>Apply the approximation model <code>method</code> with initial condition <span>$ΦX₀$</span> one step backward in time, with the state transition matrix <span>$-A$</span>, call this reach-set <span>$Ω₀₊$</span></p></li><li><p>Intersect <span>$Ω₀₋$</span> and <span>$Ω₀₊$</span> and return such set. The intersection is done either lazily or concretely depending on the specified <code>setops</code> field.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/StepIntersectModule.jl#L21-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.CorrectionHullMatrixZonotopeModule.CorrectionHullMatrixZonotope" href="#ReachabilityAnalysis.CorrectionHullMatrixZonotopeModule.CorrectionHullMatrixZonotope"><code>ReachabilityAnalysis.CorrectionHullMatrixZonotopeModule.CorrectionHullMatrixZonotope</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CorrectionHullMatrixZonotope{R} &lt;: AbstractApproximationModel</code></pre><p>Implementation of the discretization algorithm for linear systems with parametric uncertainty using matrix zonotopes by <a href="../../bibliography/#HuangLBS25">Huang <em>et al.</em> [HLBS25]</a>.</p><p><strong>Fields</strong></p><ul><li><code>taylor_order</code>     – (optional, default: <code>5</code>) order of the Taylor series                       expansion of the matrix exponential for each step</li><li><code>recursive</code>        – (optional, default: <code>false</code>) if <code>true</code>, compute the                       Taylor series expansion of the matrix zonotope                       exponential map recursively</li></ul><p><strong>Notes</strong></p><p>The <code>recursive</code> option is used to compute the Taylor expansion of the matrix zonotope exponential map. If <code>recursive == true</code>, each term of the Taylor expansion is computed recursively (e.g., <span>$A^2 P = A (A P)$</span>).</p><p>If <code>recursive == false</code>, the Taylor expansion is computed by overapproximating the matrix zonotope exponential  map, producing a single matrix that represents the exponential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/CorrectionHullMatrixZonotope.jl#L15-L37">source</a></section></article><h2 id="Exponentiation"><a class="docs-heading-anchor" href="#Exponentiation">Exponentiation</a><a id="Exponentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Exponentiation" title="Permalink"></a></h2><p>The state transition matrix of the linear ODE <span>$x&#39;(t) = Ax(t) + u(t)$</span> at time <span>$δ &gt; 0$</span> is <span>$Φ = e^{Aδ}$</span>, hence the algorithms usually require to compute exponential matrices. There are distinct ways to compute the matrix exponential <span>$e^{Aδ}$</span> depending on the type of <span>$A$</span> (see, e.g., [<a href="../../bibliography/#Higham08">Hig08</a>]). The available methods can be used through the (unexported) function <code>_exp</code>.</p><p>For high dimensional systems (typically <code>n &gt; 2000</code>), computing the matrix exponential is expensive hence it is preferable to compute the action of the matrix exponential over vectors when needed, that is, <span>$e^{δA} v$</span> for each <span>$v$</span>. This method is particularly well-suited if <code>A</code> is vert sparse. Use the option <code>exp=:krylov</code> (or <code>exp=:lazy</code>) for this purpose.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.Exponentiation" href="#ReachabilityAnalysis.Exponentiation"><code>ReachabilityAnalysis.Exponentiation</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Interface to matrix exponential backends of different kinds.</p><p>Includes common integral computations arising in the discretization of linear differential equations using matrix methods. For applications see, e.g., <a href="../../bibliography/#ForetsS22">Forets and Schilling [FS22]</a> and references therein.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/Exponentiation.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.Exponentiation._exp" href="#ReachabilityAnalysis.Exponentiation._exp"><code>ReachabilityAnalysis.Exponentiation._exp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_exp(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp)</code></pre><p>Compute the matrix exponential <span>$e^{Aδ}$</span>.</p><p><strong>Input</strong></p><ul><li><code>A</code>    – matrix</li><li><code>δ</code>    – step size</li><li><code>alg</code>  – (optional, default: <code>BaseExp</code>) the algorithm used to take the matrix           exponential of <code>Aδ</code>, possible options are <code>BaseExp</code>, <code>LazyExp</code>,           <code>PadeExp</code> and <code>IntervalExp</code> (see details in the <em>Algorithm</em> section           below)</li></ul><p><strong>Output</strong></p><p>A matrix or a lazy wrapper of the matrix exponential, depending on <code>alg</code>.</p><p><strong>Algorithm</strong></p><ul><li><p><code>BaseExp</code> – (alias: <code>:base</code>) use Higham&#39;s scaling-and-squaring method implemented              in Julia&#39;s standard library; see <code>?exp</code> for details; if <code>A</code> is a static array,              uses the implementation in <code>StaticArrays.jl</code></p></li><li><p><code>LazyExp</code> – (alias: <code>:lazy</code>) return a lazy wrapper around the matrix exponential              using the implementation <code>LazySets.SparseMatrixExp</code></p></li><li><p><code>PadeExp</code> – (alias: <code>pade</code>) apply the Padé approximant method to compute the matrix              exponential of a sparse matrix (requires <code>Expokit.jl</code>)</p></li><li><p><code>IntervalExp</code> – (alias: <code>interval</code>, <code>taylor</code>) apply the Taylor series expansion of the matrix                  exponential with an interval remainder; works if <code>A</code> is an interval matrix</p></li></ul><p><strong>Notes</strong></p><p>If the algorithm <code>LazyExp</code> is used, actions of the matrix exponential are evaluated with an external library such as <code>ExponentialUtilities.jl</code> or <code>Expokit.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/Exponentiation.jl#L122-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.Exponentiation.Φ₁" href="#ReachabilityAnalysis.Exponentiation.Φ₁"><code>ReachabilityAnalysis.Exponentiation.Φ₁</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Φ₁(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp, [isinv]::Bool=false, [Φ]=nothing)</code></pre><p>Evaluate the series</p><p class="math-container">\[Φ₁(A, δ) = ∑_{i=0}^∞ \dfrac{δ^{i+1}}{(i+1)!}A^i,\]</p><p>where <span>$A$</span> is a square matrix of order <span>$n$</span> and <span>$δ &gt; 0$</span>.</p><p><strong>Input</strong></p><ul><li><code>A</code>      – coefficients matrix</li><li><code>δ</code>      – step size</li><li><code>alg</code>    – (optional, default: <code>BaseExp</code>) the method used to take the matrix              exponential of the coefficient matrix; see the documentation of              <a href="#ReachabilityAnalysis.Exponentiation._exp"><code>_exp</code></a> for available options</li><li><code>isinv</code>  – (optional, default: <code>false</code>) if <code>true</code>, assume that the coefficients             matrix is invertible and compute <span>$A^{-1}$</span></li><li><code>Φ</code>      – (optional, default: <code>nothing</code>) optionally pass the matrix exponential <span>$e^{Aδ}$</span></li></ul><p><strong>Output</strong></p><p>A matrix.</p><p><strong>Algorithm</strong></p><p>If <span>$A$</span> is invertible, <span>$Φ₁$</span> can be computed as</p><p class="math-container">\[Φ₁(A, δ) = A^{-1}(e^{Aδ} - I_n),\]</p><p>where <span>$I_n$</span> is the identity matrix of order <span>$n$</span>.</p><p>In the general case, implemented in this function, it can be computed as submatrices of the block matrix</p><p class="math-container">\[P_{2n} = \exp \begin{pmatrix}
Aδ &amp;&amp; δI_n \\
0 &amp;&amp; 0
\end{pmatrix}.\]</p><p>It can be shown that</p><p class="math-container">\[\exp(P_{2n}) = \begin{pmatrix}
Φ(A, δ) &amp;&amp; Φ₁(A, δ) \\
0 &amp;&amp;  δI_n
\end{pmatrix}.\]</p><p>where <span>$Φ(A, δ) = e^{Aδ}$</span>. In particular, <code>Φ₁(A, δ) = P[1:n, (n+1):2*n]</code>. This method can be found in <a href="../../bibliography/#FrehseGDCRLRGDM11">Frehse <em>et al.</em> [FLD+11]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/Exponentiation.jl#L209-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.Exponentiation.Φ₂" href="#ReachabilityAnalysis.Exponentiation.Φ₂"><code>ReachabilityAnalysis.Exponentiation.Φ₂</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Φ₂(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp, [isinv]::Bool=false, [Φ]=nothing)</code></pre><p>Evaluate the series</p><p class="math-container">\[Φ₂(A, δ) = ∑_{i=0}^∞ \dfrac{δ^{i+2}}{(i+2)!}A^i,\]</p><p>where <span>$A$</span> is a square matrix of order <span>$n$</span> and <span>$δ &gt; 0$</span>.</p><p><strong>Input</strong></p><ul><li><code>A</code>      – coefficients matrix</li><li><code>δ</code>      – step size</li><li><code>alg</code>    – (optional, default: <code>BaseExp</code>) the method used to take the matrix              exponential of the coefficient matrix; see the documentation of              <a href="#ReachabilityAnalysis.Exponentiation._exp"><code>_exp</code></a> for available options</li><li><code>isinv</code>  – (optional, default: <code>false</code>) if <code>true</code>, assume that the coefficients             matrix is invertible and compute <span>$A^{-1}$</span></li><li><code>Φ</code>      – (optional, default: <code>nothing</code>) optionally pass the matrix exponential <span>$e^{Aδ}$</span></li></ul><p><strong>Output</strong></p><p>A matrix.</p><p><strong>Algorithm</strong></p><p>If <span>$A$</span> is invertible, <span>$Φ₂$</span> can be computed as</p><p class="math-container">\[Φ₂(A, δ) = A^{-2}(e^{δA} - I_n - δA).\]</p><p>In the general case, implemented in this function, it can be computed as submatrices of the block matrix</p><p class="math-container">\[P_{3n} = \exp \begin{pmatrix}
Aδ &amp;&amp; δI_n &amp;&amp; 0 \\
0 &amp;&amp; 0 &amp;&amp; δI_n \\
0 &amp;&amp; 0 &amp;&amp; 0
\end{pmatrix}.\]</p><p>It can be shown that</p><p class="math-container">\[\exp(P_{3n}) = \begin{pmatrix}
Φ(A, δ) &amp;&amp; Φ₁(A, δ) &amp;&amp; Φ₂(A, δ) \\
0 &amp;&amp; I_n     &amp;&amp; δI_n \\
0 &amp;&amp; 0     &amp;&amp; I_n
\end{pmatrix}.\]</p><p>where <span>$Φ(A, δ) = e^{Aδ}$</span>. In particular, <code>Φ₂ = P_{3n}[1:n, (2*n+1):3*n]</code>. This method can be found in <a href="../../bibliography/#FrehseGDCRLRGDM11">Frehse <em>et al.</em> [FLD+11]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/Exponentiation.jl#L342-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.Exponentiation.AbstractExpAlg" href="#ReachabilityAnalysis.Exponentiation.AbstractExpAlg"><code>ReachabilityAnalysis.Exponentiation.AbstractExpAlg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractExpAlg</code></pre><p>Abstract supertype for all exponentiation algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/Exponentiation.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.Exponentiation.BaseExpAlg" href="#ReachabilityAnalysis.Exponentiation.BaseExpAlg"><code>ReachabilityAnalysis.Exponentiation.BaseExpAlg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BaseExpAlg &lt;: AbstractExpAlg</code></pre><p>Matrix exponential using the scaling-and-squaring algorithm implemented in Julia Base.</p><p><strong>Notes</strong></p><p>The alias for this algorithm is <code>:base</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/Exponentiation.jl#L38-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.Exponentiation.LazyExpAlg" href="#ReachabilityAnalysis.Exponentiation.LazyExpAlg"><code>ReachabilityAnalysis.Exponentiation.LazyExpAlg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LazyExpAlg &lt;: AbstractExpAlg</code></pre><p>Matrix exponential computed in a lazy fashion.</p><p><strong>Fields</strong></p><ul><li><code>m</code>   – (optional, default: <code>30</code>) size of the Krylov subspace</li><li><code>tol</code> – (optional, default: <code>1e-10</code>) tolerance</li></ul><p><strong>Notes</strong></p><p>The aliases for this algorithm are <code>:lazy</code> and <code>:krylov</code>.</p><p>The operations are defined in the package <code>LazySets.jl</code> (<code>SparseMatrixExp</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/Exponentiation.jl#L53-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.Exponentiation.IntervalExpAlg" href="#ReachabilityAnalysis.Exponentiation.IntervalExpAlg"><code>ReachabilityAnalysis.Exponentiation.IntervalExpAlg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntervalExpAlg &lt;: AbstractExpAlg</code></pre><p>Matrix exponential using an interval enclosure of the Taylor series remainder.</p><p><strong>Fields</strong></p><ul><li><code>order</code> – order of the Taylor series expansion of the matrix exponential</li></ul><p><strong>Notes</strong></p><p>The aliases for this algorithm are <code>:interval</code> and <code>:taylor</code>.</p><p>This algorithm allows to overapproximate <span>$exp(Aδ)$</span> with an interval matrix. It also accepts an interval matrix <span>$A$</span> as input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/Exponentiation.jl#L80-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityAnalysis.Exponentiation.PadeExpAlg" href="#ReachabilityAnalysis.Exponentiation.PadeExpAlg"><code>ReachabilityAnalysis.Exponentiation.PadeExpAlg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PadeExpAlg &lt;: AbstractExpAlg</code></pre><p>Matrix exponential for sparse matrices using Pade approximants.</p><p><strong>Notes</strong></p><p>The alias for this algorithm is <code>:pade</code>.</p><p>This algorithm requires to load the package <code>Expokit.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/41f3967d615036a11f681767a7a86fd617ea94b8/src/Discretization/Exponentiation.jl#L106-L116">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solutions/">« Solutions</a><a class="docs-footer-nextpage" href="../projections/">Projections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 23 September 2025 02:05">Tuesday 23 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
