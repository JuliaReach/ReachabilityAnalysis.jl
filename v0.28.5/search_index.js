var documenterSearchIndex = {"docs":
[{"location":"generated_examples/Platoon/#Vehicle-Platoon","page":"Platoon","title":"Vehicle Platoon","text":"note: Overview\nSystem type: Linear hybrid system\nState dimension: 9 + time\nApplication domain: Autonomous driving","category":"section"},{"location":"generated_examples/Platoon/#Model-description","page":"Platoon","title":"Model description","text":"This benchmark considers a platoon of three vehicles following each other. In addition, loss of communication between the vehicles can occur. The hybrid model shown below has two operational modes, connected (q_c) and disconnected (or not connected, q_n).\n\n(Image: )\n\nThere are three scenarios for the loss of communication:\n\nPLAA01 (arbitrary loss) (left model): The loss of communication can occur at any time. This includes the possibility of no communication at all.\n\nPLADxy (loss at deterministic times) (central model): The loss of communication occurs at deterministic points in time, which are determined by clock constraints c_1 and c_2. The clock t is reset when communication is lost and when it is reestablished. Note that here the transitions have must-semantics, i.e., they take place as soon as possible. We will consider PLAD01: c_1 = c_2 = 5.\n\nPLANxy (loss at nondeterministic times): The loss of communication occurs during time intervals t  t_b t_c. The clock t is reset when communication is lost and when it is reestablished. Communication is reestablished at any time t  0 t_r. This scenario covers loss of communication after an arbitrarily long time t  t_c by reestablishing communication in zero time. We will consider PLAN01: t_b = 10, t_c = 20, and t_r = 20.\n\nusing ReachabilityAnalysis, SparseArrays, Symbolics\n\nconst var = @variables x[1:9] t;\nnothing #hide\n\nIn this notebook we only consider the case of deterministic switching (central model). Next we develop this model. It is convenient to create two independent functions, platoon_connected and platoon_disconnected, which describe the dynamics of the connected (resp. disconnected) modes.","category":"section"},{"location":"generated_examples/Platoon/#Dynamics-of-the-\"connected\"-platoon","page":"Platoon","title":"Dynamics of the \"connected\" platoon","text":"function platoon_connected(; deterministic_switching::Bool=true, c1=5.0)\n    n = 9 + 1\n\n    # x' = Ax + Bu + c\n    A = Matrix{Float64}(undef, n, n)\n    A[1, :] = [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0]\n    A[2, :] = [0, 0, -1.0, 0, 0, 0, 0, 0, 0, 0]\n    A[3, :] = [1.6050, 4.8680, -3.5754, -0.8198, 0.4270, -0.0450, -0.1942, 0.3626, -0.0946, 0.0]\n    A[4, :] = [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0]\n    A[5, :] = [0, 0, 1.0, 0, 0, -1.0, 0, 0, 0, 0]\n    A[6, :] = [0.8718, 3.8140, -0.0754, 1.1936, 3.6258, -3.2396, -0.5950, 0.1294, -0.0796, 0.0]\n    A[7, :] = [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]\n    A[8, :] = [0, 0, 0, 0, 0, 1.0, 0, 0, -1.0, 0]\n    A[9, :] = [0.7132, 3.5730, -0.0964, 0.8472, 3.2568, -0.0876, 1.2726, 3.0720, -3.1356, 0.0]\n    A[10, :] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0] # t' = 1\n\n    if deterministic_switching\n        invariant = HalfSpace(t <= c1, var)\n    else\n        invariant = Universe(n)\n    end\n\n    # acceleration of the lead vehicle + time\n    B = sparse([2], [1], [1.0], n, 1)\n    U = Hyperrectangle(; low=[-9.0], high=[1.0])\n    c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0]\n    @system(x' = A * x + B * u + c, x ∈ invariant, u ∈ U)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/Platoon/#Dynamics-of-the-\"disconnected\"-platoon","page":"Platoon","title":"Dynamics of the \"disconnected\" platoon","text":"function platoon_disconnected(; deterministic_switching::Bool=true, c2=5.0)\n    n = 9 + 1\n\n    # x' = Ax + Bu + c\n    A = Matrix{Float64}(undef, n, n)\n    A[1, :] = [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0]\n    A[2, :] = [0, 0, -1.0, 0, 0, 0, 0, 0, 0, 0]\n    A[3, :] = [1.6050, 4.8680, -3.5754, 0, 0, 0, 0, 0, 0, 0]\n    A[4, :] = [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0]\n    A[5, :] = [0, 0, 1.0, 0, 0, -1.0, 0, 0, 0, 0]\n    A[6, :] = [0, 0, 0, 1.1936, 3.6258, -3.2396, 0, 0, 0, 0.0]\n    A[7, :] = [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]\n    A[8, :] = [0, 0, 0, 0, 0, 1.0, 0, 0, -1.0, 0]\n    A[9, :] = [0.7132, 3.5730, -0.0964, 0.8472, 3.2568, -0.0876, 1.2726, 3.0720, -3.1356, 0.0]\n    A[10, :] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0] # t' = 1\n\n    if deterministic_switching\n        invariant = HalfSpace(t <= c2, var)\n    else\n        invariant = Universe(n)\n    end\n\n    # acceleration of the lead vehicle + time\n    B = sparse([2], [1], [1.0], n, 1)\n    U = Hyperrectangle(; low=[-9.0], high=[1.0])\n    c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0]\n    @system(x' = A * x + B * u + c, x ∈ invariant, u ∈ U)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/Platoon/#Hybrid-system","page":"Platoon","title":"Hybrid system","text":"function platoon(; deterministic_switching::Bool=true,\n                 c1=5.0,  # clock constraint\n                 c2=5.0,  # clock constraint\n                 tb=10.0,  # lower bound for loss of communication\n                 tc=20.0,  # upper bound for loss of communication\n                 tr=20.0)  # reset time\n\n    # three variables for each vehicle, (ei, d(et)/dt, ai) for\n    # (spacing error, relative velocity, speed), and the last dimension is time\n    n = 9 + 1\n\n    # transition graph\n    automaton = GraphAutomaton(2)\n    add_transition!(automaton, 1, 2, 1)\n    add_transition!(automaton, 2, 1, 2)\n\n    # modes\n    mode1 = platoon_connected(; deterministic_switching=deterministic_switching, c1=c1)\n    mode2 = platoon_disconnected(; deterministic_switching=deterministic_switching, c2=c2)\n    modes = [mode1, mode2]\n\n    # common reset\n    reset = Dict(n => 0.0)\n\n    # transition l1 -> l2\n    if deterministic_switching\n        guard = Hyperplane(t == c1, var)\n    else\n        guard = HPolyhedron([tb <= t, t <= tc], var)\n    end\n    t1 = ConstrainedResetMap(n, guard, reset)\n\n    # transition l2 -> l1\n    if deterministic_switching\n        guard = Hyperplane(t == c2, var)\n    else\n        guard = HalfSpace(t <= tr, var)\n    end\n    t2 = ConstrainedResetMap(n, guard, reset)\n\n    resetmaps = [t1, t2]\n    H = HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])\n\n    # initial condition: at the origin in mode 1\n    X0 = BallInf(zeros(n), 0.0)\n    initial_condition = [(1, X0)]\n\n    return IVP(H, initial_condition)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/Platoon/#Specification","page":"Platoon","title":"Specification","text":"The goal is to prove that the minimum distance between vehicles is preserved. The choice of the coordinate system is such that the minimum distance is a negative value. We consider the following family of specifications:\n\nBNDxy: Bounded time (no explicit bound on the number of transitions): For all t  0 20 s,\n\nx_1(t)  d_min m\nx_4(t)  d_min m\nx_7(t)  d_min m\n\nConcretely, we choose the following two cases of increasing difficulty:\n\nBND42: d_min = 42.\n\nBND30: d_min = 30.\n\nfunction dmin_specification(sol, dmin)\n    return (-ρ(sparsevec([1], [-1.0], 10), sol) ≥ -dmin) &&\n           (-ρ(sparsevec([4], [-1.0], 10), sol) ≥ -dmin) &&\n           (-ρ(sparsevec([7], [-1.0], 10), sol) ≥ -dmin)\nend\n\nprob_PLAD01 = platoon();\nnothing #hide","category":"section"},{"location":"generated_examples/Platoon/#Results","page":"Platoon","title":"Results","text":"","category":"section"},{"location":"generated_examples/Platoon/#PLAD01-BND42","page":"Platoon","title":"PLAD01 - BND42","text":"This scenario can be solved using a hyperrectangular set representation with step size δ = 001. We use a template that contains all box (i.e., canonical) directions in the ambient space of the state space (plus time), mathbbR^10. There are 20 such directions, two for each coordinate:\n\nboxdirs = BoxDirections(10)\nlength(boxdirs)\n\nalg = BOX(; δ=0.01)\nsol_PLAD01_BND42 = solve(prob_PLAD01;\n                         alg=alg,\n                         clustering_method=BoxClustering(1),\n                         intersection_method=TemplateHullIntersection(boxdirs),\n                         intersect_source_invariant=false,\n                         T=20.0);\nnothing #hide\n\nWe verify that the specification holds:\n\n@assert dmin_specification(sol_PLAD01_BND42, 42) \"the property should be proven\"\n\nIn more detail, we can check how far the flowpipe is from violating the property. The specification requires that each of the following quantities is greater than -dmin = -42.\n\nMinimum of x_1(t):\n\n-ρ(sparsevec([1], [-1.0], 10), sol_PLAD01_BND42)\n\nMinimum of x_4(t):\n\n-ρ(sparsevec([4], [-1.0], 10), sol_PLAD01_BND42)\n\nMinimum of x_7(t):\n\n-ρ(sparsevec([7], [-1.0], 10), sol_PLAD01_BND42)\n\nNext, we plot variable x_1 over time.\n\nusing Plots, LaTeXStrings\nimport DisplayAs  #hide\n\nfig = plot(sol_PLAD01_BND42; vars=(0, 1), xlab=L\"t\", ylab=L\"x_1\", title=\"PLAD01 - BND42\", lw=0.1)\nplot!(x -> x, x -> -42.0, 0.0, 20.0; linewidth=2, color=\"red\", ls=:dash, leg=nothing)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/Platoon/#PLAD01-BND30","page":"Platoon","title":"PLAD01 - BND30","text":"Note that the previous solution obtained for PLAD01 - BND42 does not verify the BND30 specifications since, for example, the minimum of variable x_4(t) is  -3552, which is below the given bound -d_min = -30. As a consequence, to prove the safety properties for this scenario, we have to use a solver with more precision. Instead of the BOX algorithm, we will use LGG09 with step-size δ = 003 and octagonal template directions. There are 200 such directions:\n\noctdirs = OctDirections(10)\nlength(octdirs)\n\ntip: Performance tip\nThe increase in the number of directions implies an increase in run time. Since evaluating the 200 directions of the template is quite expensive, we use a concrete set after the discretization (instead of using a lazy discretization). This is achieved by passing the option approx_model=Forward(setops=octdirs) to the LGG09 algorithm, specifying that we want to oveapproximate the initial set of the set-based recurrence with an octagonal template. In this example, this option gives a gain in runtime of 30, without a noticeable loss in precision.\n\nalg = LGG09(; δ=0.03, template=octdirs, approx_model=Forward(; setops=octdirs))\nsol_PLAD01_BND30 = solve(prob_PLAD01;\n                         alg=alg,\n                         clustering_method=LazyClustering(1),\n                         intersection_method=TemplateHullIntersection(octdirs),\n                         intersect_source_invariant=false,\n                         T=20.0);\nnothing #hide\n\nWe verify that the specification holds:\n\n@assert dmin_specification(sol_PLAD01_BND30, 30) \"the property should be proven\"\n\nCheck in more detail how close the flowpipe is to the safety conditions:\n\nMinimum of x_1(t):\n\n-ρ(sparsevec([1], [-1.0], 10), sol_PLAD01_BND30)\n\nMinimum of x_4(t):\n\n-ρ(sparsevec([4], [-1.0], 10), sol_PLAD01_BND30)\n\nMinimum of x_7(t):\n\n-ρ(sparsevec([7], [-1.0], 10), sol_PLAD01_BND30)\n\nFinally, we plot variable x_1 over time again.\n\nfig = plot(sol_PLAD01_BND30; vars=(0, 1), xlab=L\"t\", ylab=L\"x_1\", title=\"PLAD01 - BND30\", lw=0.1)\nplot!(x -> x, x -> -30.0, 0.0, 20.0; linewidth=2, color=\"red\", ls=:dash, leg=nothing)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"man/algorithms/GLGM06/#Zonotope-based-method-(GLGM06)","page":"GLGM06","title":"Zonotope-based method (GLGM06)","text":"","category":"section"},{"location":"man/algorithms/GLGM06/#Method","page":"GLGM06","title":"Method","text":"","category":"section"},{"location":"man/algorithms/GLGM06/#Examples","page":"GLGM06","title":"Examples","text":"","category":"section"},{"location":"man/examples_overview/#Overview","page":"Overview","title":"Overview","text":"We organize the models by the type of nonlinearities (if there are some), and whether they are purely continuous or present discrete transitions, i.e. hybrid systems. We have added a column with the associated scientific domain, and another column with the number of state variables. Roughly speaking, a higher number of state variables usually corresponds to problems which are harder to solve, although strictly speaking, this usually depends on the property to be verified.\n\nColumn P.V. refers to the cases where the example is presented with at lest one instance with parameter variation.","category":"section"},{"location":"man/examples_overview/#Further-examples","page":"Overview","title":"Further examples","text":"In addition to those present in this manual, a larger collection of examples can be found in the models library ReachabilityModels.jl. For further instructions see the section Model library.","category":"section"},{"location":"man/examples_overview/#Linear-continuous","page":"Overview","title":"Linear continuous","text":"Name Area State dim.\nDamped oscillator Physics 2\nBuilding Mechanical Engineering 48\nTransmission line circuit Power Systems Stability 4 to 40\nInternational Space Station Aerospace Engineering 270\nModified Nodal Analysis 1 Electronics 1002\nModified Nodal Analysis 2 Electronics 10913\nHeat PDE Physics 125 to 125000","category":"section"},{"location":"man/examples_overview/#Linear-hybrid","page":"Overview","title":"Linear hybrid","text":"Name Area State dim.\nAmplifier circuit Electronic Engineering 2\nElectromechanic break Electronic Engineering \nGearbox Mechanical Engineering \nPlatoon Autonomous Driving \nPowertrain Mechanical Engineering ","category":"section"},{"location":"man/examples_overview/#Nonlinear-continuous","page":"Overview","title":"Nonlinear continuous","text":"Name Area State dim.\nBrusselator  \nLaub-Loomis Molecular Biology 7\nLorenz system  \nLotka-Volterra  \nProduction-Destruction Electrical engineering \nQuadrotor  \nSEIR Model  \nVan der Pol  ","category":"section"},{"location":"man/examples_overview/#Nonlinear-hybrid","page":"Overview","title":"Nonlinear hybrid","text":"Name Area State dim.\nSpacecraft  \nLotka-Volterra w/crossing Biology, Nonlinear physics ","category":"section"},{"location":"man/benchmarks/filtered_oscillator/#Scalability-evaluation","page":"Filtered oscillator","title":"Scalability evaluation","text":"Scalability is very important in the applicability of a tool. For illustration purposes, in this section we consider the scalability of the hybrid reachability solver, using different algorithm choices, for the filtered switched oscillator model from Frehse et al. [FLD+11]. The model consists of a two-dimensional switched oscillator and a parametric number of filters which are used to smooth the oscilllator's state. An interesting aspect of the model is that it is scalable: the total number of continuous variables can be made arbitrarily large. Moreover, this is a challenging benchmark since several dozens of reach-sets may take each discrete jumps, hence clustering methods are indispensable.\n\nThe continuous variables x and y are used to denote the state of the oscillator, and the remaining m variables are used for the state of the filters. In this evaluation we consider that the number of filters ranges from 64 to 1024. To measure the quality of the approximations, we consider the safety property given by y(t)  05 for all t  0 T.\n\nThe filtered oscillator was also studied in Bogomolov et al. [BFF+18] to test the scalability of a new scheme that exploits the sparsity of the hybrid automaton to efficiently compute flowpipe-guard intersections. Such scheme is not considered in this section.\n\nRecall that for a system of n variables, a box overapproximation requires to compute n samples of the approximation boundary, whereas an octagon requires O(n^2) many. Hence, using an octagon template, while gives tighter results in general, may incur in much higher computational cost if n is high.","category":"section"},{"location":"man/benchmarks/filtered_oscillator/#Model","page":"Filtered oscillator","title":"Model","text":"using ReachabilityAnalysis\n\none_loop_iteration = false\nn0 = 4\nn1 = (one_loop_iteration ? n0 + 1 : n0)\nn = n1 + 2\nz = zeros(n1)\n\n## common flow\nA = zeros(n, n)\nA[1,1], A[2,2] = -2., -1.\nA[3,1], A[3,3] = 5., -5.\nfor i = 4 : n-1\n    A[i,i-1], A[i,i] = 5., -5.\nend\n\nfunction mode1(z)\n    b = [1.4; -0.7; z]\n    X = HPolyhedron([HalfSpace([-0.714286; -1.0; z], 0.0),  # 0.714286*x + y >= 0\n                     HalfSpace([1.0; 0.0; z], 0.0)])  # x <= 0\n    @system(x' = Ax + b, x ∈ X)\nend\n\nfunction mode2(z)\n    b = [-1.4; 0.7; z]\n    X = HPolyhedron([HalfSpace([1.0; 0.0; z], 0.0),  # x <= 0\n                     HalfSpace([0.714286; 1.0; z], 0.0)])  # 0.714286*x + y <= 0\n    @system(x' = Ax + b, x ∈ X)\nend\n\nfunction mode3(z)\n    b = [1.4; -0.7; z]\n    X = HPolyhedron([HalfSpace([-1.0; 0.0; z], 0.0),  # x >= 0\n                     HalfSpace([-0.714286; -1.0; z], 0.0)])  # 0.714286*x + y >= 0\n    @system(x' = Ax + b, x ∈ X)\nend\n\nfunction mode4(z, one_loop_iteration)\n    b = [-1.4; 0.7; z]\n    X = HPolyhedron([HalfSpace([0.714286; 1.0; z], 0.0),  # 0.714286*x + y <= 0\n                     HalfSpace([-1.0; 0.0; z], 0.0)])  # x >= 0\n\n    if one_loop_iteration\n        ## k <= 2 (2.1 to avoid numerical issues)\n        addconstraint!(X, HalfSpace([zeros(n-1); 1.], 2.1))\n    end\n    @system(x' = Ax + b, x ∈ X)\nend\n\n\nfunction filtered_oscillator_hybrid(n0, one_loop_iteration)\n\n    n1 = (one_loop_iteration ? n0 + 1 : n0)\n    n = n1 + 2\n    z = zeros(n1)\n\n    ## transition graph (automaton)\n    a = GraphAutomaton(4)\n    add_transition!(a, 3, 4, 1)\n    add_transition!(a, 4, 2, 2)\n    add_transition!(a, 2, 1, 3)\n    add_transition!(a, 1, 3, 4)\n\n    mode1 = mode1(z)\n    mode2 = mode2(z)\n    mode3 = mode3(z)\n    mode4 = mode4(z, one_loop_iteration)\n    m = [mode1, mode2, mode3, mode4]\n\n    ## transitions\n\n    ## transition l3 -> l4\n    X_l3l4 = HPolyhedron([HalfSpace([-1.0; 0.0; z], 0.0),  # x >= 0\n                          HalfSpace([-0.714286; -1.0; z], 0.0),  # 0.714286*x + y >= 0\n                          HalfSpace([0.714286; 1.0; z], 0.0)])  # 0.714286*x + y <= 0\n    if one_loop_iteration\n        A_trans_34 = Matrix(1.0I, n, n)\n        A_trans_34[n, n] = 2.  # k' = k * 2\n        r1 = ConstrainedLinearMap(A_trans_34, X_l3l4)\n    else\n        r1 = ConstrainedIdentityMap(n, X_l3l4)\n    end\n\n    ## transition l4 -> l2\n    X_l4l2 = HPolyhedron([HalfSpace([0.714286; 1.0; z], 0.0),  # 0.714286*x + y <= 0\n                          HalfSpace([-1.0; 0.0; z], 0.0),  # x >= 0\n                          HalfSpace([1.0; 0.0; z], 0.0)])  # x <= 0\n    r2 = ConstrainedIdentityMap(n, X_l4l2)\n\n    ## transition l2 -> l1\n    X_l2l1 = HPolyhedron([HalfSpace([1.0; 0.0; z], 0.0),  # x <= 0\n                          HalfSpace([-0.714286; -1.0; z], 0.0),  # 0.714286*x + y >= 0\n                          HalfSpace([0.714286; 1.0; z], 0.0)])  # 0.714286*x + y <= 0\n    r3 = ConstrainedIdentityMap(n, X_l2l1)\n\n    ## transition l1 -> l3\n    X_l1l3 = HPolyhedron([HalfSpace([-0.714286; -1.0; z], 0.0),  # 0.714286*x + y >= 0\n                          HalfSpace([-1.0; 0.0; z], 0.0),  # x >= 0\n                          HalfSpace([1.0; 0.0; z], 0.0)])  # x <= 0\n    r4 = ConstrainedIdentityMap(n, X_l1l3)\n\n    r = [r1, r2, r3, r4]\n\n    ## switchings\n    s = [HybridSystems.AutonomousSwitching()]\n\n    return HybridSystem(a, m, r, s)\nend\n\nfunction fosc(X0; n0::Int=4, one_loop_iteration::Bool=false)\n    H = filtered_oscillator_hybrid(n0, one_loop_iteration)\n    return IVP(H, [(1, X0)])\nend","category":"section"},{"location":"man/benchmarks/filtered_oscillator/#Results","page":"Filtered oscillator","title":"Results","text":"","category":"section"},{"location":"generated_examples/VanDerPol/#Van-der-Pol-oscillator","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"note: Overview\nSystem type: Polynomial continuous system\nState dimension: 2\nApplication domain: Nonlinear physics\n\nThe Van der Pol oscillator was introduced by the Dutch physicist Balthasar van der Pol. This is a famous model, typically investigated in the study of nonlinear dynamics. The model presents non-conservative oscillations with non-linear damping. In the past, it has been of relevance in several practical problems of engineering such as circuits containing vacuum tubes. For more information on the model, see Wikipedia.\n\nHere we compute the evolution of the limit cycle in the phase plane for a set of initial conditions. For this set, we consider a safety property, originally from Althoff et al. [ABF+19], that there is no solution starting from the initial set that exceeds a prescribed upper bound on the velocity y(t) = x(t) at all times in the given time span. Moreover, we also illustrate the computation of an invariant set using the obtained flowipe. Finally, we study the limit cycle à la Poincaré by defining a function that computes the cross section of the flowpipe at each revolution. Interestingly, this method gives an algorithmic proof that the safety condition obtained previously is actually verified at all times, i.e. over the unbounded time horizon 0 ).","category":"section"},{"location":"generated_examples/VanDerPol/#Model-description","page":"Van der Pol oscillator","title":"Model description","text":"The dynamics of the Van der Pol oscillator are described by the following differential equations with two variables:\n\nbeginaligned\n    dotx = y \n    doty = μ (1 - x^2) y - x\nendaligned\n\nThe system has a stable limit cycle. This limit cycle becomes increasingly sharp for higher values μ. Here we consider the parameter μ = 1.\n\nusing ReachabilityAnalysis\n\n@taylorize function vanderpol!(du, u, p, t)\n    x, y = u\n    local μ = 1.0\n    du[1] = y\n    du[2] = (μ * y) * (1 - x^2) - x\n    return du\nend\n\ntip: Performance tip\nAdvanced users may want to consider the section Some common gotchas to improve the code that is generated by @taylorize by re-writing the right-hand side of dx[2] with the use of auxiliary variables.","category":"section"},{"location":"generated_examples/VanDerPol/#Specification","page":"Van der Pol oscillator","title":"Specification","text":"We set the initial condition x(0)  125 155, y(0)  235245. The unsafe set is given by y  275 for a time span 0 7. In other words, we would like to prove that there does not exist a solution of the model with a y value which is greater than 2.75, for any initial condition from the given domain. The time horizon T = 7 is chosen such that the oscillator can do at least one full cycle.\n\nX0 = Hyperrectangle(; low=[1.25, 2.35], high=[1.55, 2.45])\nprob = @ivp(x' = vanderpol!(x), dim:2, x(0) ∈ X0);\nnothing #hide","category":"section"},{"location":"generated_examples/VanDerPol/#Analysis","page":"Van der Pol oscillator","title":"Analysis","text":"sol = solve(prob; T=7.0, alg=TMJets(; abstol=1e-12));\nnothing #hide\n\nFor further computations, it is convenient to work with a zonotopic overapproximation of the flowpipe.\n\nsolz = overapproximate(sol, Zonotope);\nnothing #hide\n\nThe maximum value of variable y is obtained by computing the support function of the flowpipe along direction 0 1:\n\ny_bound = ρ([0.0, 1.0], solz)\n@assert y_bound < 2.75 \"the property should be proven\"\ny_bound\n\nThis shows that the property is satisfied. Below we plot the flowpipe in the x-y plane, together with the horizontal line y = 275.","category":"section"},{"location":"generated_examples/VanDerPol/#Results","page":"Van der Pol oscillator","title":"Results","text":"using Plots\nimport DisplayAs  #hide\n\nfig = plot(solz; vars=(1, 2), lw=0.2, xlims=(-2.5, 2.5), xlab=\"x\", ylab=\"y\")\nplot!(x -> 2.75; color=:red, lab=\"y = 2.75\", ls=:dash, legend=:bottomright)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nWe can also plot the state variables x(t) and y(t) as a function of time (recall that 0 in vars is used to denote the time variable):\n\nfig = plot(solz; vars=(0, 1), lw=0.2, xlab=\"t\", ylab=\"x\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nfig = plot(solz; vars=(0, 2), lw=0.2, xlab=\"t\", ylab=\"y\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/VanDerPol/#Invariant-Set","page":"Van der Pol oscillator","title":"Invariant Set","text":"We can use the reachability result to examine an invariant of the system. In other words, we can algorithmically prove that the flowpipe re-enters from where it started after one loop iteration, using inclusion checks.\n\nfig = plot(solz; vars=(1, 2), lw=0.2, xlims=(0.0, 2.5), ylims=(1.6, 2.8), xlab=\"x\", ylab=\"y\")\nplot!(solz[1:13]; vars=(1, 2), color=:green, lw=1, alpha=0.5, lab=\"F[1:13]\")\nplot!(solz[388]; vars=(1, 2), color=:red, lw=1, alpha=0.6, lab=\"F[388]\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nIt can be seen that the reach set at index 388 corresponding to the time-span\n\ntspan(solz[388])\n\nis included in the set union F1  cdots  F13 of previously computed reach sets. Notice that all future trajectories starting from the 388-th reach set are already covered by the flowpipe. Therefore, we have found an invariant set.","category":"section"},{"location":"generated_examples/VanDerPol/#Limit-cycle","page":"Van der Pol oscillator","title":"Limit cycle","text":"To examine the limit cycle, we can intersect a line segment perpendicular to the flowpipe, which will allow us to get a cross section of the sets in order to prove that after one cycle the intersection segment actually shrinks. This approach is similar to the method of Poincaré sections.\n\nline = LineSegment([1, 2.0], [2.0, 2.5])\nfig = plot(solz; vars=(1, 2), lw=0.2, xlims=(0.0, 2.5), ylims=(1.6, 2.8), xlab=\"x\", ylab=\"y\")\nplot!(solz[1:13]; vars=(1, 2), color=:green, lw=1.0, alpha=0.5, lab=\"F[1:13]\")\nplot!(solz[388]; vars=(1, 2), color=:red, lw=1.0, alpha=0.6, lab=\"F[388]\")\nplot!(line; lw=2.0)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nNext, we define a function to get the cross section of the flowpipe. The function needs the flowpipe, a line segment that cuts the flowpipe, and the indices of the subsets to cut.\n\nfunction cross_section(line::LineSegment, F, idx)\n    p = VPolygon()\n    for i in idx\n        x = intersection(line, set(F[i]))\n        if !isempty(x)\n            p = convex_hull(p, x)\n        end\n    end\n    vl = vertices_list(p)\n    @assert length(vl) == 2\n    return LineSegment(vl[1], vl[2])\nend;\nnothing #hide\n\nThen we can get the cross section of the first 13 sets and the last set.\n\nifirst = cross_section(line, solz, 1:13)\nilast = cross_section(line, solz, [388]);\nnothing #hide\n\nWe can also calculate the length of each cross section.\n\nlfirst = norm(ifirst.q - ifirst.p)\n\nllast = norm(ilast.q - ilast.p)\n\nfig = plot(ifirst; lw=3.0, alpha=1.0, label=\"First subsets\", legend=:bottomright)\nplot!(ilast; lw=5.0, alpha=1.0, label=\"Last subset\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nThe inclusion check succeeds:\n\n@assert ilast ⊆ ifirst \"the cross section should get smaller\"\n\nAs we can see, the cross section of the last reach set is a subset of the first 13 reach sets. Thus, the cycle will continue, presumably getting smaller each revolution.","category":"section"},{"location":"lib/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"lib/solutions/#Abstract-interface","page":"Solutions","title":"Abstract interface","text":"","category":"section"},{"location":"lib/solutions/#Solution-of-a-reachability-problem","page":"Solutions","title":"Solution of a reachability problem","text":"","category":"section"},{"location":"lib/solutions/#Solution-of-a-verification-problem","page":"Solutions","title":"Solution of a verification problem","text":"","category":"section"},{"location":"lib/solutions/#Solving-a-reachability-problem","page":"Solutions","title":"Solving a reachability problem","text":"","category":"section"},{"location":"lib/solutions/#Solving-a-hybrid-reachability-problem","page":"Solutions","title":"Solving a hybrid reachability problem","text":"TODO: document other methods in solutions.jl.","category":"section"},{"location":"lib/solutions/#ReachabilityAnalysis.AbstractSolution","page":"Solutions","title":"ReachabilityAnalysis.AbstractSolution","text":"AbstractSolution\n\nAbstract supertype of all solution types of a rechability problem.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#ReachabilityAnalysis.ReachSolution","page":"Solutions","title":"ReachabilityAnalysis.ReachSolution","text":"ReachSolution{FT<:AbstractFlowpipe, ST<:AbstractPost} <: AbstractSolution\n\nType that wraps the solution of a reachability problem as a sequence of lazy sets, and a dictionary of options.\n\nFields\n\nXk       – the list of AbstractReachSets\nalg      – algorithm used\noptions  – the dictionary of options\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#ReachabilityAnalysis.CheckSolution","page":"Solutions","title":"ReachabilityAnalysis.CheckSolution","text":"CheckSolution{T} <: AbstractSolution\n\nType that wraps the solution of a verification problem.\n\nFields\n\nTODO\n\nNotes\n\nThis type contains the answer if the property is satisfied, and if not, it contains the index at which the property might be violated for the first time.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#CommonSolve.solve","page":"Solutions","title":"CommonSolve.solve","text":"solve(ivp::IVP{<:AbstractContinuousSystem}, tspan, alg; kwargs...)\n\nSolves the initial-value problem defined by ivp over the time span tspan, using the algorithm alg. If no algorithm is given, a default algorithm is chosen.\n\nInput\n\nivp   – initial-value problem\ntspan – time span for this initial-value problem\nalg   – reachability algorithm\n\nAdditional options are passed as arguments or keyword arguments; see the notes below for details. See the online documentation for examples.\n\nOutput\n\nThe solution of a reachability problem, as an instance of a ReachSolution.\n\nNotes\n\nUse the alg, algorithm or opC keyword arguments to specify the algorithm to solve the initial-value problem. Algorithm-specific options should be passed to the algorithm constructor as well.\nUse the tspan keyword argument to specify the time span; it can be:\na tuple,\nan interval, or\na vector with two components.\nUse the T keyword argument to specify the time horizon; the initial time is then assumed to be zero.\nUse the static keyword argument to force conversion to static arrays in the algorithm (should be supported by the algorithm).\nUse the NSTEPS keyword argument to specify the number of discrete steps solved in the set-based recurrence.\nUse the threading option to use multi-threading parallelism. This option applies for initial-value problems whose initial condition is a vector of sets.\n\n\n\n\n\n","category":"function"},{"location":"lib/solutions/#ReachabilityAnalysis.AbstractPost","page":"Solutions","title":"ReachabilityAnalysis.AbstractPost","text":"AbstractPost\n\nAbstract supertype of all post operator types.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#ReachabilityAnalysis.AbstractContinuousPost","page":"Solutions","title":"ReachabilityAnalysis.AbstractContinuousPost","text":"AbstractContinuousPost\n\nAbstract supertype of all continuous post operators.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#ReachabilityAnalysis.AbstractDiscretePost","page":"Solutions","title":"ReachabilityAnalysis.AbstractDiscretePost","text":"AbstractDiscretePost\n\nAbstract supertype of all discrete post operators.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#ReachabilityAnalysis.AbstractWaitingList","page":"Solutions","title":"ReachabilityAnalysis.AbstractWaitingList","text":"AbstractWaitingList\n\nAbstract supertype for all waiting list types.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#ReachabilityAnalysis.WaitingList","page":"Solutions","title":"ReachabilityAnalysis.WaitingList","text":"WaitingList{TN, ST, M, QT<:StateInLocation{ST, M}} <: AbstractWaitingList\n\nIterable container representing a list of pairs (set, mode) of a hybrid automaton.\n\nFields\n\ntimes  – vector with a time interval associated to each state\narray  – vector of StateInLocation\n\nNotes\n\nA WaitingList is a list of pairs `(set_i, loc_i) for i in 1..k where times is a vector with a time interval associated to each state.\n\nThis waiting list allows for a unique set representation (ST) for all elements of the list.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#ReachabilityAnalysis.StateInLocation","page":"Solutions","title":"ReachabilityAnalysis.StateInLocation","text":"StateInLocation{ST,M}\n\nStruct that associates a set with a hybrid automaton's location index, usually an integer.\n\n\n\n\n\n","category":"type"},{"location":"lib/systems/#Systems","page":"Systems","title":"Systems","text":"Systems types are defined in the library MathematicalSystems.jl. Apart from purely discrete or continuous, hybrid automata (i.e. those mixing discrete-continuous dynamics) are defined in HybridSystems.jl.\n\nPages = [\"systems.md\"]\nDepth = 3","category":"section"},{"location":"lib/systems/#Types-and-macros","page":"Systems","title":"Types and macros","text":"The API reference for systems types and macros can be found in the MathematicalSystems.jl documentation. Two commonly used macros are @system and @ivp, used to define a system and an initial-value problem respectively.","category":"section"},{"location":"lib/systems/#Normalization","page":"Systems","title":"Normalization","text":"","category":"section"},{"location":"lib/systems/#Homogenization","page":"Systems","title":"Homogenization","text":"","category":"section"},{"location":"lib/systems/#Hybrid-systems","page":"Systems","title":"Hybrid systems","text":"","category":"section"},{"location":"lib/systems/#LinearAlgebra.normalize-Tuple{AbstractSystem}","page":"Systems","title":"LinearAlgebra.normalize","text":"normalize(system::AbstractSystem)\n\nTransform a mathematical system to a normalized (or canonical) form.\n\nInput\n\nsystem – system; it can be discrete or continuous\n\nOutput\n\nEither the same system if it already conforms to a canonical form, or a new system otherwise.\n\nNotes\n\nThe normalization procedure consists of transforming a given system type into a \"canonical\" format that is used internally. More details are given below.\n\nAlgorithm\n\nThe implementation of normalize exploits MathematicalSystems's' types, which carry information about the problem as a type parameter.\n\nHomogeneous ODEs of the form x = Ax x  mathcalX are canonical if the associated problem is a ConstrainedLinearContinuousSystem and A is a matrix. This type does not handle non-deterministic inputs.\n\nNote that a LinearContinuousSystem does not consider constraints on the state-space (such as an invariant); to specify state constraints, use a ConstrainedLinearContinuousSystem. If the passed system is a LinearContinuousSystem (i.e. no constraints) then the normalization fixes a universal set (Universe) as the constraint set.\n\nThe generalization to canonical systems with constraints and possibly time-varying non-deterministic inputs is considered next. These systems are of the form x = Ax + u u  mathcalU x  mathcalX. The system type is ConstrainedLinearControlContinuousSystem, where A is a matrix, X is a set and U is an input, that is, any concrete subtype of AbstractInput.\n\nIf U is not given as an input, normalization accepts either a LazySet, or a vector of LazySets. In these cases, the sets are wrapped around an appropriate concrete input type.\n\nIf the system does not conform to a canonical form, the implementation tries to make the transformation; otherwise an error is thrown. In particular, ODEs of the form x = Ax + Bu are mapped into x = Ax + u u  BmathcalU, where now u has the same dimensions as x.\n\nThe transformations described above are analogous in the discrete case, i.e. x_k+1 = A x_k and x_k+1 = Ax_k + u_k u_k  mathcalU x_k  mathcalX for the linear and affine cases respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/systems/#LinearAlgebra.normalize-Tuple{InitialValueProblem}","page":"Systems","title":"LinearAlgebra.normalize","text":"normalize(ivp::InitialValueProblem)\n\nTransform an initial-value problem into a normalized (or canonical) form.\n\nInput\n\nivp – initial-value problem\n\nOutput\n\nEither the same initial-value problem if it already conforms to a canonical form, or a new one otherwise.\n\nNotes\n\nThis function extends normalize for initial-value problems.\n\n\n\n\n\n","category":"method"},{"location":"lib/systems/#ReachabilityAnalysis.add_dimension","page":"Systems","title":"ReachabilityAnalysis.add_dimension","text":"add_dimension(A::AbstractMatrix, m=1)\n\nAppend one or more zero rows and columns to a matrix.\n\nInput\n\nA – matrix\nm – (optional, default: 1) the number of extra dimensions\n\nExamples\n\njulia> using ReachabilityAnalysis: add_dimension\n\njulia> A = [0.4 0.25; 0.46 -0.67]\n2×2 Matrix{Float64}:\n 0.4    0.25\n 0.46  -0.67\n\njulia> add_dimension(A)\n3×3 Matrix{Float64}:\n 0.4    0.25  0.0\n 0.46  -0.67  0.0\n 0.0    0.0   0.0\n\nTo append more than one zero row-column, use the second argument m:\n\njulia> add_dimension(A, 2)\n4×4 Matrix{Float64}:\n 0.4    0.25  0.0  0.0\n 0.46  -0.67  0.0  0.0\n 0.0    0.0   0.0  0.0\n 0.0    0.0   0.0  0.0\n\n\n\n\n\nadd_dimension(X::LazySet, m=1)\n\nAdds an extra dimension to a LazySet through a Cartesian product.\n\nInput\n\nX – a lazy set\nm – (optional, default: 1) the number of extra dimensions\n\nExamples\n\njulia> using ReachabilityAnalysis: add_dimension\n\njulia> X = BallInf(ones(9), 0.5);\n\njulia> dim(X)\n9\n\njulia> Xext = add_dimension(X);\n\njulia> dim(Xext)\n10\n\njulia> X = ZeroSet(4);\n\njulia> dim(add_dimension(X))\n5\n\njulia> typeof(X)\nZeroSet{Float64}\n\nMore than one dimension can be added passing the second argument:\n\njulia> Xext = add_dimension(BallInf(zeros(10), 0.1), 4);\n\njulia> dim(Xext)\n14\n\nNotes\n\nIn the special case that the given set is a zero set, instead of cartesian product a new zero set with extended dimensions is returned.\n\n\n\n\n\nadd_dimension(ivp::IVP, m=1)\n\nAdds an extra dimension to a initial-value system.\n\nInput\n\nivp – initial-value system\nm   – (optional, default: 1) the number of extra dimensions\n\nExamples\n\njulia> using MathematicalSystems, SparseArrays\n\njulia> using ReachabilityAnalysis: add_dimension\n\njulia> A = sprandn(3, 3, 0.5);\n\njulia> X0 = BallInf(zeros(3), 1.0);\n\njulia> s = InitialValueProblem(LinearContinuousSystem(A), X0);\n\njulia> sext = add_dimension(s);\n\njulia> statedim(sext)\n4\n\nIf there is an input set, it is also extended:\n\njulia> using LinearAlgebra\n\njulia> using ReachabilityAnalysis.DiscretizationModule: next_set\n\njulia> U = ConstantInput(Ball2(ones(3), 0.1));\n\njulia> s = InitialValueProblem(ConstrainedLinearControlContinuousSystem(A, Matrix(1.0I, size(A)), nothing, U), X0);\n\njulia> sext = add_dimension(s);\n\njulia> statedim(sext)\n4\n\njulia> dim(next_set(inputset(sext)))\n4\n\nExtending a system with a varying input set:\n\nIf there is an input set, it is also extended:\n\njulia> U = VaryingInput([Ball2(ones(3), 0.1 * i) for i in 1:3]);\n\njulia> s = InitialValueProblem(ConstrainedLinearControlContinuousSystem(A, Matrix(1.0I, size(A)), nothing, U), X0);\n\njulia> sext = add_dimension(s);\n\njulia> statedim(sext)\n4\n\njulia> dim(next_set(inputset(sext), 1))\n4\n\nExtending a varying input set with more than one extra dimension:\n\njulia> sext = add_dimension(s, 7);\n\njulia> statedim(sext)\n10\n\njulia> dim(next_set(inputset(sext), 1))\n10\n\n\n\n\n\n","category":"function"},{"location":"lib/systems/#ReachabilityAnalysis.homogenize","page":"Systems","title":"ReachabilityAnalysis.homogenize","text":"homogenize(ivp::IVP{<:CLCCS{N,MTA,MTB,XT,UT},ST}) where {N, MTA<:AbstractMatrix{N},\n    MTB<:IdentityMultiple{N}, XT<:LazySet{N}, UT<:ConstantInput{<:Singleton{N}}, ST<:LazySet{N}}\n\nTransform an inhomogeneous linear initial-value problem into a homogeneous one by introducing auxiliary state variables.\n\nInput\n\nivp – initial-value problem\n\nOutput\n\nHomogeneous initial-value problem.\n\nNotes\n\nThis function transforms the canonical initial-value problem x = Ax + u, x  X with u(0)  U = u (a singleton) into a homogeneous problem without inputs y = Â * y, y  Y.\n\n\n\n\n\nhomogenize(sys::SOACS)\n\nTransform an inhomogeneous second order system into a homogeneous one by introducing auxiliary state variables.\n\nInput\n\nsys – second order system\n\nOutput\n\nFirst-order homogeneous system.\n\nNotes\n\nThis function transforms the second-order system Mx + Cx + Kx = b into a first-order, homogeneous one, y = Â * y. It is assumed that the matrix M is invertible.\n\n\n\n\n\n","category":"function"},{"location":"lib/systems/#ReachabilityAnalysis.HACLD1","page":"Systems","title":"ReachabilityAnalysis.HACLD1","text":"HACLD1{T<:AbstractSystem, MT, N, J} <: AHACLD\n\nSingle-mode hybrid automaton with clocked linear dynamics.\n\nFields\n\nsys       – system\nrmap      – reset map\nTsample   – sampling time\nζ         – jitter\nswitching – (optional) value that\n\nNotes\n\nThis type is parametric in:\n\nT  – system type\nMT – type of the reset map\nN  – numeric type, applies to the sampling time and jitter\nJ  – type associated to the jitter\n\nThe type associated to the jitter, J, can be one of the following:\n\nMissing     – no jitter, i.e. switchings are deterministic\nNumber      – symmetric jitter, i.e. non-deterministic switchings occur in the                  intervals [Tsample - ζ, Tsample + ζ]\nIA.Interval – non-symmetric jitter, i.e. non-deterministic switchings occur in the                  intervals [Tsample + inf(ζ), Tsample + sup(ζ)]; note that                  the infimum is expected to be negative for most use cases, i.e.                  when the jitter interval is centered at zero\n\nThe following getter functions are available:\n\ninitial_state  – initial state of the continuous mode\njitter         – return the jitter\nreset_map      – return the reset map\nsampling_time  – return the sampling time\nstatedim       – dimension of the state-space\nsystem         – return the continuous mode\nswitching      – return the type of switching\n\nNon-deterministic switching:\n\ntstart       Ts-ζ⁻         tend  [––––––-|––––––-]\n\nIn the following, suppose that the continuous post-operator has fixed step-size δ > 0. If F denotes the flowpipe, then\n\nF[1]    F[2]    F[3]    F[4]    F[5]        F[k] [–––][–––][–––][–––][–––]  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  [–––]\n\nR = array(F) denote the array of reach-sets time-span for reach reach-set is of the form:\n\nSimilarly we compute tstart and tend for the supremum part Ts-ζ⁺\n\n\n\n\n\n","category":"type"},{"location":"lib/systems/#ReachabilityAnalysis.DiscreteTransition","page":"Systems","title":"ReachabilityAnalysis.DiscreteTransition","text":"DiscreteTransition{RT, GT, IT⁻, IT⁺, WT} <: AbstractTransition\n\nType that encodes a discrete transition with an affine assignment of the form:\n\n    post_d(X) = (R(X  G  I)  W)  I\n\nwhere I and I  are invariants at the source and the target locations respectively, G  mathbbR^n is the guard set of the transition, the assignment is of the form x^+ = Rx + w, w  W, x^+  mathbbR^m are the values after the transition, R  mathbbR^mtimes n is the assignment map (or reset map) and W  mathbbR^m is a closed and bounded convex set of non-deterministic inputs.\n\nFields\n\nR  – assignment map\nW  – non-deterministic inputs\nG  – guard set of the transition from the source location to the target location\nI⁻ – invariant at the source location\nI⁺ – invariant at the target location\n\n\n\n\n\n","category":"type"},{"location":"lib/systems/#LazySets.constrained_dimensions-Tuple{HybridSystem}","page":"Systems","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(HS::HybridSystem)::Dict{Int,Vector{Int}}\n\nFor each location, compute all dimensions that are constrained in the invariant or the guard of any outgoing transition.\n\nInput\n\nHS  – hybrid system\n\nOutput\n\nA dictionary mapping (::Dict{Int,Vector{Int}}) the index of each location ℓ to the dimension indices that are constrained in ℓ.\n\n\n\n\n\n","category":"method"},{"location":"generated_examples/Quadrotor/#Quadrotor","page":"Quadrotor","title":"Quadrotor","text":"note: Overview\nSystem type: Polynomial continuous system\nState dimension: 12\nApplication domain: Mechanical engineering","category":"section"},{"location":"generated_examples/Quadrotor/#Model-description","page":"Quadrotor","title":"Model description","text":"We study the dynamics of a quadrotor, derived in Beard [Bea08] and used in Geretti et al. [GSA+21]. Starting with the state variables, we have the inertial (north) position x_1, the inertial (east) position x_2, the altitude x_3, the longitudinal velocity x_4, the lateral velocity x_5, the vertical velocity x_6, the roll angle x_7, the pitch angle x_8, the yaw angle x_9, the roll rate x_10, the pitch rate x_11, and the yaw rate x_12. We further require the following parameters: gravity constant g = 981 [m/s^2], radius of center mass R = 01 [m], distance of rotors to center mass l = 05 [m], rotor mass M_rotor = 01 [kg], center mass M = 1 [kg], and total mass m = M + 4M_rotor.\n\nFrom the above parameters, we can compute the moments of inertia as\n\nbeginaligned\n    J_x = 04 M R^2 + 2 l^2 M_rotor \n    J_y = J_x \n    J_z = 04 M R^2 + 4 l^2 M_rotor\nendaligned\n\nFinally, we can write the set of ordinary differential equations for the quadrotor according to Beard [Bea08], Eq. (16)-(19):\n\nbeginaligned\n    dotx_1 = cos(x_8)cos(x_9)x_4 + Big(sin(x_7)sin(x_8)cos(x_9) - cos(x_7)sin(x_9)Big)x_5 \n     + Big(cos(x_7)sin(x_8)cos(x_9) + sin(x_7)sin(x_9)Big)x_6 \n    dotx_2 = cos(x_8)sin(x_9)x_4 + Big(sin(x_7)sin(x_8)sin(x_9) + cos(x_7)cos(x_9)Big)x_5 \n     + Big(cos(x_7)sin(x_8)sin(x_9) - sin(x_7)cos(x_9)Big)x_6 \n    dotx_3 = sin(x_8)x_4 - sin(x_7)cos(x_8)x_5 - cos(x_7)cos(x_8)x_6 \n    dotx_4 = x_12x_5 - x_11x_6 - gsin(x_8) \n    dotx_5 = x_10x_6 - x_12x_4 + gcos(x_8)sin(x_7) \n    dotx_6 = x_11x_4 - x_10x_5 + gcos(x_8)cos(x_7) - dfracFm \n    dotx_7 = x_10 + sin(x_7)tan(x_8)x_11 + cos(x_7)tan(x_8)x_12 \n    dotx_8 = cos(x_7)x_11 - sin(x_7)x_12 \n    dotx_9 = dfracsin(x_7)cos(x_8)x_11 + dfraccos(x_7)cos(x_8)x_12 \n    dotx_10 = dfracJ_y - J_zJ_xx_11x_12 + dfrac1J_xτ_ϕ \n    dotx_11 = dfracJ_z - J_xJ_yx_10x_12 + dfrac1J_yτ_θ \n    dotx_12 = dfracJ_x - J_yJ_zx_10x_11 + dfrac1J_zτ_ψ\nendaligned\n\nTo check interesting control specifications, we stabilize the quadrotor using simple PD controllers for height, roll, and pitch. The inputs to the controller are the desired values for height, roll, and pitch u_1, u_2, and u_3, respectively. The equations of the controllers are:\n\nbeginaligned\n    F = m  g - 10(x_3 - u_1) + 3x_6   (textheight control) \n    τ_ϕ = -(x_7 - u_2) - x_10  (textroll control) \n    τ_θ = -(x_8 - u_3) - x_11  (textpitch control)\nendaligned\n\nWe leave the heading uncontrolled by setting τ_ψ = 0.\n\nusing ReachabilityAnalysis\nusing ReachabilityBase.Arrays: SingleEntryVector\n\n# parameters of the model\nconst g = 9.81            # gravity constant in m/s^2\nconst R = 0.1             # radius of center mass in m\nconst l = 0.5             # distance of rotors to center mass in m\nconst Mrotor = 0.1        # rotor mass in kg\nconst M = 1.0             # center mass in kg\nconst m = M + 4 * Mrotor  # total mass in kg\nconst mg = m * g;\n\n# moments of inertia\nconst Jx = 0.4 * M * R^2 + 2 * l^2 * Mrotor\nconst Jy = Jx\nconst Jz = 0.4 * M * R^2 + 4 * l^2 * Mrotor\nconst Cyzx = (Jy - Jz) / Jx\nconst Czxy = (Jz - Jx) / Jy\nconst Cxyz = 0.0; #(Jx - Jy)/Jz\n\n# control parameters\nconst u₁ = 1.0\nconst u₂ = 0.0\nconst u₃ = 0.0\n\n@taylorize function quadrotor!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, x₅, x₆, x₇, x₈, x₉, x₁₀, x₁₁, x₁₂ = x\n\n    # equations of the controllers\n    F = (mg - 10 * (x₃ - u₁)) + 3 * x₆  # height control\n    τϕ = -(x₇ - u₂) - x₁₀               # roll control\n    τθ = -(x₈ - u₃) - x₁₁               # pitch control\n    local τψ = 0.0                    # heading is uncontrolled\n\n    Tx = τϕ / Jx\n    Ty = τθ / Jy\n    Tz = τψ / Jz\n    F_m = F / m\n\n    # some abbreviations\n    sx7 = sin(x₇)\n    cx7 = cos(x₇)\n    sx8 = sin(x₈)\n    cx8 = cos(x₈)\n    sx9 = sin(x₉)\n    cx9 = cos(x₉)\n\n    sx7sx9 = sx7 * sx9\n    sx7cx9 = sx7 * cx9\n    cx7sx9 = cx7 * sx9\n    cx7cx9 = cx7 * cx9\n    sx7cx8 = sx7 * cx8\n    cx7cx8 = cx7 * cx8\n    sx7_cx8 = sx7 / cx8\n    cx7_cx8 = cx7 / cx8\n\n    x4cx8 = cx8 * x₄\n\n    p11 = sx7_cx8 * x₁₁\n    p12 = cx7_cx8 * x₁₂\n    xdot9 = p11 + p12\n\n    # differential equations for the quadrotor\n    dx[1] = (cx9 * x4cx8 + (sx7cx9 * sx8 - cx7sx9) * x₅) + (cx7cx9 * sx8 + sx7sx9) * x₆\n    dx[2] = (sx9 * x4cx8 + (sx7sx9 * sx8 + cx7cx9) * x₅) + (cx7sx9 * sx8 - sx7cx9) * x₆\n    dx[3] = (sx8 * x₄ - sx7cx8 * x₅) - cx7cx8 * x₆\n    dx[4] = (x₁₂ * x₅ - x₁₁ * x₆) - g * sx8\n    dx[5] = (x₁₀ * x₆ - x₁₂ * x₄) + g * sx7cx8\n    dx[6] = (x₁₁ * x₄ - x₁₀ * x₅) + (g * cx7cx8 - F_m)\n    dx[7] = x₁₀ + sx8 * xdot9\n    dx[8] = cx7 * x₁₁ - sx7 * x₁₂\n    dx[9] = xdot9\n    dx[10] = Cyzx * (x₁₁ * x₁₂) + Tx\n    dx[11] = Czxy * (x₁₀ * x₁₂) + Ty\n    dx[12] = Cxyz * (x₁₀ * x₁₁) + Tz\n    return dx\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/Quadrotor/#Specification","page":"Quadrotor","title":"Specification","text":"The task is to change the height from 0 m to 1 m within 5 s. More precisely, a goal region 098102 of the height x_3 has to be reached within 5 s and the height has to stay below 14 m for all times. After 1 s, the height should stay above 09 m. The initial value for the position and velocities (i.e., from x_1 to x_6) is uncertain and given by -Δ Δ m, with Δ = 04. All other variables are initialized to 0. This preliminary analysis must be followed by a corresponding evolution for Δ = 01 and Δ = 08 while keeping all the settings the same. No goals are specified for these cases: the objective instead is to understand the scalability of the tool.\n\nconst T = 5.0\nconst v3 = SingleEntryVector(3, 12, 1.0)\n\n@inline function quad_property(sol)\n    tf = tend(sol)\n\n    # Condition: b1 = (x[3] < 1.4) for all time\n    unsafe1 = HalfSpace(-v3, -1.4) # unsafe: -x3 <= -1.4\n    b1 = all([isdisjoint(unsafe1, set(R)) for R in sol(0.0 .. tf)])\n    #b1 = ρ(v3, sol) < 1.4\n\n    # Condition: x[3] > 0.9 for t ≥ 1.0\n    unsafe2 = HalfSpace(v3, 0.9) # unsafe: x3 <= 0.9\n    b2 = all([isdisjoint(unsafe2, set(R)) for R in sol(1.0 .. tf)])\n\n    # Condition: x[3] ⊆ Interval(0.98, 1.02) for t = 5.0\n    b3 = set(project(sol[end]; vars=(3))) ⊆ Interval(0.98, 1.02)\n\n    return b1 && b2 && b3\nend\n\nfunction quadrotor(; Wpos, Wvel)\n    # initial condition\n    ΔX0 = [Wpos, Wpos, Wpos, Wvel, Wvel, Wvel, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    X0 = Hyperrectangle(zeros(12), ΔX0)\n\n    # initial-value problem\n    prob = @ivp(x' = quadrotor!(x), dim:12, x(0) ∈ X0)\n\n    return prob\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/Quadrotor/#Analysis","page":"Quadrotor","title":"Analysis","text":"","category":"section"},{"location":"generated_examples/Quadrotor/#Case-1:-smaller-uncertainty","page":"Quadrotor","title":"Case 1: smaller uncertainty","text":"Wpos = 0.1\nWvel = 0.1\nprob = quadrotor(; Wpos=Wpos, Wvel=Wvel)\nalg = TMJets(; abstol=1e-7, orderT=5, orderQ=1, adaptive=false)\n\nsol = solve(prob; T=T, alg=alg)\nsolz1 = overapproximate(sol, Zonotope);\nnothing #hide\n\nVerify that the specification holds:\n\n@assert quad_property(solz1) \"the property should be proven\"","category":"section"},{"location":"generated_examples/Quadrotor/#Case-2:-intermediate-uncertainty","page":"Quadrotor","title":"Case 2: intermediate uncertainty","text":"Wpos = 0.4\nWvel = 0.4\nprob = quadrotor(; Wpos=Wpos, Wvel=Wvel)\nalg = TMJets(; abstol=1e-7, orderT=5, orderQ=1, adaptive=false)\n\nsol = solve(prob; T=T, alg=alg)\nsolz2 = overapproximate(sol, Zonotope);\nnothing #hide\n\nVerify that the specification holds:\n\n@assert quad_property(solz2) \"the property should be proven\"","category":"section"},{"location":"generated_examples/Quadrotor/#Case-3:-large-uncertainty","page":"Quadrotor","title":"Case 3: large uncertainty","text":"Wpos = 0.8\nWvel = 0.8\nprob = quadrotor(; Wpos=Wpos, Wvel=Wvel)\nalg = TMJets(; abstol=1e-7, orderT=5, orderQ=1, adaptive=false)\n\nsol = solve(prob; T=T, alg=alg)\nsolz3 = overapproximate(sol, Zonotope);\nnothing #hide\n\nThe specification does not hold in this case:\n\n@assert !quad_property(solz3) \"the property should not be proven\"","category":"section"},{"location":"generated_examples/Quadrotor/#Results","page":"Quadrotor","title":"Results","text":"using Plots\nimport DisplayAs  #hide\n\nfig = plot(solz3; vars=(0, 3), linecolor=\"green\", color=:green, alpha=0.8)\nplot!(solz2; vars=(0, 3), linecolor=\"blue\", color=:blue, alpha=0.8)\nplot!(solz1; vars=(0, 3), linecolor=\"yellow\", color=:yellow, alpha=0.8,\n      xlab=\"t\", ylab=\"x3\",\n      xtick=[0.0, 1.0, 2.0, 3.0, 4.0, 5.0], ytick=[-1.0, -0.5, 0.0, 0.5, 1.0, 1.5],\n      xlims=(0.0, 5.0), ylims=(-1.0, 1.5))\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"man/algorithms/ASB07/#Interval-matrix-zonotope-method-(ASB07)","page":"ASB07","title":"Interval matrix-zonotope method (ASB07)","text":"","category":"section"},{"location":"man/algorithms/ASB07/#Method","page":"ASB07","title":"Method","text":"","category":"section"},{"location":"man/algorithms/ASB07/#Examples","page":"ASB07","title":"Examples","text":"","category":"section"},{"location":"lib/algorithms/GLGM06/#ReachabilityAnalysis.GLGM06","page":"GLGM06","title":"ReachabilityAnalysis.GLGM06","text":"GLGM06{N, AM, S, D, NG, P, RM} <: AbstractContinuousPost\n\nImplementation of the Girard–Le Guernic–Maler algorithm for reachability of linear systems using zonotopes.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: FirstOrderZonotope()) approximation                       model; see Notes below for possible options\nmax_order        – (optional, default: 5) maximum zonotope order\nstatic           – (optional, default: false) if true, convert the problem data                       to statically sized arrays\ndim              – (optional default: missing) ambient dimension\nngens            – (optional, default: missing) number of generators\npreallocate      – (optional, default: true) if true, use the implementation                       which preallocates the zonotopes prior to applying the update rule\nreduction_method    – (optional, default: GIR05()) zonotope order reduction method used\ndisjointness_method – (optional, default: NoEnclosure()) method to check                          disjointness between the reach-set and the invariant\n\nNotes\n\nThe type parameters are:\n\nN  – number type of the step-size\nAM – approximation model\nS  – value type of the static option\nD  – value type of the dimension of the system dim\nNG – value type of the number of generators ngens\nP  – value type of the preallocate option\nRM – type of the reduction method\n\nThe only parameter that does not have a default value is the step size δ, associated with the type parameter N. Parameters dim and ngens are optionally specified (default to missing). These parameters are needed for the cases that require the size of the zonotopes to be known (fixed) at compile time, namely the static=true version of this algorithm.\n\nThe default approximation model is FirstOrderZonotope.\n\nReferences\n\nThe main ideas behind this algorithm can be found in Girard [Gir05] and Girard et al. [GLM06]. These methods are discussed at length in the dissertation [LG09].\n\nRegarding the zonotope order reduction methods, we refer to Combastel [Com03] and Girard [Gir05] and the review article [YS18].\n\n\n\n\n\n","category":"type"},{"location":"generated_examples/DuffingOscillator/#Duffing-oscillator","page":"Duffing oscillator","title":"Duffing oscillator","text":"note: Overview\nSystem type: Polynomial continuous system\nState dimension: 2\nApplication domain: Nonlinear physics","category":"section"},{"location":"generated_examples/DuffingOscillator/#Model-description","page":"Duffing oscillator","title":"Model description","text":"using ReachabilityAnalysis\n\nconst ω = 1.2\n\n@taylorize function duffing!(du, u, p, t)\n    local α = -1.0\n    local β = 1.0\n    local δ = 0.3\n    local γ = 0.37\n\n    x, v = u\n\n    f = γ * cos(ω * t)\n\n    du[1] = u[2]\n    du[2] = -α * x - δ * v - β * x^3 + f\n    return du\nend","category":"section"},{"location":"generated_examples/DuffingOscillator/#Specification","page":"Duffing oscillator","title":"Specification","text":"X0 = Hyperrectangle([1.0, 0.0], [0.1, 0.1])\nprob = @ivp(x' = duffing!(x), x(0) ∈ X0, dim:2)\n\nT = 2 * pi / ω;\nnothing #hide","category":"section"},{"location":"generated_examples/DuffingOscillator/#Analysis","page":"Duffing oscillator","title":"Analysis","text":"sol = solve(prob; tspan=(0.0, 20 * T), alg=TMJets21a());\nnothing #hide","category":"section"},{"location":"generated_examples/DuffingOscillator/#Results","page":"Duffing oscillator","title":"Results","text":"using Plots\nimport DisplayAs  #hide\n\nfig = plot(sol; vars=(0, 1), xlab=\"t\", ylab=\"x\", lw=0.2, color=:blue)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nfig = plot(sol; vars=(0, 2), xlab=\"t\", ylab=\"v\", lw=0.2, color=:blue)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nfig = plot(sol; vars=(1, 2), xlab=\"x\", ylab=\"v\", lw=0.5, color=:red)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"lib/algorithms/BOX/#ReachabilityAnalysis.BOX","page":"BOX","title":"ReachabilityAnalysis.BOX","text":"BOX{N, AM, S, D, R} <: AbstractContinuousPost\n\nImplementation of a reachability method for linear systems using box approximations.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\nstatic\ndim          – (optional default: missing) ambient dimension\nrecursive    – (optional default: false) if true, use the implementation that                   recursively computes each reach-set; otherwise, use the implementation                   that unwraps the sequence until the initial set\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\nS  – value type for the static option\nD  – value type for the dimension\nR  – value type for the recursive option\n\nThe default approximation model is:\n\nForward(sih=:concrete, exp=:base, setops=:lazy)\n\nThis algorithm solves the set-based recurrence equation X_k+1 = ΦX_k  V_k by computing a tight hyperrectangular over-approximation of X_k+1 at each step k  mathbbN. The recursive implementation uses the previously computed set X_k to compute X_k+1. However, it is known that this method incurs wrapping effects. The non-recursive implementation instead computes X_k+1 by unwrapping the discrete recurrence until X_0 = Ω₀, at the expense of computing powers of the matrix Φ. These ideas are discussed in Bogomolov et al. [BFF+18].\n\nReferences\n\nThis algorithm is essentially a non-decomposed version of the method in Bogomolov et al. [BFF+18], using hyperrectangles as set representation. For a general introduction we refer to the dissertation [LG09].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in Frehse et al. [FLD+11].\n\n\n\n\n\n","category":"type"},{"location":"generated_examples/Lorenz/#Lorenz-equations","page":"Lorenz system","title":"Lorenz equations","text":"note: Overview\nSystem type: Polynomial continuous system\nState dimension: 3\nApplication domain: Atmospheric convection","category":"section"},{"location":"generated_examples/Lorenz/#Model-description","page":"Lorenz system","title":"Model description","text":"This model is a system of three ordinary differential equations known as the Lorenz equations:\n\nbeginaligned\n    dotx = σ (y - x) \n    doty = x (ρ - z) - y \n    dotz = x y - β z\nendaligned\n\nThe equations relate the properties of a two-dimensional fluid layer uniformly warmed from below and cooled from above. In particular, the equations describe the rate of change of three quantities with respect to time: x is proportional to the rate of convection, y to the horizontal temperature variation, and z to the vertical temperature variation. The parameters σ, ρ, and β are proportional to the Prandtl number, Rayleigh number, and certain physical dimensions of the layer itself.\n\nusing ReachabilityAnalysis\n\n@taylorize function lorenz!(du, u, p, t)\n    local σ = 10.0\n    local β = 8.0 / 3.0\n    local ρ = 28.0\n\n    x, y, z = u\n    du[1] = σ * (y - x)\n    du[2] = x * (ρ - z) - y\n    du[3] = x * y - β * z\n    return du\nend","category":"section"},{"location":"generated_examples/Lorenz/#Specification","page":"Lorenz system","title":"Specification","text":"The initial condition is X_0  09 11  0 0  0 0, for a time span of 10.\n\nX0 = Hyperrectangle(; low=[0.9, 0.0, 0.0], high=[1.1, 0.0, 0.0])\nprob = @ivp(x' = lorenz!(x), dim:3, x(0) ∈ X0);\nnothing #hide","category":"section"},{"location":"generated_examples/Lorenz/#Analysis","page":"Lorenz system","title":"Analysis","text":"We compute the flowpipe using the TMJets algorithm with n_T=10 and n_Q=2.\n\nalg = TMJets(; abstol=1e-15, orderT=10, orderQ=2, maxsteps=50_000)\nsol = solve(prob; T=10.0, alg=alg)\nsolz = overapproximate(sol, Zonotope);\nnothing #hide","category":"section"},{"location":"generated_examples/Lorenz/#Results","page":"Lorenz system","title":"Results","text":"using Plots\nimport DisplayAs  #hide\n\nfig = plot(solz; vars=(0, 1), xlab=\"t\", ylab=\"x\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nIt is apparent by inspection that variable x(t) does not exceed 20 in the computed time span:\n\nfig = plot(solz(0.0 .. 1.5); vars=(0, 1), xlab=\"t\", ylab=\"x\", lw=0)\nplot!(fig, x -> 20.0; c=:red, xlims=(0.0, 1.5), lab=\"\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nWe can prove that this is the case by evaluating the support function of the flowpipe along direction 1 0 0:\n\n@assert ρ([1.0, 0, 0], solz(0 .. 1.5)) < 20 \"the property should be proven\"\n\nρ([1.0, 0, 0], solz(0 .. 1.5))\n\nIn a similar fashion, we can compute extremal values of variable y(t):\n\nfig = plot(solz; vars=(0, 2), xlab=\"t\", ylab=\"y\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nSince we have computed overapproximations of the exact flowipe, the following quantities are a lower bound on the exact minimum (resp. an upper bound on the exact maximum):\n\n-ρ([0.0, -1.0, 0.0], solz), ρ([0.0, 1.0, 0.0], solz)\n\nfig = plot(solz; vars=(0, 3), xlab=\"t\", ylab=\"z\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nBelow we plot the flowpipe projected on the x/z-plane.\n\nfig = plot(solz; vars=(1, 3), xlab=\"x\", ylab=\"z\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"man/parametric/#Parametric-reachability","page":"Parametric reachability","title":"Parametric reachability","text":"The reachability analysis of parametric systems is performed by the solve function. The following algorithms are available:\n\nPages = [\"HLBS25.md\"]\nDepth = 3","category":"section"},{"location":"generated_examples/LaubLoomis/#Laub-Loomis","page":"Laub-Loomis","title":"Laub-Loomis","text":"note: Overview\nSystem type: Polynomial continuous system\nState dimension: 7\nApplication domain: Molecular biology","category":"section"},{"location":"generated_examples/LaubLoomis/#Model-description","page":"Laub-Loomis","title":"Model description","text":"The Laub-Loomis model is presented in Laub and Loomis [LL98] for studying a class of enzymatic activities. The dynamics can be defined by the following seven-dimensional system of differential equations.\n\nusing ReachabilityAnalysis\n\n@taylorize function laubloomis!(dx, x, p, t)\n    dx[1] = 1.4 * x[3] - 0.9 * x[1]\n    dx[2] = 2.5 * x[5] - 1.5 * x[2]\n    dx[3] = 0.6 * x[7] - 0.8 * (x[2] * x[3])\n    dx[4] = 2 - 1.3 * (x[3] * x[4])\n    dx[5] = 0.7 * x[1] - (x[4] * x[5])\n    dx[6] = 0.3 * x[1] - 3.1 * x[6]\n    dx[7] = 1.8 * x[6] - 1.6 * (x[2] * x[7])\n    return dx\nend\n\nThe system is asymptotically stable and the equilibrium is the origin.","category":"section"},{"location":"generated_examples/LaubLoomis/#Specification","page":"Laub-Loomis","title":"Specification","text":"The initial conditions are defined according to the ones used in Testylier and Dang [TD13]. They are boxes centered at x_1(0) = 12, x_2(0) = 105, x_3(0) = 15, x_4(0) = 24, x_5(0) = 1, x_6(0) = 01, x_7 (0) = 045. The range of the box in the i-th dimension is defined by the interval x_i(0)  W x_i(0) + W. We consider W = 001, W = 005, and W = 01. The specification for each scenario is given as follows:\n\nW = 001 and W = 005: The unsafe region is defined by x_4  45.\nW = 01: The unsafe set is defined by x_4  5.\n\nThe time horizon for all cases is 0 20.\n\nfunction laubloomis(; W=0.01)\n    X0 = Hyperrectangle([1.2, 1.05, 1.5, 2.4, 1.0, 0.1, 0.45], fill(W, 7))\n    prob = @ivp(x' = laubloomis!(x), dim:7, x(0) ∈ X0)\n    return prob\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/LaubLoomis/#Analysis","page":"Laub-Loomis","title":"Analysis","text":"The final widths of x_4 along with the computation times are computed for all three cases, as well as a figure in the (t x_4) axes, with t  0 20, x_4  15 5, where the three plots are overlaid.\n\nCanonical direction along x₄:\n\nconst e4 = [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0];\nnothing #hide","category":"section"},{"location":"generated_examples/LaubLoomis/#Case-1:-Small-initial-set","page":"Laub-Loomis","title":"Case 1: Small initial set","text":"In this case, we consider the width of the initial set W = 001.\n\nprob = laubloomis(; W=0.01)\nalg = TMJets(; abstol=1e-11, orderT=7, orderQ=1, adaptive=true)\n\nsol_1 = solve(prob; T=20.0, alg=alg)\nsol_1z = overapproximate(sol_1, Zonotope);\nnothing #hide\n\nWe verify that the specification holds:\n\n@assert ρ(e4, sol_1z) < 4.5 \"the property should be proven\"\nρ(e4, sol_1z)\n\nTo compute the width of the final box, we use the support function:\n\nρ(e4, sol_1z[end]) + ρ(-e4, sol_1z[end])","category":"section"},{"location":"generated_examples/LaubLoomis/#Case-2:-Intermediate-initial-set","page":"Laub-Loomis","title":"Case 2: Intermediate initial set","text":"In this case, we consider the width of the initial set W = 005.\n\nprob = laubloomis(; W=0.05)\nalg = TMJets(; abstol=1e-12, orderT=7, orderQ=1, adaptive=false)\n\nsol_2 = solve(prob; T=20.0, alg=alg)\nsol_2z = overapproximate(sol_2, Zonotope);\nnothing #hide\n\nWe verify that the specification holds:\n\n@assert ρ(e4, sol_2z) < 4.5 \"the property should be proven\"\nρ(e4, sol_2z)\n\nWidth of final box:\n\nρ(e4, sol_2z[end]) + ρ(-e4, sol_2z[end])","category":"section"},{"location":"generated_examples/LaubLoomis/#Case-3:-Large-initial-set","page":"Laub-Loomis","title":"Case 3: Large initial set","text":"In this case, we consider the width of the initial set W = 01.\n\nprob = laubloomis(; W=0.1)\nalg = TMJets(; abstol=1e-12, orderT=7, orderQ=1, adaptive=false)\n\nsol_3 = solve(prob; T=20.0, alg=alg)\nsol_3z = overapproximate(sol_3, Zonotope);\nnothing #hide\n\nWe verify that the specification holds:\n\n@assert ρ(e4, sol_3z) < 5.0 \"the property should be proven\"\nρ(e4, sol_3z)\n\nWidth of final box:\n\nρ(e4, sol_3z[end]) + ρ(-e4, sol_3z[end])","category":"section"},{"location":"generated_examples/LaubLoomis/#Results","page":"Laub-Loomis","title":"Results","text":"using Plots, Plots.PlotMeasures, LaTeXStrings\nimport DisplayAs  #hide\n\nfig = plot(sol_3z; vars=(0, 4), linecolor=\"green\", color=:green, alpha=0.8, lab=\"W = 0.1\")\nplot!(fig, sol_2z; vars=(0, 4), linecolor=\"blue\", color=:blue, alpha=0.8, lab=\"W = 0.05\")\nplot!(fig, sol_1z; vars=(0, 4), linecolor=\"yellow\", color=:yellow, alpha=0.8, lab=\"W = 0.01\",\n      tickfont=font(10, \"Times\"), guidefontsize=15, xlab=L\"t\", ylab=L\"x_4\",\n      xtick=[0.0, 5.0, 10.0, 15.0, 20.0], ytick=[1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0],\n      xlims=(0.0, 20.0), ylims=(1.5, 5.02),\n      bottom_margin=6mm, left_margin=2mm, right_margin=4mm, top_margin=3mm,\n      size=(600, 600))\nplot!(fig, x -> x, x -> 4.5, 0.0, 20.0; line=2, color=\"red\", linestyle=:dash, lab=\"\")\nplot!(fig, x -> x, x -> 5.0, 0.0, 20.0; line=2, color=\"red\", linestyle=:dash, lab=\"\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"man/hybrid/#hybrid_systems","page":"Introduction","title":"Hybrid systems","text":"","category":"section"},{"location":"man/hybrid/#Introduction","page":"Introduction","title":"Introduction","text":"Our running example is the bouncing ball model; although it is a very hybrid automaton, it can be used to introduce the main notions involved in hybrid systems reachability.\n\n(Image: Hybrid automaton of the bouncing ball model)\n\nusing ReachabilityAnalysis, Plots, Symbolics\n\nfunction bouncing_ball()\n\n    # symbolic variables\n    var = @variables x v\n\n    # falling mode with invariant x >= 0\n    A = [0 1.; 0 0]\n    b = [0, -9.8]\n    flow = @system(z' = A*z + b, z ∈ HalfSpace(x ≥ 0, var))\n\n    # guard x ≤ 0 && v ≤ 0\n    FLOOR = HPolyhedron([x ≤ 0, v ≤ 0], var)\n\n    # reset map v⁺ := -cv\n    assignment = ConstrainedLinearMap([1 0; 0 -0.75], FLOOR)\n\n    # hybrid system\n    H = HybridSystem(flow, assignment)\n\n    return H\nend\n\nH = bouncing_ball()\n\nZ0 = Hyperrectangle(low=[10.0, 0], high=[10.2, 0])\nprob = @ivp(H, z(0) ∈ Z0);\n\nboxdirs = BoxDirections{Float64, Vector{Float64}}(2)\nThull = TemplateHullIntersection(boxdirs)\n\nsol = solve(prob, T=5.0,\n            alg=LGG09(δ=0.02, template=boxdirs),\n            clustering_method=LazyClustering(1, convex=false),\n            intersection_source_invariant_method=Thull,\n            intersection_method=Thull);\n\nfig = plot(sol, vars=(0, 1), xlab=\"t\", ylab=\"x(t)\", lc=:blue)\n\nimport DisplayAs  # hide\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\ntspan(sol)\n\nfig = plot(sol, vars=(1, 2), xlab=\"x(t)\", ylab=\"y(t)\", lc=:blue)\n\nimport DisplayAs  # hide\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide","category":"section"},{"location":"man/hybrid/#Formalism","page":"Introduction","title":"Formalism","text":"TODO: definition of HA","category":"section"},{"location":"man/hybrid/#Hybrid-solver-algorithm","page":"Introduction","title":"Hybrid solver algorithm","text":"TODO: high-level description of the hybrid solve","category":"section"},{"location":"man/hybrid/#Flowpipe-guard-intersections","page":"Introduction","title":"Flowpipe-guard intersections","text":"In this section we illustrate the available methods to compute flowpipe-guard intersections. We will see how to use the function cluster to select a clustering strategies to cope with the case when there are several intersecting sets. We will also show examples of choosing different intersection templates.","category":"section"},{"location":"man/hybrid/#Customizing-the-solver","page":"Introduction","title":"Customizing the solver","text":"TODO: further examples on how to customize the discrete post-operator","category":"section"},{"location":"lib/algorithms/BFFPSV18/#BFFPSV18","page":"BFFPSV18","title":"BFFPSV18","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#ReachabilityAnalysis.BFFPSV18","page":"BFFPSV18","title":"ReachabilityAnalysis.BFFPSV18","text":"BFFPSV18{N, ST, AM, IDX, BLK, RBLK, CBLK} <: AbstractContinuousPost\n\nImplementation of the reachability method for linear systems using block decompositions.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: Forward) approximation model;                       see Notes below for possible options\nvars             – vector with the variables of interest\nblock_indices    – vector of integers to index each block that contains a variable of interest\nrow_blocks       – vector of integer vectors to index variables associated to blocks of interest\ncolumn_blocks    – vector of integer vectors to index variables in the partition\nlazy_initial_set – (optional, default: false) if true, use a lazy decomposition of the initial states                       after discretization\nlazy_input    – (optional, default: false) if true, use a lazy decomposition of the input set                     after discretization\nsparse        – (optional, default: false) if true, assume that the state transition                     matrix is sparse\nview          – (optional, default: false) if true, use implementation that                    uses arrays views\n\nmatrix is sparse\n\nSee the Examples section below for some concrete examples of these options.\n\nNotes\n\nThis algorithm solves the set-based recurrence equation X_k+1 = ΦX_k  V_k by using block decompositions. The algorithm was introduced in Bogomolov et al. [BFF+18].\n\nComments about some fields:\n\nN    – number type of the step-size, e.g. Float64\nST   – set representation used; this is either a concrete LazySet subtype,           eg. Interval{Float64}, or a tuple of concrete LazySet subtypes           that is commensurate with the partition\n\nThe default approximation model is:\n\nForward(sih=:concrete, exp=:base, setops=:lazy)\n\nTODO:\n\nclarify assumption about contiguous blocks\n\nExamples\n\nReferences\n\nThis algorithm is essentially an extension of the method in Bogomolov et al. [BFF+18]. Blocks can have different dimensions and the set representation can be different for each block.\n\nFor a general introduction we refer to the dissertation [Sch18].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in Frehse et al. [FLD+11].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets","page":"TMJets","title":"ReachabilityAnalysis.TMJets","text":"TMJets\n\nThe algorithm TMJets defaults to TMJets21b.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets21a","page":"TMJets","title":"ReachabilityAnalysis.TMJets21a","text":"TMJets21a{N, DM<:AbstractDisjointnessMethod} <: AbstractContinuousPost\n\nValidated integration using Taylor models with the validated_integ algorithm.\n\nFields\n\norderQ       – (optional, default: 2) order of the Taylor models for jet transport variables\norderT       – (optional, default: 8) order of the Taylor model in time\nabstol       – (optional, default: 1e-10) absolute tolerance\nmaxsteps     – (optional, default: 2000) maximum number of steps in the                    validated integration x = f(x)\nadaptive     – (optional, default: true) if true, try decreasing the absolute                    tolerance each time step validation fails, until min_abs_tol is reached\nminabstol    – (optional, default: 1e-29) minimum absolute tolerance for the adaptive algorithm\ndisjointness – (optional, default: ZonotopeEnclosure()) defines the method to                    perform the disjointness check between the taylor model flowpipe and the invariant\n\nNotes\n\nThe argument disjointness allows to control how are disjointness checks computed, in the case where the invariant is not universal. In particular, ZonotopeEnclosure() pre-processes the taylor model with a zonotopic overapproximation, then performs the disjointness check with that zonotope and the invariant. For other options, see the documentation of AbstractDisjointnessMethod.\n\nThis algorithm is an adaptation of the implementation in TaylorModels.jl (see copyright license in the file reach.jl of the current folder). The package TaylorIntegration.jl is used for jet-transport of ODEs using the Taylor method, and TaylorSeries.jl is used to work with truncated Taylor series.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets21b","page":"TMJets","title":"ReachabilityAnalysis.TMJets21b","text":"TMJets21b{N, DM<:AbstractDisjointnessMethod} <: AbstractContinuousPost\n\nValidated integration using Taylor models with the validated_integ2 algorithm.\n\nFields\n\norderQ       – (optional, default: 2) order of the Taylor models for jet transport variables\norderT       – (optional, default: 8) order of the Taylor model in time\nabstol       – (optional, default: 1e-10) absolute tolerance\nmaxsteps     – (optional, default: 2000) maximum number of steps in the                    validated integration x = f(x)\nadaptive     – (optional, default: true) if true, try decreasing the absolute                    tolerance each time step validation fails, until min_abs_tol is reached\nminabstol    – (optional, default: 1e-29) minimum absolute tolerance for the adaptive algorithm\ndisjointness – (optional, default: ZonotopeEnclosure()) defines the method to                    perform the disjointness check between the taylor model flowpipe and the invariant\n\nNotes\n\nThe argument disjointness allows to control how are disjointness checks computed, in the case where the invariant is not universal. In particular, ZonotopeEnclosure() pre-processes the taylor model with a zonotopic overapproximation, then performs the disjointness check with that zonotope and the invariant. For other options, see the documentation of AbstractDisjointnessMethod.\n\nThis algorithm is an adaptation of the implementation in TaylorModels.jl (see copyright license in the file reach.jl of the current folder). The package TaylorIntegration.jl is used for jet-transport of ODEs using the Taylor method, and TaylorSeries.jl is used to work with truncated Taylor series.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Internal-functions-and-macros","page":"Internal functions and macros","title":"Internal functions and macros","text":"This section of the manual includes some internal (i.e. unexported) functions and macros used within the library.\n\nPages = [\"internals.md\"]\nDepth = 3","category":"section"},{"location":"lib/internals/#Algorithm-defaults","page":"Internal functions and macros","title":"Algorithm defaults","text":"","category":"section"},{"location":"lib/internals/#ReachabilityAnalysis._default_cpost","page":"Internal functions and macros","title":"ReachabilityAnalysis._default_cpost","text":"_default_cpost(ivp::IVP{<:AbstractContinuousSystem}, tspan; kwargs...)\n\nInput\n\nivp   – initial-value problem\ntspan – time-span\n\nOutput\n\nA continuous post-operator that can handle the given initial-value problem.\n\nNotes\n\nIf the system is affine, then:\n\nIf it is one-dimensional, algorithm INT is used, otherwise,\nAlgorithm GLGM06 is used.\n\nIf the system is not affine, then the algorithm TMJets is used.\n\n\n\n\n\n","category":"function"},{"location":"generated_examples/OpAmp/#Operational-Amplifier","page":"Operational amplifier","title":"Operational Amplifier","text":"note: Overview\nSystem type: Linear continuous system\nState dimension: 2\nApplication domain: Electrical engineering\n\nOperational amplifiers (\"op-amp\") are electronic devices to amplify an input voltage signal. They are widely used to construct filters that remove a desired range of frequencies from the input signal.\n\nThe schematic diagram of an op-amp has two terminals:\n\ninput terminal (left)\noutput terminal (right)\n\nThe output voltage is e_out = K(e_B - e_A), where K is the voltage gain of the op-amp, which is usually very large (at the order of 10^5 V  V).\n\nIn the ideal op-amp scenario, the following assumptions hold:\n\nThe input terminals of the op-amp draw negligible current.\nThe voltage difference at the input terminals e_B - e_A is zero.\nThe gain K is infinite.","category":"section"},{"location":"generated_examples/OpAmp/#Inverting-amplifier","page":"Operational amplifier","title":"Inverting amplifier","text":"Consider the following circuit, which consists of an ideal op-amp in the so-called inverting configuration.\n\n(Image: )\n\nIt is not hard to show [Klu20] that the output satisfies the following differential equation:\n\n   dfracd e_out(t)dt = -dfrac1R_2 Ce_out(t) - dfrac1R_1Ce_in(t)\n\nThe circuit exhibits a transient behavior because of the capacitor connected in parallel to the op-amp. In the stationary limit t  , dfracd e_out(t)dt = 0 and e_out = - dfracR_2R_1 e_in. The gain is thus -dfracR_2R_1 and the minus sign is the reason that this circuit is called \"inverting amplifier.\"\n\nThe output voltage e_out(t) depends on the input voltage e_in(t). In order to highlight some typical assumptions on the inputs, in the rest of this notebook we model the input voltage in different ways:\n\nNondeterministic input with bounded range. This is the most general case, in which e_in(t)  E_in, with E_in  mathbbR is an interval for the set of admissible inputs. This approach guarantees that the flowpipe covers all possible trajectories for any bounded and measurable function e_in(t) satisfying the constraint e_in(t)  E_in for all t of the given time span.\nConstant input, a special case such that e_in(t)  E_in and e_in(t) is constant along trajectories.\nTime-varying input such that the input is determined by a (possibly time-varying) predefined function e_in(t) that is given by the solution of some differential equation. In particular, we consider linear and exponential input functions.\n\nIn the following sections, we will consider these three different scenarios.","category":"section"},{"location":"generated_examples/OpAmp/#Nondeterministic-input","page":"Operational amplifier","title":"Nondeterministic input","text":"In this section, we assume that the input voltage e_in(t) can be any (measurable) function whose range is contained in the set E_in.","category":"section"},{"location":"generated_examples/OpAmp/#Model","page":"Operational amplifier","title":"Model","text":"It is convenient to define constants α and β such that dfracd e_out(t)dt = α e_out(t) + β e_in(t).\n\nusing ReachabilityAnalysis\n\nfunction opamp_nondet(; X0=Singleton([0.0]),\n                      R₁=2.0, R₂=6.0, C=1.e-3,\n                      Ein=Interval(1.9, 2.1))\n    α = hcat(-1 / (R₂ * C))\n    β = hcat(-1 / (R₁ * C))\n\n    # continuous evolution\n    sys = @system(eout' = α * eout + β * ein, ein ∈ Ein, eout ∈ Universe(1))\n\n    # initial-value problem\n    return @ivp(sys, x(0) ∈ X0)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/OpAmp/#Analysis","page":"Operational amplifier","title":"Analysis","text":"sol_nondet = solve(opamp_nondet(); T=0.1, alg=INT(; δ=1e-4));\nnothing #hide\n\ntip: Performance tip\nWe have chosen the algorithm INT, as it is the best choice in terms     of efficiency for one-dimensional ODEs.","category":"section"},{"location":"generated_examples/OpAmp/#Results","page":"Operational amplifier","title":"Results","text":"using Plots, LaTeXStrings\nimport DisplayAs  #hide\n\nfig = plot(sol_nondet; vars=(0, 1), xlab=L\"t\", ylab=L\"e_{out}\",\n           title=\"Solution for nondeterministic input\", lw=0.2)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nThe solution sol_nondet assumed that the initial state is at the origin. Now we solve for three different initial conditions of increasing width, for a shorter time horizon.\n\nΔt = 0 .. 0.04\n\nfig = plot(; xlab=L\"t\", ylab=L\"e_{out}(t)\", title=\"Solution for nondeterministic input\")\n\nsol_nondet = solve(opamp_nondet(; X0=Interval(-1.0, 1.0)); T=0.1, alg=INT(; δ=1e-4))\nplot!(fig, sol_nondet(Δt); vars=(0, 1), lab=\"X0 = -1 .. 1\", lw=0.2)\n\nsol_nondet = solve(opamp_nondet(; X0=Interval(-0.5, 0.5)); T=0.1, alg=INT(; δ=1e-4))\nplot!(fig, sol_nondet(Δt); vars=(0, 1), lab=\"X0 = -0.5 .. 0.5\", lw=0.2)\n\nsol_nondet = solve(opamp_nondet(); T=0.1, alg=INT(; δ=1e-4))\nplot!(fig, sol_nondet(Δt); vars=(0, 1), lab=\"X0 = 0\", lw=0.2)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\ntip: Visualization tip\nThe order in which we have plotted the solutions is such that the flowpipe with largest width comes first, so it does not overlap with flowpipes which are strictly included in it.","category":"section"},{"location":"generated_examples/OpAmp/#Constant-input","page":"Operational amplifier","title":"Constant input","text":"In this section, we model the input voltage e_in(t) with a family of differential equations of the form dfracd e_in(t)dt = γ e_in(t) + δ.","category":"section"},{"location":"generated_examples/OpAmp/#Model-2","page":"Operational amplifier","title":"Model","text":"There are two distinct behaviors depending on the parameters γ and δ:\n\nγ = δ = 0: the input is constant, e_in(t) = e_in 0.\nγ = 0, δ  0: the input is given by linear with rate δ, e_in(t) = δ t + e_in 0.\nγ  0, δ  0: the input is exponential with rate γ, e_in(t) = (e_in 0 + δ  γ)e^γ t - δ  γ.\n\nMoreover, it is natural to assume that the input saturates at a given threshold value. The following function, opamp_with_saturation, models the system as a hybrid automaton with two modes: in the first mode, the input signal e_in(t) varies according to the specified dynamics, and in the second mode, the input signal saturates and ceases to increase (or decrease, depding on the signs chosen). Observe that there are now two state dimensions. The first coordinate corresponds to the output e_out(t), while the second coordinate, e_in(t), corresponds to the input signal e_in(t).\n\nIn this section, we consider the constant input scenario: e_in(0)  E_in 0, e_in(t) constant and γ = δ = 0. We will consider the other cases in the next section.\n\nusing Symbolics\n\nfunction opamp_with_saturation(; X0=Singleton(zeros(2)),\n                               R₁=2.0, R₂=6.0, C=1.e-3,\n                               γ=100.0, δ=100.0, Es=2.0)\n    var = @variables eₒ ein\n    α = hcat(-1 / (R₂ * C))\n    β = hcat(-1 / (R₁ * C))\n\n    # transition graph\n    automaton = GraphAutomaton(2)\n    add_transition!(automaton, 1, 2, 1)\n\n    # modes\n    A = [α β; 0 γ]\n    b = [0; δ]\n    mode1 = @system(x' = A * x + b, x ∈ HalfSpace(ein <= Es, var))\n    A = [α β; 0 0]\n    mode2 = @system(x' = A * x, x ∈ Universe(2))\n    modes = [mode1, mode2]\n\n    # transition mode1 -> mode2 (saturation)\n    t1 = @map(x -> x, dim:2, x ∈ Hyperplane(ein == Es, var))\n    resetmaps = [t1]\n\n    # initial condition: at the origin in mode 1\n    initial_condition = [(1, X0)]\n\n    H = HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])\n    return IVP(H, initial_condition)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/OpAmp/#Specification","page":"Operational amplifier","title":"Specification","text":"We choose the initial condition such that e_out(0) is at the origin and e_in(0)  14 16.\n\nX0 = Hyperrectangle([0.0, 1.5], [0.0, 0.1]);\nnothing #hide\n\nThe value of the saturation constant Es is chosen to be sufficiently high such that the system does not transition to mode 2.\n\nprob_const = opamp_with_saturation(; X0=X0, γ=0.0, δ=0.0, Es=3.0);\nnothing #hide","category":"section"},{"location":"generated_examples/OpAmp/#Analysis-2","page":"Operational amplifier","title":"Analysis","text":"sol_const = solve(prob_const; T=0.1, alg=BOX(; δ=1e-4));\nnothing #hide","category":"section"},{"location":"generated_examples/OpAmp/#Results-2","page":"Operational amplifier","title":"Results","text":"fig = plot(sol_const; vars=(0, 2), xlab=L\"t\", ylab=L\"e_{in}(t)\",\n           title=\"Constant input signal\", lw=0.2)\nplot!(fig, x -> x, x -> 1.5, 0.0, 0.1; color=\"red\", lw=2, ls=:dash, lab=\"\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nfig = plot(sol_const; vars=(0, 1), xlab=L\"t\", ylab=L\"e_{out}(t)\",\n           title=\"Solution for constant input\", lw=0.2)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/OpAmp/#Time-varying-input","page":"Operational amplifier","title":"Time-varying input","text":"For the time-varying scenario with a prescribed function, we consider two cases:\n\nLinearly increasing input voltage: γ = 0, δ  0.\nExponentially increasing input voltage (up to saturation at Es = 1.0): γ  0, δ  0.","category":"section"},{"location":"generated_examples/OpAmp/#Specification-2","page":"Operational amplifier","title":"Specification","text":"For both cases we consider the initial condition being the origin:\n\nX0 = Singleton(zeros(2));\nnothing #hide\n\nWe choose some values for δ and γ:\n\nprob_lin = opamp_with_saturation(; X0=X0, γ=0.0, δ=100.0, Es=1.0)\nprob_exp = opamp_with_saturation(; X0=X0, γ=-100.0, δ=100.0, Es=3.0);\nnothing #hide","category":"section"},{"location":"generated_examples/OpAmp/#Analysis-3","page":"Operational amplifier","title":"Analysis","text":"sol_lin = solve(prob_lin; T=0.1, alg=BOX(; δ=1e-4))\n\nsol_exp = solve(prob_exp; T=0.1, alg=BOX(; δ=1e-4));\nnothing #hide","category":"section"},{"location":"generated_examples/OpAmp/#Results-3","page":"Operational amplifier","title":"Results","text":"fig = plot(sol_lin; vars=(0, 2), xlab=L\"t\", ylab=L\"e_{in}(t)\",\n           title=\"Linear input with saturation\", lw=0.2)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nfig = plot(sol_exp; vars=(0, 2), xlab=L\"t\", ylab=L\"e_{in}(t)\",\n           title=\"Exponential input\", lw=0.2)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nfig = plot(sol_lin; vars=(0, 1), xlab=L\"t\", ylab=L\"e_{out}(t)\",\n           title=\"Solution for linear input\", lw=0.2)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nfig = plot(sol_exp; vars=(0, 1), xlab=L\"t\", ylab=L\"e_{out}(t)\",\n           title=\"Solution for exponential input\", lw=0.2)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"man/benchmarks/benchmarks/#Benchmark-repository","page":"Benchmark repository","title":"Benchmark repository","text":"The benchmark suite of JuliaReach is available at the ReachabilityBenchmarks repository.\n\nThe repository includes:\n\nBenchmarks for all models in the ReachabilityAnalysis.jl test suite.\nBenchmarks for models which are not part of the ReachabilityAnalysis.jl test suite, and are used to detect regressions (i.e. examples that accidentally run slower, due to changes in core downstream libraries such as LazySets.jl).\nThe SLICOT models, from the SLICOT Model and Controller Reduction Toolbox, which reflect real world applications with dimensions ranging from several dozens to over 10.000.","category":"section"},{"location":"man/benchmarks/model_library/#Model-library","page":"Model library","title":"Model library","text":"The library ReachabilityModels.jl contains a collection of pre-made models that can be found in books, articles or other publicly available software related to reachability analysis. As it is explained in the documentation of that library, once installed use it as:\n\nusing ReachabilityModels, Plots\n\nprob = fetch_model(\"building\") # initial-value problem\n\nsol = solve(prob, T=5.0); # solve it using default options\n\nplot(sol, vars=(0, 25)) # plot the solution","category":"section"},{"location":"generated_examples/ISS/#International-Space-Station","page":"International Space Station","title":"International Space Station","text":"note: Overview\nSystem type: Linear continuous system\nState dimension: 270\nApplication domain: Aerospace engineering","category":"section"},{"location":"generated_examples/ISS/#Model-description","page":"International Space Station","title":"Model description","text":"This is a model of component 1r (Russian service module) of the International Space Station [ASG01]. It has 270 states, 3 inputs and 3 outputs. The model consists of a continuous linear time-invariant system\n\nbeginaligned\n    dotx(t) = Ax(t) + Bu(t)qquad u(t)  mathcalU \n    y(t) = Cx(t)\nendaligned\n\nIt was proposed as a benchmark in Tran et al. [TNJ16]. The matrix dimensions are A  mathbbR^270  270, B  mathbbR^270  3, and C  mathbbR^3  270.\n\nThe matrices A, B, and C are available in MATLAB format here (iss.mat). For convenience, the .mat file has been converted to the JLD2 format and stored in iss.jld2.\n\nThere are two versions of this benchmark, ISSF01 (time-varying inputs) and ISSC01 (constant inputs).\n\nISSF01 (time-varying inputs): In this setting, the inputs can change arbitrarily over time: forall t u(t)  mathcalU.\nISSC01 (constant inputs): The inputs are only uncertain in their initial value, and constant over time: u(0)  mathcalU, dotu(t) = 0.\n\nusing ReachabilityAnalysis, JLD2, ReachabilityBase.CurrentPath\nusing ReachabilityAnalysis: add_dimension\n\npath = @current_path(\"ISS\", \"ISS.jld2\")\n\n@load path C\nconst C3 = C[3, :]  # variable y₃\nconst C3_ext = vcat(C3, fill(0.0, 3));\nnothing #hide","category":"section"},{"location":"generated_examples/ISS/#Specifications","page":"International Space Station","title":"Specifications","text":"Initially, all variables are in the range -00001 00001, and the inputs are bounded: u_1(t)  0 01, u_2(t)  08 1, and u_3(t)  09 1. The time bound is 20.\n\nThe verification goal is to check the ranges reachable by the output y_3(t), which is a linear combination of the state variables. In addition to the safety specification, for each version there is an UNSAT instance that serves as sanity checks to ensure that the model and the tool work as intended. But there is a caveat: In principle, verifying an UNSAT instance only makes sense formally if a witness is provided (counterexample, underapproximation, etc.). We instead run the tool with the same accuracy settings on an SAT-UNSAT pair of instances. The SAT instance demonstrates that the overapproximation is not too coarse, and the UNSAT instance demonstrates that the overapproximation is indeed conservative.\n\nISS01: Bounded time, safe property: For all t  0 20,        y_3(t)  00007 00007. This property is used with the        uncertain input case (ISSF01) and should be proven.\nISS02: Bounded time, safe property: For all t  0 20,        y_3(t)  00005 00005. This property is used with the        constant input case (ISSC01) and should be proven.\nISU01: Bounded time, unsafe property: For all t  0 20,        y_3 (t)  00005 00005. This property is used with the        uncertain input case (ISSF01) and should not be proven.\nISU02: Bounded time, unsafe property: For all t  0 20,        y_3 (t)  000017 000017. This property is used with the        constant input case (ISSC01) and should not be proven.\n\nfunction ISS_common(n)\n    X0 = BallInf(zeros(n), 0.0001)\n    U = Hyperrectangle(; low=[0.0, 0.8, 0.9], high=[0.1, 1.0, 1.0])\n    return X0, U\nend\n\nfunction ISSF01()\n    @load path A B\n    X0, U = ISS_common(size(A, 1))\n    return @ivp(x' = A * x + B * u, x(0) ∈ X0, u ∈ U, x ∈ Universe(270))\nend\n\nfunction ISSC01()\n    @load path A B\n    A_ext = add_dimension(A, 3)\n    A_ext[1:270, 271:273] = B\n    X0, U = ISS_common(size(A, 1))\n    return @ivp(x' = A_ext * x, x(0) ∈ X0 * U)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/ISS/#Results","page":"International Space Station","title":"Results","text":"The specification involves only the output y(t) = C_3 x(t), where C_3 denotes the third row of the output matrix C  mathbbR^3  270. Hence, it is sufficient to compute the flowpipe associated with y(t) directly, without the need of actually computing the full 270-dimensional flowpipe associated with all state variables. The flowpipe associated with a linear combination of state variables can be computed efficiently using the support-function based algorithm [LG09]. The idea is to define a template polyhedron with only two supporting directions, namely C_3 and -C_3.\n\nThe chosen step sizes are 610^-4 for ISSF01 and 110^-2 for ISSC01.","category":"section"},{"location":"generated_examples/ISS/#ISSF01","page":"International Space Station","title":"ISSF01","text":"dirs = CustomDirections([C3, -C3])\nprob_ISSF01 = ISSF01()\nsol_ISSF01 = solve(prob_ISSF01; T=20.0,\n                   alg=LGG09(; δ=6e-4, template=dirs, sparse=true, cache=false));\nnothing #hide\n\nThe solution sol_ISSF01 is a 270-dimensional set that (only) contains template reach sets for the linear combination C_3 x(t).\n\ndim(sol_ISSF01)\n\nFor visualization, it is necessary to specify that we want to plot \"time\" vs. y_3(t). We can transform the flowpipe on the output y_3(t) by converting the support function bounds to intervals along directions dirs.\n\nπsol_ISSF01 = to_intervals(sol_ISSF01);\nnothing #hide\n\nNow πsol_ISSF01 is a one-dimensional flowpipe.\n\ndim(πsol_ISSF01)\n\ntip: Performance tip\nNote that projecting the solution along direction C_3 corresponds to computing the min and max bounds for each reach set X, i.e., (-ρ(-C3, X), ρ(C3, X)). However, the method to_intervals(sol_ISSF01, rows=(1, 2)) is more efficient since it uses the matrix of support-function evaluations obtained by LGG09 along directions C_3 and -C_3.\n\nusing Plots, Plots.PlotMeasures, LaTeXStrings\nimport DisplayAs  #hide\n\nold_ztol = LazySets._ztol(Float64)\nLazySets.set_ztol(Float64, 1e-8);  # use higher precision for the plots\nnothing #hide\n\nfig = plot(πsol_ISSF01[1:10:end]; vars=(0, 1), linecolor=:blue, color=:blue,\n           alpha=0.8, xlab=L\"t\", ylab=L\"y_{3}\", xtick=[0, 5, 10, 15, 20.0],\n           ytick=[-0.00075, -0.0005, -0.00025, 0, 0.00025, 0.0005, 0.00075],\n           xlims=(0.0, 20.0), ylims=(-0.00075, 0.00075),\n           bottom_margin=6mm, left_margin=2mm, right_margin=4mm, top_margin=3mm)\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/ISS/#ISSC01","page":"International Space Station","title":"ISSC01","text":"dirs = CustomDirections([C3_ext, -C3_ext])\nprob_ISSC01 = ISSC01()\nsol_ISSC01 = solve(prob_ISSC01; T=20.0,\n                   alg=LGG09(; δ=0.01, template=dirs, sparse=true, cache=false));\nnothing #hide\n\nWe can convert the flowpipe to intervals for the output y_3(t) as before:\n\nπsol_ISSC01 = to_intervals(sol_ISSC01);\nnothing #hide\n\nfig = plot(πsol_ISSC01; vars=(0, 1), linecolor=:blue, color=:blue, alpha=0.8,\n           lw=1.0, xlab=L\"t\", ylab=L\"y_{3}\", xtick=[0, 5, 10, 15, 20.0],\n           ytick=[-0.0002, -0.0001, 0.0, 0.0001, 0.0002],\n           xlims=(0.0, 20.0), ylims=(-0.0002, 0.0002),\n           bottom_margin=6mm, left_margin=2mm, right_margin=4mm, top_margin=3mm)\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nLazySets.set_ztol(Float64, old_ztol);  # reset precision\nnothing #hide","category":"section"},{"location":"tutorials/set_representations/zonotopes/#Zonotopes","page":"Zonotopic sets","title":"Zonotopes","text":"Zonotopes are a sub-class of polytopes defined as the image of a unit cube under an affine transformation. For example,\n\nusing LazySets, Plots #hide\nusing LazySets: center #hide\n\nB = BallInf(zeros(2), 1.0) # unit cube\nM = [0 1; -1 0] # an affine transformation\n\nZ = linear_map(M, B) # zonotope\n\nZonotopes are commonly represented using their generator representation. Here, a zonotope Z  mathbbR^n is defined by a center c  mathbbR^n and a finite number of generators g_1     g_p  mathbbR^n such that\n\nZ = left c + sum_i=1^p ξ_i g_i  ξ_i  1 1right\n\nIt is common to note Z = (c  g_1     g_p ) or simply Z = (c G), where g_i is the i-th column of G. In the example above,\n\n@show center(Z)\n\n@show genmat(Z)\n\nThe generators can be\n\nZ3 = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1])\n\nThe order of a zonotope is the ratio between the number of dimensions and the number of generators; i.e. o = frackn. Use the function order(Z) to get the order of a given zonotope.\n\nZ = Zonotope([1, 1.], [-1 0.3 1.5 0.3; 0 0.1 -0.3 0.3])\nplot(Z)\nquiver!(fill(1., 4), fill(1., 4), quiver=(genmat(Z)[1, :], genmat(Z)[2, :]), color=:black)","category":"section"},{"location":"tutorials/set_representations/zonotopes/#Other-characterizations","page":"Zonotopic sets","title":"Other characterizations","text":"There are other useful characterization of zonotopes. A zonotope can be seen as the Minkowski addition of line segments resulting in centrally symmetric convex polytopes as shown in the following figure, which illustrates how each generator spans the zonotope.","category":"section"},{"location":"tutorials/set_representations/zonotopes/#Operations-with-zonotopes","page":"Zonotopic sets","title":"Operations with zonotopes","text":"The cost is measured in terms of the number of binary operations, mathrmOp().\n\nZ_1 = (c  v_1  v_k ) Z_2 = (d  w_1  w_m )  mathbbR^n M  mathbbR^m times n\n\nZ_1 oplus Z_2 = (c+d  v_1  v_k w_1  w_m )\n\nMZ_1 = (Mc  Mv_1  Mv_k )\n\nCH(Z_1 e^AδZ_1)  frac12(c + e^Aδc v_1 + e^Aδv_1  v_k+e^Aδv_k v_1 - e^Aδv_1 v_k - e^Aδv_k c - e^Aδc  )\n\nOperation Simplification Rule Cost\nZ_1 oplus Z_2  n\nMZ_1  2mn(k+1)\nCH(Z_1 e^AδZ_1)  2n^2(k+1)+2n(k+2)","category":"section"},{"location":"lib/algorithms/VREP/#ReachabilityAnalysis.VREP","page":"VREP","title":"ReachabilityAnalysis.VREP","text":"VREP{N, AM, S, D} <: AbstractContinuousPost\n\nImplementation of a linear reachability solver using the vertex representation.\n\n\n\n\n\n","category":"type"},{"location":"lib/projections/#Projections","page":"Projections","title":"Projections","text":"","category":"section"},{"location":"lib/projections/#Concrete-projection","page":"Projections","title":"Concrete projection","text":"TODO: document project","category":"section"},{"location":"lib/projections/#Lazy-projection","page":"Projections","title":"Lazy projection","text":"TODO: document Projection","category":"section"},{"location":"lib/projections/#LazySets.Projection","page":"Projections","title":"LazySets.Projection","text":"Projection(fp::AbstractFlowpipe, vars::NTuple{D,Int}) where {D}\n\nReturn the lazy projection of a flowpipe.\n\nInput\n\nOutput\n\nNotes\n\nThe projection is lazy, and consists of mapping each set X in the flowpipe to MX, where M is the projection matrix associated with the given variables vars.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear_methods/discrete_time/#Set-propagation-in-discrete-time","page":"Discrete time reachability","title":"Set propagation in discrete time","text":"Our motivating example is to solve the following simple linear set-based recurrence\n\nX_k+1 = M(θ) X_k qquad 0  k  50 X_0 = 08 12 times 08 12  mathbbR^2\n\nLet θ  0 2 π be an equally spaced vector of length 50, and M(θ) is the rotation matrix given by:\n\nM(θ) = beginpmatrixcosθ  sinθ  -sinθ  cosθ endpmatrix\n\nThe matrix M(θ) rotates points in the xy-plane clockwise through an angle θ around the origin of a two-dimensional Cartesian coordinate system.","category":"section"},{"location":"tutorials/linear_methods/discrete_time/#Propagating-point-clouds","page":"Discrete time reachability","title":"Propagating point clouds","text":"To gain some intuition, let's build the matrix and apply it to some points.\n\nusing ReachabilityAnalysis, Plots\nusing ReachabilityAnalysis: center\nimport Optim\n\n# initial set\nX0 = BallInf(ones(2), 0.2)\n\n# rotation matrix\nM(θ) = [cos(θ) sin(θ); -sin(θ) cos(θ)]\n\nfig = plot(X0, c=:white)\nplot!(M(pi/4) * X0, c=:white)\n\n# center of the initial set\nc = center(X0) |> Singleton\n\n# list of vertices\nV = vertices_list(X0) .|> Singleton |> UnionSetArray\n\nplot!(c)\nplot!(V)\nplot!(M(pi/4) * c) # rotate 45 degrees\nplot!(linear_map(M(pi/4), V))\n\nxlims!(0.0, 1.8) # hide\nylims!(-0.4, 1.4) # hide\n\nimport DisplayAs  # hide\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nX = sample(X0, 25) .|> Singleton |> UnionSetArray\n\nplot!(X)\nplot!(linear_map(M(pi/4), X), c=:blue)     # rotate 45 degrees\nplot!(linear_map(M(pi/2), X), c=:green)    # rotate 90 degrees\nplot!(linear_map(M(4pi/3), X), c=:orange)  # rotate 180 degrees\n\nplot!(X0, c=:white)\nplot!(M(pi/4) * X0, c=:white)\nplot!(M(pi/2) * X0, c=:white)\nplot!(M(4pi/3) * X0, c=:white)\n\nxlims!(0.0, 1.8) # hide\nylims!(-0.4, 1.4) # hide\n\nDoes propagating point clouds solve the problem? Practically speaking, while we can compute the successors of any x_0  X_0 we still lack a global description of the set according the the given discrete recurrence.. which brings us back to the original question: how to represent the solution of the recurrence for all points in simultaneous?","category":"section"},{"location":"tutorials/linear_methods/discrete_time/#Propagating-zonotopes","page":"Discrete time reachability","title":"Propagating zonotopes","text":"The set representation that is most effective to this problem are zonotopes since they are closed under linear maps. Moreover, since the initial states is a hyperrectangle (thus a zonotope), we can propagate the whole set exactly (and efficiently).\n\nWe now implement the solution by propagating zonotopes.\n\n# map X0 according to the rotation matrix\nX0z = convert(Zonotope, X0)\n\narr = [linear_map(M(θi), X0z) for θi in range(0, 2pi, length=50)]\n\nfig = plot(arr, ratio=1., alpha=1.)\nplot!(X0, lw=2.0, ls=:dash, alpha=1., c=:white)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\ntypeof(arr)\n\nX0\n\nconvert(Zonotope, X0)\n\ngenmat(arr[1])\n\n(do ?Zonotope for the docstring)\n\ngenmat(arr[2])\n\nM(2pi/50) * genmat(arr[1])\n\nThe set effectively rotates clockwise around the origin:\n\nfig = plot(Singleton(zeros(2)))\nplot!(arr[1:10], ratio=1., alpha=1.)\nplot!(X0, lw=2.0, ls=:dash, alpha=1., c=:white)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nnote: Animations with Plots\nThe Julia package Plots.jl has a @gif functionality that can be used to created animated gifs. The following code animates the solution at 15 frames per second (fps).# map X0 according to the rotation matrix\nX0z = convert(Zonotope, X0)\n\nfig = plot()\nanim = @animate for θi in range(0, 2pi, length=50)\n    plot!(fig, linear_map(M(θi), X0z), lw=2.0, alpha=1., lab=\"\")\n    xlims!(-3, 3)\n    ylims!(-2, 2)\nend\ngif(anim, fps=15)\n\nNow we will use reach-sets and associate the angle θ with the time field.\n\n# propagate sets passing the time point (angle)\nRsets = [ReachSet(M(θi) * X0, θi) for θi in range(0, 2pi, length=50)]\nnothing # hide\n\nWe can pass an array of reach-sets to the plotting function:\n\nfig = plot(Rsets, vars=(1, 2), xlab=\"x\", ylab=\"y\", ratio=1., c=:blue)\nplot!(X0, c=:white, alpha=.6)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nSince reach-sets have time information, we can also plot the sequence in time.\n\nfig = plot(Rsets, vars=(0, 1), xlab=\"t\", lab=\"x(t)\", lw=2.0, lc=:blue, alpha=1.)\nplot!(Rsets, vars=(0, 2), lab=\"y(t)\", lw=2.0, lc=:orange, alpha=1.)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide","category":"section"},{"location":"tutorials/linear_methods/discrete_time/#What-is-a-flowpipe?","page":"Discrete time reachability","title":"What is a flowpipe?","text":"A flowpipe is a collection of reach-sets which behaves like their (set) union. Flowpipes attain the right level of abstraction in order to represent solutions of set-based problems.\n\nWe can instantiate a flowpipe by passing an array of reach-sets.\n\narr = [ReachSet(M(θi) * X0, θi) for θi in range(0, 2pi, length=50)]\n\nF = Flowpipe(arr)\ntypeof(F)\n\nWe can plot flowpipes, and all the reach-sets are plotted with the same color.\n\nfig = plot(F, vars=(1, 2), ratio=1.)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nFlowpipes implement Julia's array interface.\n\nlength(F)\n\nFor instance, do F[1:3:end] to plot one every three elements:\n\nplot!(F[1:3:end], vars=(1, 2), c=:red)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nOf course, it is also possible to use the wrapped array (do array(F)) directly. However, flowpipes can be used to filter reach-sets in time, among other operations.\n\ntspan.(F[1:5]) # time span of the first five reach-sets\n\nF(2pi) # find the reach-set at time t = 2pi\n\nWe can also pick, or filter, those reach-sets whose intersection is non-empty with a given time interval.\n\nF(2.5 .. 3.0) # returns a view\n\nWe can also filter by a condition on the time span using tstart and tend:\n\n# get all reach-sets from time t = 4 onwards\naux = F(4 .. tend(F));\n\nlength(aux)\n\nfig = plot(F, vars=(0, 1), xlab=\"t\", ylab=\"x\", lw=2.0, alpha=1.)\n\n# get all those reach-set whose time span is greater than 40\nplot!(aux, vars=(0, 1), lw=2.0, lc=:red, alpha=1.)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nFinally, observe that set operations with flowpipes are also supported. The following example intersects the flowpipe F with a half-space.\n\nH  = HalfSpace([1, 1.], 1.) # x + y ≤ 1\n\nQ = F ∩ H  # perform a lazy intersection\n\n# plot the result\nfig = plot(H, alpha=.3, lab=\"H\", c=:grey)\nplot!(F ∩ H, vars=(1, 2), ratio=1., lab=\"F ∩ H\")\nxlims!(-2.0, 2.0); ylims!(-2, 2.)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide","category":"section"},{"location":"tutorials/linear_methods/discrete_time/#Using-the-solve-interface-for-discrete-problems","page":"Discrete time reachability","title":"Using the solve interface for discrete problems","text":"By default, the solve interface propagates sets in dense time (as explained in the next section). However, it is possible to propagate sets in discrete time by specifying that the approximation model should not add any bloating to the initial states, approx_model=NoBloating() to the solver used.\n\nExercise. Solve the linear set based recurrence in the current section using the solve interface. Hint: use the algorithm alg=GLGM06(δ=0.05, approx_model=NoBloating()) and the state matrix as specified in the following section.","category":"section"},{"location":"man/algorithms/ORBIT/#Singleton-propagation-(ORBIT)","page":"ORBIT","title":"Singleton propagation (ORBIT)","text":"","category":"section"},{"location":"man/algorithms/ORBIT/#Method","page":"ORBIT","title":"Method","text":"Consider the ODE\n\nx(t) = Ax(t) + u qquad x_0  mathbbR^nqquad (1)\n\nwith A  mathbbR^ntimes n and u  mathbbR^n. The analytic solution at δ  0 is known to be\n\nx(δ) = e^Aδx_0 + _0^δ e^A(δ - s) uds\n\nLet us introduce the matrices Φ(A δ) = e^Aδ and Φ_1(A δ) = _0^δ e^A(δ - s) ds. The computation of these matrices will be discussed later.\n\nSince u is assumed constant,\n\nx(δ) = Φ x_0 + v\n\nwhere we have defined v = Φ_1(A δ) u. To get the exact solution at t = 2δ, note that by time invariance of Eq. (1),\n\nx(2δ) = e^Aδ x(δ) + _0^δ e^A(δ - s)u ds\n\nhence\n\nx(2δ) = Φ (Φ x_0 + v) + v = Φ^2 x_0 + Φ v + v\n\nThe solution at subsequent multiples of the step-size δ is achieved by applying the preceding rule iteratlvely. For any k  1, we obtain\n\nx(kδ) = Φ^k x_0 + sum_i=0^k-1 Φ^i vqquad k  1\n\nBefore considering the computation of Φ and Φ_1, note that the method admits a straightforward generalization for non-constant inputs. Indeed, if u  0 Tto mathbbR^n is a piecewise-constant function, there always exists a sufficiently small step-size δ such that the following premise holds. Assume that u_1 u_2  u_N  mathbbR^n is the range of values of the input, where u(t) = u_k for t  (k-1)δ kδ), k = 1  N, and let v_k = Φ_1(u_k δ) for all k = 1 N. Then it holds that x(δ) = Φ x_0 + v_1, x(2δ) = Φ^2 x_0 + Φ v_1+ v_2, and\n\nx(kδ) = Φ^k x_0 + sum_i=0^k-1 Φ^i v_k-iqquad k = 1 N\n\nThe matrix Φ = e^Aδ can be evaluated in different ways, using the function ReachabilityAnalysis.Exponentiation._exp:\n\n(1) method = :base uses Julia's built-in implementation (if method = :base),\n\n(2) method = :lazy uses a lazy wrapper of the matrix exponential which is then evaluated using Krylov subspace methods.\n\nMethod (1) is the default method. Method (2) is particularly useful to work with very large and sparse matrices (e.g. typically of order n > 2000). Evaluation of Φ_1(u δ) is available through the function ReachabilityAnalysis.Exponentiation.Φ₁. Two implementations are available:\n\n(1) If the coefficients matrix A is invertible, then the integral is equivalent to computing A^-1(e^Aδ - I).\n\n(2) In general, Φ_1(u δ) can be obtained as a sub-block of a larger matrix. See Frehse et al. [FLD+11] for details.\n\nMethod (2) is the default method, although there are cases in which method (1) is more convenient. For example, if we are only interested in singleton inputs and A is invertible, it is possible to compute Φ_1(A δ) u efficiently without actually inverting the matrix A in full.","category":"section"},{"location":"man/algorithms/BOX/#Hyperrectangle-based-method-(BOX)","page":"BOX","title":"Hyperrectangle-based method (BOX)","text":"","category":"section"},{"location":"man/algorithms/BOX/#Method","page":"BOX","title":"Method","text":"","category":"section"},{"location":"man/algorithms/BOX/#Examples","page":"BOX","title":"Examples","text":"","category":"section"},{"location":"generated_examples/ProductionDestruction/#Production/Destruction","page":"Production-Destruction","title":"Production/Destruction","text":"note: Overview\nSystem type: Rational continuous system\nState dimension: 3\nApplication domain: Chemical kinetics","category":"section"},{"location":"generated_examples/ProductionDestruction/#Model-description","page":"Production-Destruction","title":"Model description","text":"A production-destruction system consists of an ordinary differential equation and two constraints: positivity and conservativity. It means that the system states are quantities which are always positive and their sum is constant. This particular family of systems is often used to test the stability of integration schemes.\n\nAs proposed by Michaelis-Menten theory [KM18], a model for three quantities can be defined as follows:\n\nbeginaligned\n    dotx = dfrac-xy1+x 2mm\n    doty = dfracxy1+x - a y 2mm\n    dotz = a y\nendaligned\n\nwith nominal value a = 03 and an initial condition x(0) = 998, y(0) = 001, and z(0) = 001. In this model, x represents the nutrients, y the phytoplankton, and z the detritus. In this case study, we analyze the behavior of the system subject to uncertainties in the initial condition and/or the model's parameter a.","category":"section"},{"location":"generated_examples/ProductionDestruction/#Specification","page":"Production-Destruction","title":"Specification","text":"The solution should satisfy the following two constraints:\n\nPositivity: x(t), y(t), z(t) are positive, and\nConservativity: x(t) + y(t) + z(t) = 10 for all t  0.\n\nHere we are interested in computing the reachable tube until the time horizon T=100 and to verify the constraints 10  x+y+z and x y z  0 at T = 100. Three setups are considered, depending on the source of bounded uncertainties:\n\nCase I: x(0)  95 100, i.e., uncertainty in the initial condition;\nCase P: a  0296 0304, i.e., uncertainty in the parameter value;\nCase I & P: x(0)  95 100 and a  0296 0304, i.e., both uncertainties are present.\n\nThe reachability settings considered above are a variation of those in Geretti et al. [GSA+20]. Note that variables x and y converge towards zero, so the final volume can be used as a quality measure of the overapproximation.\n\nWe consider two measures of quality of the approximation: the volume of the box (x  y  z) enclosing the final states (at T = 100) and the total time of computation for evolution and verification. These results are obtained for the three setups.\n\nWe discuss the implementation of each constraint satisfaction problem, beginning by defining the positive orthant in three-dimensional space, positive_orthant, as an unbounded polyhedron in constraint representation.\n\nusing ReachabilityAnalysis, Symbolics\n\n@variables x y z\npositive_orthant = HPolyhedron([x >= 0, y >= 0, z >= 0], [x, y, z]);\nnothing #hide\n\nGiven a set X  mathbbR^n, checking whether the positivity constraint holds corresponds to checking whether X is included in the positive orthant. This computation can be done efficiently using the support function, which is available in LazySets.jl. Multiple dispatch takes care based on the types of the arguments in the call X ⊆ positive_orthant depending on the type of X.\n\nOn the other hand, given a set X, a quick way to check the conservativity constraint is to first overapproximate X with a box, then represent this box as a product-of-intervals (IntervalBox) B, and finally take the Minkowski sum of each interval, using sum(B). This check is only sufficient; splitting X can be used to refine the check.\n\nThe verification problem is summarized in the function prod_dest_verif. It receives the solution of a reachability problem represented with a Taylor-model flowpipe and two optional arguments that specify the time horizon T, which defaults to 100, and the conservativity condition given a target value target, which defaults to 10. The function returns the tuple (sat, vol). The first output, sat, is true if and only if the positivity and conservativity conditions are satisfied at the time horizon T. The second output, vol, corresponds to the volume of the box overapproximation of the final reach set.\n\nfunction prod_dest_verif(sol; T=100.0, target=10.0)\n    # obtain the final reach set and project onto the state variables x, y, z\n    Xh = box_approximation(sol(T))\n    X = project(Xh; vars=(1, 2, 3))\n\n    # check that all variables are nonnegative\n    nonnegative = X ⊆ positive_orthant\n\n    # compute the volume\n    vol = volume(X)\n\n    # check that the target belongs to the Minkowski sum of the projections\n    # onto each coordinate\n    B = convert(IntervalBox, X) # get a product-of-intervals representation\n    contains_target = target ∈ sum(B)\n\n    return nonnegative && contains_target, vol\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/ProductionDestruction/#Analysis-and-Results","page":"Production-Destruction","title":"Analysis & Results","text":"","category":"section"},{"location":"generated_examples/ProductionDestruction/#Case-I","page":"Production-Destruction","title":"Case I","text":"Case I corresponds to uncertainty in the initial states. We begin by writing the system of differential equations in the function prod_dest_I!.\n\n@taylorize function prod_dest_I!(du, u, p, t)\n    local a = 0.3\n    x, y, z = u\n\n    xyx = (x * y) / (1 + x)\n    ay = a * y\n\n    du[1] = -xyx\n    du[2] = xyx - ay\n    du[3] = ay\n    return du\nend\n\nThe initial states are uncertain in dimension x.\n\nX0 = Hyperrectangle(; low=[9.5, 0.01, 0.01], high=[10, 0.01, 0.01])\nprob = @ivp(x' = prod_dest_I!(x), dim:3, x(0) ∈ X0);\nnothing #hide","category":"section"},{"location":"generated_examples/ProductionDestruction/#Analysis","page":"Production-Destruction","title":"Analysis","text":"sol = solve(prob; T=100.0, alg=TMJets(; abstol=1e-12, orderT=6, orderQ=1));\nnothing #hide\n\nVerify that the specification holds:\n\nproperty, vol = prod_dest_verif(sol)\n@assert property \"the property should be proven\"\nvol","category":"section"},{"location":"generated_examples/ProductionDestruction/#Results","page":"Production-Destruction","title":"Results","text":"We plot z over time.\n\nusing Plots\nimport DisplayAs  #hide\n\nfig = plot(sol; vars=(0, 3), lc=:orange, c=:orange, alpha=0.3, lab=\"I\", xlab=\"t\", ylab=\"z\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/ProductionDestruction/#Case-P","page":"Production-Destruction","title":"Case P","text":"For the case of an uncertain parameter, we add a new state variable that corresponds to a, with constant (zero) dynamics.\n\n@taylorize function prod_dest_IP!(du, u, p, t)\n    x, y, z, a = u[1], u[2], u[3], u[4]\n\n    xyx = (x * y) / (1 + x)\n    ay = a * y\n\n    du[1] = -xyx\n    du[2] = xyx - ay\n    du[3] = ay\n    du[4] = zero(a)\n    return du\nend\n\nX0 = Hyperrectangle(; low=[9.98, 0.01, 0.01, 0.296], high=[9.98, 0.01, 0.01, 0.304])\nprob = @ivp(x' = prod_dest_IP!(x), dim:4, x(0) ∈ X0);\nnothing #hide","category":"section"},{"location":"generated_examples/ProductionDestruction/#Analysis-2","page":"Production-Destruction","title":"Analysis","text":"sol = solve(prob; T=100.0, alg=TMJets(; abstol=9e-13, orderT=6, orderQ=1));\nnothing #hide\n\nVerify that the specification holds:\n\nproperty, vol = prod_dest_verif(sol)\n@assert property \"the property should be proven\"\nvol","category":"section"},{"location":"generated_examples/ProductionDestruction/#Results-2","page":"Production-Destruction","title":"Results","text":"We plot z over time.\n\nfig = plot(sol; vars=(0, 3), lc=:blue, c=:blue, alpha=0.3, lab=\"P\", xlab=\"t\", ylab=\"z\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/ProductionDestruction/#Case-I-and-P","page":"Production-Destruction","title":"Case I & P","text":"When uncertainty in both the initial states and the parameters are present, we can reuse the function prod_dest_IP!, but setting an uncertain initial condition and an uncertain parameter. Recall that we are interested in x(0)  95 100 and a  0296 0304.\n\nX0 = Hyperrectangle(; low=[9.5, 0.01, 0.01, 0.296], high=[10, 0.01, 0.01, 0.304])\nprob = @ivp(x' = prod_dest_IP!(x), dim:4, x(0) ∈ X0);\nnothing #hide","category":"section"},{"location":"generated_examples/ProductionDestruction/#Analysis-3","page":"Production-Destruction","title":"Analysis","text":"sol = solve(prob; T=100.0, alg=TMJets(; abstol=1e-12, orderT=6, orderQ=1));\nnothing #hide\n\nVerify that the specification holds:\n\nproperty, vol = prod_dest_verif(sol)\n@assert property \"the property should be proven\"\nvol","category":"section"},{"location":"generated_examples/ProductionDestruction/#Results-3","page":"Production-Destruction","title":"Results","text":"We plot z over time.\n\nfig = plot(sol; vars=(0, 3), lc=:red, c=:red, alpha=0.3, lab=\"I & P\", xlab=\"t\", ylab=\"z\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"lib/algorithms/ORBIT/#ReachabilityAnalysis.ORBIT","page":"ORBIT","title":"ReachabilityAnalysis.ORBIT","text":"ORBIT{N, VT, AM} <: AbstractContinuousPost\n\nImplementation of discrete-time integration for deterministic linear ODEs for singleton initial conditions and proper input sets.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: NoBloating) approximation model\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – type of the approximation model\n\nNotes\n\nIf the input set is a singleton, the result is the discrete-time sequence of states that correspond to the analytic solution. If the input set is a dense set, we sample a new input signal in every step.\n\nReachability solutions computed with the ORBIT algorithm have its own plot recipe, producing a scatter plot. Use the markershape option to change the shape of the markers used for the scatter plot. To \"connect\" the points, use the option seriestype=:path. For additional options see the Plots.jl documentation.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/A20/#Krylov-method-for-large-linear-systems-(A20)","page":"A20","title":"Krylov method for large linear systems (A20)","text":"","category":"section"},{"location":"man/algorithms/A20/#Method","page":"A20","title":"Method","text":"","category":"section"},{"location":"man/algorithms/A20/#Examples","page":"A20","title":"Examples","text":"","category":"section"},{"location":"lib/algorithms/INT/#ReachabilityAnalysis.INT","page":"INT","title":"ReachabilityAnalysis.INT","text":"INT{N, AM} <: AbstractContinuousPost\n\nImplementation of a reachability method for linear one-dimensional systems interval arithmetic.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\n\nThe default approximation model used in this algorithm is:\n\nForward(sih=:concrete, exp=:base, setops=:Interval)\n\nIn particular, the setops=:Interval flag specifies that intermediate computations in the discretization are done using interval arithmetic. This allows for some optimizations.\n\nReferences\n\nThis algorithm is essentially a non-decomposed version of the method in Bogomolov et al. [BFF+18], using intervals as set representation. For a general introduction we refer to the dissertation [LG09].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in Frehse et al. [FLD+11].\n\nInterval arithmetic operations are performed using the IntervalArithmetic.jl package. Hence, the results are guaranteed to comply to the IEE754 standard with respect to the floating-point operations using intervals.\n\n\n\n\n\n","category":"type"},{"location":"#ReachabilityAnalysis.jl","page":"Overview","title":"ReachabilityAnalysis.jl","text":"","category":"section"},{"location":"#What-is-reachability-analysis?","page":"Overview","title":"What is reachability analysis?","text":"Reachability analysis is a numerical method that aims to compute sets of states reachable by dynamical systems from all initial states and for all admissible inputs and parameters.","category":"section"},{"location":"#Where-is-reachability-being-applied?","page":"Overview","title":"Where is reachability being applied?","text":"Reachability analysis is of interest in diverse domains including automotive, aerospace, power systems, system biology, analog/mixed-signal circuits, robotics, and safe machine learning.\n\nBelow we briefly comment on a few remarkable problems where reachability is being applied. We refer to the technical literature for further applications; see Bibliography for a selection of papers to get you started! An up-to-date review with relevant references can be found in Althoff et al. [AFG21].\n\nFormal verification. Determining whether a system is safe, i.e. to verify if it does not enter into a region of unsafe sets. Typical applications are assessing the critical distance between autonomous vehicles or robots, or critical concentration of chemicals in a reactor.\n\nValidation of control strategies. Checking if the system trajectories stay in a region around a reference trajectory, or reach a goal region around a setpoint, for any admissible value of the non-deterministic inputs, initial conditions or noise.\n\nController synthesis. The controller synthesis problem consists in finding parameter sets of controllers that satisfy safety or performance constraints.\n\nDeep neural network verification. Providing formal guarantees for the network behavior subject to perturbations in the inputs, e.g. detecting that small changes in an input image do not cause the network o misclassify it.","category":"section"},{"location":"#How-to-read-this-manual","page":"Overview","title":"How to read this manual","text":"Please note that the manual contains a Frequently Asked Questions (FAQ) section with a selection of different questions and answers, many of them with working code so that you can also experiment with the answers.\n\nnote: Note\nIf you have questions, want to chat about how to apply this package, or if you found a bug or have trouble running an example, feel free to open an issue or make a pull request on the project's GitHub page. You can also find us at the #reachability-analysis stream on JuliaLang's Zulip channel, and at the JuliaReach Gitter channel.","category":"section"},{"location":"#Features","page":"Overview","title":"Features","text":"This library implements reachability analysis methods for systems of ordinary differential equations (ODEs), for both continuous and hybrid dynamical systems.\n\nThe following types of systems are currently supported:\n\nContinuous ODEs with linear dynamics.\nContinuous ODEs with non-linear dynamics.\nHybrid systems with piecewise-affine dynamics.\nHybrid systems with non-linear dynamics.\nHybrid systems with space-triggered or time-triggered transitions.\n\nThe library can handle uncertainties in the sets of initial states, inputs, or parameter variation.","category":"section"},{"location":"#How-to-install-the-package?","page":"Overview","title":"How to install the package?","text":"You can easily install ReachabilityAnalysis.jl from your Julia console (press ] in the Julia REPL to enter the pkg> mode):\n\npkg> add ReachabilityAnalysis","category":"section"},{"location":"lib/discretize/#Discretization","page":"Discretization","title":"Discretization","text":"Pages = [\"discretize.md\"]\nDepth = 3","category":"section"},{"location":"lib/discretize/#Discretize-API","page":"Discretization","title":"Discretize API","text":"","category":"section"},{"location":"lib/discretize/#Approximation-models","page":"Discretization","title":"Approximation models","text":"","category":"section"},{"location":"lib/discretize/#Exponentiation","page":"Discretization","title":"Exponentiation","text":"The state transition matrix of the linear ODE x(t) = Ax(t) + u(t) at time δ  0 is Φ = e^Aδ, hence the algorithms usually require to compute exponential matrices. There are distinct ways to compute the matrix exponential e^Aδ depending on the type of A (see, e.g., [Hig08]). The available methods can be used through the (unexported) function _exp.\n\nFor high dimensional systems (typically n > 2000), computing the matrix exponential is expensive hence it is preferable to compute the action of the matrix exponential over vectors when needed, that is, e^δA v for each v. This method is particularly well-suited if A is vert sparse. Use the option exp=:krylov (or exp=:lazy) for this purpose.","category":"section"},{"location":"lib/discretize/#ReachabilityAnalysis.DiscretizationModule","page":"Discretization","title":"ReachabilityAnalysis.DiscretizationModule","text":"Interface for conservative time discretization methods.\n\n\n\n\n\n","category":"module"},{"location":"lib/discretize/#LinearAlgebra.normalize","page":"Discretization","title":"LinearAlgebra.normalize","text":"normalize(system::AbstractSystem)\n\nTransform a mathematical system to a normalized (or canonical) form.\n\nInput\n\nsystem – system; it can be discrete or continuous\n\nOutput\n\nEither the same system if it already conforms to a canonical form, or a new system otherwise.\n\nNotes\n\nThe normalization procedure consists of transforming a given system type into a \"canonical\" format that is used internally. More details are given below.\n\nAlgorithm\n\nThe implementation of normalize exploits MathematicalSystems's' types, which carry information about the problem as a type parameter.\n\nHomogeneous ODEs of the form x = Ax x  mathcalX are canonical if the associated problem is a ConstrainedLinearContinuousSystem and A is a matrix. This type does not handle non-deterministic inputs.\n\nNote that a LinearContinuousSystem does not consider constraints on the state-space (such as an invariant); to specify state constraints, use a ConstrainedLinearContinuousSystem. If the passed system is a LinearContinuousSystem (i.e. no constraints) then the normalization fixes a universal set (Universe) as the constraint set.\n\nThe generalization to canonical systems with constraints and possibly time-varying non-deterministic inputs is considered next. These systems are of the form x = Ax + u u  mathcalU x  mathcalX. The system type is ConstrainedLinearControlContinuousSystem, where A is a matrix, X is a set and U is an input, that is, any concrete subtype of AbstractInput.\n\nIf U is not given as an input, normalization accepts either a LazySet, or a vector of LazySets. In these cases, the sets are wrapped around an appropriate concrete input type.\n\nIf the system does not conform to a canonical form, the implementation tries to make the transformation; otherwise an error is thrown. In particular, ODEs of the form x = Ax + Bu are mapped into x = Ax + u u  BmathcalU, where now u has the same dimensions as x.\n\nThe transformations described above are analogous in the discrete case, i.e. x_k+1 = A x_k and x_k+1 = Ax_k + u_k u_k  mathcalU x_k  mathcalX for the linear and affine cases respectively.\n\n\n\n\n\nnormalize(ivp::InitialValueProblem)\n\nTransform an initial-value problem into a normalized (or canonical) form.\n\nInput\n\nivp – initial-value problem\n\nOutput\n\nEither the same initial-value problem if it already conforms to a canonical form, or a new one otherwise.\n\nNotes\n\nThis function extends normalize for initial-value problems.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#MathematicalSystems.discretize","page":"Discretization","title":"MathematicalSystems.discretize","text":"discretize(ivp::IVP, δ, alg::AbstractApproximationModel)\n\nSet-based conservative discretization of a continuous-time initial value problem into a discrete-time problem.\n\nInput\n\nivp   – initial value problem for a linear ODE in canonical form (see Notes below)\nδ     – step size\nalg   – algorithm used to compute the approximation model\n\nOutput\n\nThe initial value problem of a discrete system.\n\nNotes\n\nDifferent approximation algorithms and their respective options are described in the docstring of each method. Here is a list of all the available approximation models:\n\njulia> subtypes(ReachabilityAnalysis.DiscretizationModule.AbstractApproximationModel)\n10-element Vector{Any}:\n Backward\n CorrectionHull\n CorrectionHullMatrixZonotope\n FirstOrder\n FirstOrderZonotope\n Forward\n ForwardBackward\n NoBloating\n SecondOrderddt\n StepIntersect\n\nInitial-value problems considered in this function are of the form\n\nx = Ax(t) + u(t)qquad x(0)  mathcalX_0qquad (1)\n\nand where u(t)  U(k) add where U(k)_k is a sequence of sets of non-deterministic inputs and mathcalX_0 is the set of initial states. Other problems, e.g. x = Ax(t) + Bu(t) can be brought to the canonical form with the function normalize.\n\nFor references to the original papers introducing each algorithm, see the docstrings, e.g. ?Forward.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.NoBloatingModule.NoBloating","page":"Discretization","title":"ReachabilityAnalysis.NoBloatingModule.NoBloating","text":"NoBloating{EM, SO, IT} <: AbstractApproximationModel\n\nNo bloating, or discrete-time, approximation model.\n\nFields\n\nexp     – exponentiation method\nsetops  – set operations method\ninv     – (optional, default: false) if true, assume that the state matrix              is invertible and use its inverse in the Φ functions\n\nAlgorithm\n\nThe transformations are:\n\nΦ  exp(Aδ)\nΩ_0  mathcalX_0\nV(k)  Φ₁(A δ)U(k), k  0.\n\nThe function Φ₁(A δ) is defined in Φ₁. We allow U to be a sequence of time varying non-deterministic input sets.\n\nSee also Bogomolov et al. [BFF+18], Eq. (14).\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.ForwardModule.Forward","page":"Discretization","title":"ReachabilityAnalysis.ForwardModule.Forward","text":"Forward{EM, SO, SI, IT, BT} <: AbstractApproximationModel\n\nForward approximation model.\n\nFields\n\nexp     – exponentiation method\nsetops  – set operations method\nsih     – symmetric interval hull\ninv     – (optional, default: false) if true, assume that the state matrix              is invertible and use its inverse in the Φ functions\nbackend – (optional, default: nothing) used if the algorithm needs to apply              concrete polyhedral computations\n\nAlgorithm\n\nThe transformations are:\n\nΦ  exp(Aδ),\nΩ_0  CH(mathcalX_0 ΦmathcalX_0  δU(0)  E_ψ(U(0) δ)  E^+(mathcalX_0 δ)),\nV(k)  δU(k)  E_ψ(U(k) δ).\n\nHere we allow U to be a sequence of time varying non-deterministic input sets.\n\nFor the definition of the sets E_ψ and E^+ see [FLD+11]. The Backward method uses E^-.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.BackwardModule.Backward","page":"Discretization","title":"ReachabilityAnalysis.BackwardModule.Backward","text":"Backward{EM, SO, SI, IT, BT} <: AbstractApproximationModel\n\nBackward approximation model.\n\nFields\n\nexp     – exponentiation method\nsetops  – set operations method\nsih     – symmetric interval hull\ninv     – (optional, default: false) if true, assume that the state matrix              is invertible and use its inverse in the Φ functions\nbackend – (optional, default: nothing) used if the algorithm needs to apply              concrete polyhedral computations\n\nAlgorithm\n\nThe transformations are:\n\nΦ  exp(Aδ),\nΩ_0  CH(mathcalX_0 ΦmathcalX_0  δU(0)  E_ψ(U(0) δ)  E^-(mathcalX_0 δ)),\nV(k)  δU(k)  E_ψ(U(k) δ).\n\nHere we allow U to be a sequence of time varying non-deterministic input sets.\n\nFor the definition of the sets E_ψ and E^- see [FLD+11]. The Forward method uses E^+.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.FirstOrderModule.FirstOrder","page":"Discretization","title":"ReachabilityAnalysis.FirstOrderModule.FirstOrder","text":"FirstOrder{EM} <: AbstractApproximationModel\n\nFirst-order approximation model.\n\nFields\n\nexp – (optional, default: BaseExp) exponentiation method\n\nAlgorithm\n\nThe transformations are [LG10]:\n\nΦ  exp(Aδ),\nΩ_0  CH(mathcalX_0 ΦmathcalX_0  δU  B_ε)\n\nwhere B_ε is the input ball of radius ε centered in the origin.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.FirstOrderZonotopeModule.FirstOrderZonotope","page":"Discretization","title":"ReachabilityAnalysis.FirstOrderZonotopeModule.FirstOrderZonotope","text":"FirstOrderZonotope{EM} <: AbstractApproximationModel\n\nFirst order approximation model that works with zonotopes.\n\nFields\n\nexp – (optional, default: BaseExp) exponentiation method\n\nAlgorithm\n\nThe transformations are:\n\nΦ  exp(Aδ),\nΩ_0  bloat(zono(CH(mathcalX_0 ΦmathcalX_0)) α + β)\n\nwhere bloat(mathcalX ε) bloats the set mathcalX with the value ε, zono() overapproximates its argument with a zonotope, and α and β are factors computed for the homogeneous system and the inputs, respectively.\n\nReference\n\nA. Girard: Reachability of uncertain linear systems using zonotopes. HSCC 2005.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.SecondOrderddtModule.SecondOrderddt","page":"Discretization","title":"ReachabilityAnalysis.SecondOrderddtModule.SecondOrderddt","text":"SecondOrderddt{EM, SO, SI, IT, BT} <: AbstractApproximationModel\n\nSecond-order approximation model used in the tool d/dt. It can be used for overapproximation and underapproximation.\n\nFields\n\noa      – (optional, default: true) flag to choose between              overapproximation and underapproximation\nexp     – (optional, default: BaseExp) exponentiation method\nsetops  – (optional, default: :lazy) set operations method\nsih     – (optional, default: :concrete) way to compute the symmetric              interval hull\ninv     – (optional, default: false) if true, assume that the state              matrix is invertible and use its inverse in the Φ functions\nbackend – (optional, default: nothing) used if the algorithm needs to              apply concrete polyhedral computations\n\nAlgorithm\n\nThe transformations are:\n\nΦ  exp(Aδ),\nΩ_0  bloat(CH(mathcalX_0 ΦmathcalX_0) ε)\n\nwhere bloat(mathcalX ε) bloats the set mathcalX with the value ε. If oa == false, the bloating acts in an inverted way and shrinks the set.\n\nReference\n\nE. Asarin, T. Dang, O. Maler, O. Bournez: Approximate reachability analysis of piecewise-linear dynamical systems. HSCC 2000.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.CorrectionHullModule.CorrectionHull","page":"Discretization","title":"ReachabilityAnalysis.CorrectionHullModule.CorrectionHull","text":"CorrectionHull{EM} <: AbstractApproximationModel\n\nDiscretization using the correction hull of the matrix exponential.\n\nFields\n\nexp   – exponentiation method\norder – order of the Taylor series expansion of the matrix exponential\n\nAlgorithm\n\nFor the homogeneous case, this method implements the transformation:\n\nΩ_0 = CH(X_0 e^Aδ  X_0)  FX_0\n\nwhere F is the correction (interval) matrix.\n\nFor the inhomogeneous case, x = Ax + u,  x  X u  U, implements Ω_0 = CH(X_0 exp(Aδ)  X0)  FX0 where F is the correction (interval) matrix.\n\nIn both cases, if A is an interval matrix, the exponential is overapproximated using methods from IntervalMatrices.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.StepIntersectModule.StepIntersect","page":"Discretization","title":"ReachabilityAnalysis.StepIntersectModule.StepIntersect","text":"StepIntersect{DM<:AbstractApproximationModel} <: AbstractApproximationModel\n\nApproximation model that composes (intersecting) one step Forward of a given model with one step backward of the same model.\n\nFields\n\nmodel  – approximation model\nsetops – set operations method\n\nNotes\n\nLet x = Ax with x(0)  X₀. This methods consists of:\n\nCompute the discretized system with step-size δ obtaining Ω0 and the given approximation model method.\nCompute the (lazy) linear map ΦX₀. This set consists of the (exact) reachable states at the time point δ.\nApply the approximation model method with initial condition ΦX₀ one step backward in time, with the state transition matrix -A, call this reach-set Ω₀\nIntersect Ω₀ and Ω₀ and return such set. The intersection is done either lazily or concretely depending on the specified setops field.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.CorrectionHullMatrixZonotopeModule.CorrectionHullMatrixZonotope","page":"Discretization","title":"ReachabilityAnalysis.CorrectionHullMatrixZonotopeModule.CorrectionHullMatrixZonotope","text":"CorrectionHullMatrixZonotope{R} <: AbstractApproximationModel\n\nImplementation of the discretization algorithm for linear systems with parametric uncertainty using matrix zonotopes by Huang et al. [HLBS25].\n\nFields\n\ntaylor_order     – (optional, default: 5) order of the Taylor series                       expansion of the matrix exponential for each step\nrecursive        – (optional, default: false) if true, compute the                       Taylor series expansion of the matrix zonotope                       exponential map recursively\n\nNotes\n\nThe recursive option is used to compute the Taylor expansion of the matrix zonotope exponential map. If recursive == true, each term of the Taylor expansion is computed recursively (e.g., A^2 P = A (A P)).\n\nIf recursive == false, the Taylor expansion is computed by overapproximating the matrix zonotope exponential  map, producing a single matrix that represents the exponential.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.Exponentiation","page":"Discretization","title":"ReachabilityAnalysis.Exponentiation","text":"Interface to matrix exponential backends of different kinds.\n\nIncludes common integral computations arising in the discretization of linear differential equations using matrix methods. For applications see, e.g., Forets and Schilling [FS22] and references therein.\n\n\n\n\n\n","category":"module"},{"location":"lib/discretize/#ReachabilityAnalysis.Exponentiation._exp","page":"Discretization","title":"ReachabilityAnalysis.Exponentiation._exp","text":"_exp(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp)\n\nCompute the matrix exponential e^Aδ.\n\nInput\n\nA    – matrix\nδ    – step size\nalg  – (optional, default: BaseExp) the algorithm used to take the matrix           exponential of Aδ, possible options are BaseExp, LazyExp,           PadeExp and IntervalExp (see details in the Algorithm section           below)\n\nOutput\n\nA matrix or a lazy wrapper of the matrix exponential, depending on alg.\n\nAlgorithm\n\nBaseExp – (alias: :base) use Higham's scaling-and-squaring method implemented              in Julia's standard library; see ?exp for details; if A is a static array,              uses the implementation in StaticArrays.jl\nLazyExp – (alias: :lazy) return a lazy wrapper around the matrix exponential              using the implementation LazySets.SparseMatrixExp\nPadeExp – (alias: pade) apply the Padé approximant method to compute the matrix              exponential of a sparse matrix (requires Expokit.jl)\nIntervalExp – (alias: interval, taylor) apply the Taylor series expansion of the matrix                  exponential with an interval remainder; works if A is an interval matrix\n\nNotes\n\nIf the algorithm LazyExp is used, actions of the matrix exponential are evaluated with an external library such as ExponentialUtilities.jl or Expokit.jl.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Exponentiation.Φ₁","page":"Discretization","title":"ReachabilityAnalysis.Exponentiation.Φ₁","text":"Φ₁(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp, [isinv]::Bool=false, [Φ]=nothing)\n\nEvaluate the series\n\nΦ₁(A δ) = _i=0^ dfracδ^i+1(i+1)A^i\n\nwhere A is a square matrix of order n and δ  0.\n\nInput\n\nA      – coefficients matrix\nδ      – step size\nalg    – (optional, default: BaseExp) the method used to take the matrix              exponential of the coefficient matrix; see the documentation of              _exp for available options\nisinv  – (optional, default: false) if true, assume that the coefficients             matrix is invertible and compute A^-1\nΦ      – (optional, default: nothing) optionally pass the matrix exponential e^Aδ\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nIf A is invertible, Φ₁ can be computed as\n\nΦ₁(A δ) = A^-1(e^Aδ - I_n)\n\nwhere I_n is the identity matrix of order n.\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP_2n = exp beginpmatrix\nAδ  δI_n \n0  0\nendpmatrix\n\nIt can be shown that\n\nexp(P_2n) = beginpmatrix\nΦ(A δ)  Φ₁(A δ) \n0   δI_n\nendpmatrix\n\nwhere Φ(A δ) = e^Aδ. In particular, Φ₁(A, δ) = P[1:n, (n+1):2*n]. This method can be found in Frehse et al. [FLD+11].\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Exponentiation.Φ₂","page":"Discretization","title":"ReachabilityAnalysis.Exponentiation.Φ₂","text":"Φ₂(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp, [isinv]::Bool=false, [Φ]=nothing)\n\nEvaluate the series\n\nΦ₂(A δ) = _i=0^ dfracδ^i+2(i+2)A^i\n\nwhere A is a square matrix of order n and δ  0.\n\nInput\n\nA      – coefficients matrix\nδ      – step size\nalg    – (optional, default: BaseExp) the method used to take the matrix              exponential of the coefficient matrix; see the documentation of              _exp for available options\nisinv  – (optional, default: false) if true, assume that the coefficients             matrix is invertible and compute A^-1\nΦ      – (optional, default: nothing) optionally pass the matrix exponential e^Aδ\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nIf A is invertible, Φ₂ can be computed as\n\nΦ₂(A δ) = A^-2(e^δA - I_n - δA)\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP_3n = exp beginpmatrix\nAδ  δI_n  0 \n0  0  δI_n \n0  0  0\nendpmatrix\n\nIt can be shown that\n\nexp(P_3n) = beginpmatrix\nΦ(A δ)  Φ₁(A δ)  Φ₂(A δ) \n0  I_n      δI_n \n0  0      I_n\nendpmatrix\n\nwhere Φ(A δ) = e^Aδ. In particular, Φ₂ = P_{3n}[1:n, (2*n+1):3*n]. This method can be found in Frehse et al. [FLD+11].\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Exponentiation.AbstractExpAlg","page":"Discretization","title":"ReachabilityAnalysis.Exponentiation.AbstractExpAlg","text":"AbstractExpAlg\n\nAbstract supertype for all exponentiation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.Exponentiation.BaseExpAlg","page":"Discretization","title":"ReachabilityAnalysis.Exponentiation.BaseExpAlg","text":"BaseExpAlg <: AbstractExpAlg\n\nMatrix exponential using the scaling-and-squaring algorithm implemented in Julia Base.\n\nNotes\n\nThe alias for this algorithm is :base.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.Exponentiation.LazyExpAlg","page":"Discretization","title":"ReachabilityAnalysis.Exponentiation.LazyExpAlg","text":"LazyExpAlg <: AbstractExpAlg\n\nMatrix exponential computed in a lazy fashion.\n\nFields\n\nm   – (optional, default: 30) size of the Krylov subspace\ntol – (optional, default: 1e-10) tolerance\n\nNotes\n\nThe aliases for this algorithm are :lazy and :krylov.\n\nThe operations are defined in the package LazySets.jl (SparseMatrixExp).\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.Exponentiation.IntervalExpAlg","page":"Discretization","title":"ReachabilityAnalysis.Exponentiation.IntervalExpAlg","text":"IntervalExpAlg <: AbstractExpAlg\n\nMatrix exponential using an interval enclosure of the Taylor series remainder.\n\nFields\n\norder – order of the Taylor series expansion of the matrix exponential\n\nNotes\n\nThe aliases for this algorithm are :interval and :taylor.\n\nThis algorithm allows to overapproximate exp(Aδ) with an interval matrix. It also accepts an interval matrix A as input.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.Exponentiation.PadeExpAlg","page":"Discretization","title":"ReachabilityAnalysis.Exponentiation.PadeExpAlg","text":"PadeExpAlg <: AbstractExpAlg\n\nMatrix exponential for sparse matrices using Pade approximants.\n\nNotes\n\nThe alias for this algorithm is :pade.\n\nThis algorithm requires to load the package Expokit.jl.\n\n\n\n\n\n","category":"type"},{"location":"generated_examples/LotkaVolterra/#Lotka-Volterra","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"note: Overview\nSystem type: Polynomial continuous system\nState dimension: 2\nApplication domain: Biological systems","category":"section"},{"location":"generated_examples/LotkaVolterra/#Model-description","page":"Lotka-Volterra","title":"Model description","text":"The 2-dimensional Lotka-Volterra system depicts the population change of a class of predators and a class of preys. The growth rate of the prey population x over time is governed by the differential equation\n\n    dotx = α x - β x y\n\nwhere α, β are constant parameters and y is the population of predators. We can see that the number of prey grows exponentially without predation.\n\nThe population growth of predators is governed by the differential equation\n\n    doty = δ x y - γ y\n\nwhere γ δ are constant parameters.\n\nWe set these parameters to α = 15, β = 1, γ = 3, and δ = 1.\n\nusing ReachabilityAnalysis\n\n@taylorize function lotkavolterra!(du, u, p, t)\n    local α, β, γ, δ = 1.5, 1.0, 3.0, 1.0\n\n    x, y = u\n    xy = x * y\n    du[1] = α * x - β * xy\n    du[2] = δ * xy - γ * y\n    return du\nend","category":"section"},{"location":"generated_examples/LotkaVolterra/#Specification","page":"Lotka-Volterra","title":"Specification","text":"We consider the initial set x  48 52 y  18 22.\n\nX0 = Hyperrectangle(; low=[4.8, 1.8], high=[5.2, 2.2])\nprob = @ivp(x' = lotkavolterra!(x), dim:2, x(0) ∈ X0);\nnothing #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Analysis","page":"Lotka-Volterra","title":"Analysis","text":"sol = solve(prob; T=8.0, alg=TMJets())\nsolz = overapproximate(sol, Zonotope);\nnothing #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Results","page":"Lotka-Volterra","title":"Results","text":"using Plots\nimport DisplayAs  #hide\n\nfig = plot(solz; vars=(1, 2), alpha=0.3, lw=0.0, xlab=\"x\", ylab=\"y\",\n           lab=\"Flowpipe\", legend=:bottomright)\nplot!(fig, X0; label=\"X(0)\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Adding-parameter-variation","page":"Lotka-Volterra","title":"Adding parameter variation","text":"In this setting, we consider all parameters as uncertain model constants. In addition, we add another term ϵ to the first differential equation.\n\n@taylorize function lotkavolterra_parametric!(du, u, p, t)\n    x, y, αp, βp, γp, δp, ϵp = u\n    xy = x * y\n    du[1] = αp * x - βp * xy - ϵp * x^2\n    du[2] = δp * xy - γp * y\n\n    # encode uncertain parameters\n    du[3] = zero(αp)\n    du[4] = zero(βp)\n    du[5] = zero(γp)\n    du[6] = zero(δp)\n    du[7] = zero(ϵp)\n    return du\nend","category":"section"},{"location":"generated_examples/LotkaVolterra/#Specification-2","page":"Lotka-Volterra","title":"Specification","text":"p_int = (0.99 .. 1.01) × (0.99 .. 1.01) × (2.99 .. 3.01) × (0.99 .. 1.01) × (0.099 .. 0.101)\nU0 = cartesian_product(Singleton([1.0, 1.0]), convert(Hyperrectangle, p_int))\nprob = @ivp(u' = lotkavolterra_parametric!(u), dim:7, u(0) ∈ U0);\nnothing #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Analysis-2","page":"Lotka-Volterra","title":"Analysis","text":"sol = solve(prob; tspan=(0.0, 10.0))\nsolz = overapproximate(sol, Zonotope);\nnothing #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Results-2","page":"Lotka-Volterra","title":"Results","text":"fig = plot(solz; vars=(1, 2), lw=0.3, title=\"Uncertain parameters\",\n           lab=\"abstol = 1e-15\", xlab=\"x\", ylab=\"y\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Uncertain-initial-condition-(u0)","page":"Lotka-Volterra","title":"Uncertain initial condition (u0)","text":"Now we consider an initial box around u0","category":"section"},{"location":"generated_examples/LotkaVolterra/#ϵ-0.05","page":"Lotka-Volterra","title":"ϵ = 005","text":"In this setting, we consider the uncertain parameter ϵ with radius 005.","category":"section"},{"location":"generated_examples/LotkaVolterra/#Specification-3","page":"Lotka-Volterra","title":"Specification","text":"□(ϵ) = BallInf([1.0, 1.0], ϵ)\n\nU0 = cartesian_product(□(0.05), convert(Hyperrectangle, p_int))\nprob = @ivp(u' = lotkavolterra_parametric!(u), dim:7, u(0) ∈ U0);\nnothing #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Analysis-3","page":"Lotka-Volterra","title":"Analysis","text":"sol = solve(prob; T=10.0, alg=TMJets(; abstol=1e-10))\nsolz = overapproximate(sol, Zonotope);\nnothing #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Results-3","page":"Lotka-Volterra","title":"Results","text":"fig = plot(solz; vars=(1, 2), color=:orange, lw=0.3, lab=\"ϵ = 0.05\",\n           title=\"Uncertain u0 and uncertain parameters\", xlab=\"x\", ylab=\"y\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#ϵ-0.01","page":"Lotka-Volterra","title":"ϵ = 001","text":"In this setting, we consider the uncertain parameter ϵ with radius 001.","category":"section"},{"location":"generated_examples/LotkaVolterra/#Specification-4","page":"Lotka-Volterra","title":"Specification","text":"U0 = cartesian_product(□(0.01), convert(Hyperrectangle, p_int))\nprob = @ivp(u' = lotkavolterra_parametric!(u), dim:7, u(0) ∈ U0);\nnothing #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Analysis-4","page":"Lotka-Volterra","title":"Analysis","text":"sol = solve(prob; T=10.0, alg=TMJets(; abstol=1e-10))\nsolz = overapproximate(sol, Zonotope);\nnothing #hide","category":"section"},{"location":"generated_examples/LotkaVolterra/#Results-4","page":"Lotka-Volterra","title":"Results","text":"plot!(solz; vars=(1, 2), color=:blue, lw=0.3, lab=\"ϵ = 0.01\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"tutorials/set_representations/distances/#Hausdorff-distance","page":"Metric notions","title":"Hausdorff distance","text":"The notion of Hausdorff distance can be used to measure the distance between sets. It constitutes a practical theoretical tool to quantify the quality of an approximation.\n\n  d_H(mathcalX mathcalY) = max left( sup_x  mathcalXinf_y  mathcalY Vert x - y Vert sup_y  mathcalYinf_x  mathcalX Vert x - y Vert right)","category":"section"},{"location":"man/systems/#Systems","page":"Systems","title":"Systems","text":"This section of the manual describes the systems types that are used in this library.\n\nMathematicalSystems.jl provides some convenience types and methods to work with mathematical systems models. Every system inherits from AbstractSystem.","category":"section"},{"location":"man/systems/#Linear-systems","page":"Systems","title":"Linear systems","text":"Two commonly used types of systems are discrete and continuous systems.\n\nDiscrete systems. A discrete system consists of a matrix representing the system dynamics, a set of initial states, a set of nondeterministic inputs, and a discretization step δ.\n\nContinuous systems.  A continuous system consists of a matrix representing the system dynamics, a set of initial states, and a set of nondeterministic inputs.","category":"section"},{"location":"man/systems/#Nondeterministic-inputs","page":"Systems","title":"Nondeterministic inputs","text":"The above systems may contain nondeterministic inputs, which are wrapped in special types. Every nondeterministic input representation inherits from NonDeterministicInput.\n\nThe inputs are closely related to a DiscreteSystem in the sense that for each discrete time step the input set may change. We support iteration through the inputs over time.","category":"section"},{"location":"man/systems/#Constant-nondeterministic-inputs","page":"Systems","title":"Constant nondeterministic inputs","text":"Constant nondeterministic inputs are chosen from a set of values that does not change over time. Note that, while the set is constant, the inputs themselves vary over time.","category":"section"},{"location":"man/systems/#Time-varying-nondeterministic-inputs","page":"Systems","title":"Time-varying nondeterministic inputs","text":"Time-varying nondeterministic inputs are chosen from a set of values that changes over time (with each time step).","category":"section"},{"location":"man/systems/#Second-order-systems","page":"Systems","title":"Second order systems","text":"A second order system is one of the form\n\n    Mx(t) + Cx(t) + Kx(t) = f(t)\n\nwhere x(t)  mathbbR^n is the state vector and f  mathbbR to mathbbR^n is the forcing term. Here M, C and K are often called the mass matrix, viscosity matrix and stiffness matrix respectively. These names are adopted from physical applications, particularly from structural mechanics. Assuming that the matrix M is invertible, we can transform the second order system to a first order system introducing auxiliary variables, x̃(t) = x(t)v(t)^T, where v(t) = x(t) is the vector of velocities. Then,\n\n    x̃(t) = Ax̃(t) + Bf(t)\n\nwhere\n\nA = beginpmatrix\n0  I  -M^-1K  -M^-1C\nendpmatrixqquad B = beginpmatrix\n0   M^-1\nendpmatrix\n\nSee the SecondOrder documentation in MathematicalSystems.jl for additional details in second order ODEs types.\n\nnote: Note\nA similar relation can be obtained using the alternative convention v(t)x(t)^T. Use derivatives_first=true in the normalize function to swap between these conventions (it is set to false by default).","category":"section"},{"location":"man/systems/#Normalization","page":"Systems","title":"Normalization","text":"","category":"section"},{"location":"man/systems/#Homogenization","page":"Systems","title":"Homogenization","text":"","category":"section"},{"location":"man/systems/#Nonlinear-systems","page":"Systems","title":"Nonlinear systems","text":"","category":"section"},{"location":"man/systems/#Parametric-systems","page":"Systems","title":"Parametric systems","text":"","category":"section"},{"location":"lib/operations/#Further-set-operations","page":"Further set operations","title":"Further set operations","text":"","category":"section"},{"location":"lib/operations/#Convexification","page":"Further set operations","title":"Convexification","text":"","category":"section"},{"location":"lib/operations/#Quality-measures","page":"Further set operations","title":"Quality measures","text":"","category":"section"},{"location":"lib/operations/#ReachabilityAnalysis.convexify","page":"Further set operations","title":"ReachabilityAnalysis.convexify","text":"convexify(fp::Flowpipe{N, <:AbstractLazyReachSet}) where {N}\n\nReturn a reach-set representing the convex hull array of the flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nA reach-set that contains the convex hull array, ConvexHullArray, of the given flowpipe.\n\nNotes\n\nThe time span of this reach-set is the same as the time-span of the flowpipe.\n\nThis function allocates an array to store the sets of the flowpipe.\n\n\n\n\n\nconvexify(fp::AbstractVector{<:AbstractLazyReachSet{N}}) where {N}\n\nReturn a reach-set representing the convex hull array of the array of the array of reach-sets.\n\nInput\n\nfp – array of reach-sets\n\nOutput\n\nA reach-set that contains the convex hull array, ConvexHullArray, of the given flowpipe.\n\nNotes\n\nThe time span of this reach-set corresponds to the minimum (resp. maximum) of the time span of each reach-set in fp.\n\nThis function allocates an array to store the sets of the flowpipe.\n\nThe function doesn't assume that the reach-sets are time ordered.\n\n\n\n\n\n","category":"function"},{"location":"lib/operations/#ReachabilityAnalysis.Overapproximate.relative_error","page":"Further set operations","title":"ReachabilityAnalysis.Overapproximate.relative_error","text":"relative_error(x, x_ref)\n\nCompute the relative error between interval x and a reference interval xref.\n\nInput\n\nx    – interval\nxref – reference interval\n\nOutput\n\nAn interval representing the relative error (in percentage) of x with respect to the reference interval xref.\n\nAlgorithm\n\nIf x = x_L x_Handxref = [xref_L, xref_H], the output is the intervaly = 100 * [y_L, y_H]computed asy_L = -(x_L - xref_L) / denandy_H = (x_H - xref_H) / den, whereden = xref_H - xref_L`.\n\nThis function measures the relative error between an interval x and a reference interval x_ref accounting for it the lower and the upper range bounds separately (see Althoff et al. [AGK18], Eq. (20)).\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear_methods/dense_time/#Set-propagation-in-dense-time","page":"Dense time reachability","title":"Set propagation in dense time","text":"In this section we transition from the discrete time problem considered before to a problem in which time is assumed to be a continuously varying quantity. Thus, our next \"toy\" problem is the system of ordinary differential equations that describe a simple, undamped, harmonic oscillator:\n\nbeginaligned\nx(t) = y(t) \ny(t) = -x(t)\nendaligned\nqquad textrmsubject to  (x(0) y(0))  X_0 = 08 12 times 08 12  mathbbR^2\n\nWe are interested in solving this problem for all t  0 T with T = 2π.\n\nThe problem studied in the previous section is the \"discrete analogue\" of the purely continuous system of differential equations defined above.\n\nThe matrix M(ω t) describes the solution of a mathematical model called simple harmonic oscillator with natural frequency ω = 1, and the analytic solution is\n\nbeginaligned\nx(t) = x_0 cos t + y_0 sin t \ny(t) = -x_0 sin t + y_0 cos t\nendaligned\n\nObserve that (x(t) y(t))^T is just the matrix M(t) applied to the initial state (x_0 y_0)^T.\n\nDefine the invariant G (x y)  mathbbR^2 x  13 .\n\nusing ReachabilityAnalysis, Plots\nusing ReachabilityAnalysis: center\n\n\nimport Random # hide\nRandom.seed!(1117) # hide\n\n# initial states\nX0 = BallInf(ones(2), 0.2)\n\n# rotation matrix\nM(θ) = [cos(θ) sin(θ); -sin(θ) cos(θ)]\n\n# analytic solution to visualize the solution at intermediate times\nfunction analytic_sol(u0, tt)  # hide\n    sol = [M(t) * u0 for t in tt]  # hide\n    xcoords = getindex.(sol, 1)  # hide\n    ycoords = getindex.(sol, 2)  # hide\n    return xcoords, ycoords  # hide\nend  # hide\n\nsamples = sample(X0, 200, include_vertices=true)\ntt = range(0, 2pi/20, length=100)\n\nF = [ReachSet(linear_map(M(ti), X0), ti) for ti in range(0, 2pi, step=2pi/20)]\n\nfig = plot(F[1], vars=(1, 2), lab=\"X0\", c=:blue)\nplot!(fig, F[2], vars=(1, 2), lab=\"Φ * X0\", c=:orange)\n[plot!(fig, xcoords, ycoords, seriestype=:path, lab=\"\", c=:magenta, ratio=1.) for (xcoords, ycoords) in analytic_sol.(samples, Ref(tt))]\nfig\n\nimport DisplayAs  # hide\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide","category":"section"},{"location":"tutorials/linear_methods/dense_time/#Conservative-time-discretization","page":"Dense time reachability","title":"Conservative time discretization","text":"fig = plot()\n\nplot!(fig, convexify(F[1:2]), vars=(1, 2), ls=:dash, lw=3.0, c=:green, lab=\"CH(X0, Φ*X0)\")\nplot!(fig, F[1], vars=(1, 2), lab=\"X0\", c=:blue)\nplot!(fig, F[2], vars=(1, 2), lab=\"Φ*X0\", c=:orange)\n[plot!(fig, xcoords, ycoords, seriestype=:path, lab=\"\", c=:magenta, ratio=1.) for (xcoords, ycoords) in analytic_sol.(samples, Ref(tt))]\n\nfig\n\nimport DisplayAs  # hide\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nxlims!(1.0, 1.5)\nylims!(0.8, 1.2)\n\n<div style=\"background: ghostwhite;\n            font-size: 16px;\n            padding: 10px;\n            border: 1px solid lightgray;\n            margin: 10px;\n            font-family: helvetica;\">\n\n<b>Proposition 1.</b> Conservative time discretization for linear homogeneous systems\n[LeGuernicG09](@cite).\n\nLet ``x' = Ax`` with initial states ``x(0) ∈ X_0``. Then the convex set\n\n````\nΩ_0 := CH(X_0, Φ X_0 \\oplus B_r),\n````\n\nwhere ``Φ = e^{A δ}`` is the state transition matrix given a step size\n``δ > 0`` and ``B_r`` is the infinity norm ball centered at the origin and\nradius ``r = (e^{δ \\Vert A \\Vert } - 1 - δ \\Vert A \\Vert)\\Vert X_0\\Vert``,\nsatisfies ``R^e([0, δ], X_0) ⊆ Ω_0``, where\n``R^e([0, δ], X_0)`` are the exact reachable states between time ``0`` and ``δ``.\n\nMoreover, ``Ω_0`` converges to the true reachable states when the step size\n``δ \\to 0`` (in Hausdorff distance).\n\n</div>\n\nAlgorithms implementing conservative time discretization can be used from the discretize(ivp::IVP, δ, alg::ReachabilityAnalysis.DiscretizationModule.AbstractApproximationModel) function. Set-based conservative discretization of a continuous-time initial value problem into a discrete-time problem. This function receives three inputs: the initial value problem (ivp) for a linear ODE in canonical form, (e.g. the system returned by normalize); the step-size (δ), and the algorithm (alg) used to compute the approximation model. Do subtypes(ReachabilityAnalysis.DiscretizationModule.AbstractApproximationModel) to see the available approximation models.\n\nThe output of a discretization is a new initial value problem of a discrete system. Different approximation algorithms and their respective options are described in the docstring of each method, e.g. Forward.\n\nInitial-value problems considered in this function are of the form\n\nx = Ax(t) + u(t)qquad x(0)  mathcalX_0qquad (1)\n\nand where u(t)  U(k) add where U(k)_k is a sequence of sets of non-deterministic inputs and mathcalX_0 is the set of initial states. Recall that this initial-value problem is called homogeneous whenever U is the empty set. Other problems, e.g. x = Ax(t) + Bu(t) can be brought to the canonical form with the function normalize.\n\nThe initial value problem returned by this function consists of a set discretized (also called bloated) initial states Ω₀, together with the coefficient matrix Φ = e^Aδ and a transformed sequence of inputs if U is non-empty.\n\nTwo main variations of this algorithm are considered: dense time case and discrete time case.\n\nIn the dense time case, the transformation is such that the trajectories\n\nof the given continuous system are included in the computed flowpipe of the discretized system. More precisely, given a step size δ and the system (1) conservative set-based discretization function computes a set, Ω₀, that guarantees to contain all the trajectories of (1) starting at any x(0)  mathcalX_0 and for any input function that satisfies u(t)  U(1), for any t  0 δ. If U is time-varying, this function also discretizes the inputs for k  0.\n\nIn the discrete time case, there is no bloating of the initial states and the\n\ninput is assumed to remain constant between sampled times. Use the algorithm NoBloating() for this setting. If U is time-varying, this function also discretizes the inputs for k  0.\n\nThere are algorithms to obatin such transformations, called approximation models in the technical literature. For references to the original papers, see the docstring of each concrete subtype of AbstractApproximationModel.","category":"section"},{"location":"tutorials/taylor_methods/gotchas/#Some-common-gotchas","page":"Common gotchas","title":"Some common gotchas","text":"In this section we comment on some performance aspects about the solution of initial-value problems for nonlinear systems using Taylor methods.","category":"section"},{"location":"tutorials/taylor_methods/gotchas/#What-is-@taylorize?-Do-I-need-it?","page":"Common gotchas","title":"What is @taylorize? Do I need it?","text":"@taylorize is a macro which parses the functions containing the ODEs to be integrated, allowing to speed up repeated evaluations. The macro is defined in TaylorIntegration.jl, see @taylorize's documentation in TaylorIntegration.jl for further details. Since it is an optimization, it is not mandatory, though it is recommended as it helps to reduce the number of allocations and as a consequence it usually gives a performance boost.","category":"section"},{"location":"tutorials/taylor_methods/gotchas/#How-can-I-get-the-most-out-of-@taylorize?","page":"Common gotchas","title":"How can I get the most out of @taylorize?","text":"The main advice is to refactor expressions involving several terms into smaller expressions which involve at most two arguments, making appropriate use of parentheses if needed. For further limitations and advice see this section of TaylorInegrations.jl's documentation.\n\nExample. Here is an example that uses some of the above recommendations. Start with f! defined below:\n\n@taylorize function f!(du, u, params, t)\n    local a = 0.3\n    x, y, z = u[1], u[2], u[3]\n\n    du[1] = -x * y/(1 + x)\n    du[2] = x * y/(1 + x) - a * y\n    du[3] = a * y * y\n    return du\nend\n\nObserve that the terms x * y can be factored out into a new auxiliary variable aux, and all intermediate operations can be arranged to only involve two arguments, using parentheses:\n\n@taylorize function g!(du, u, params, t)\n    local a = 0.3\n    x, y, z = u[1], u[2], u[3]\n\n    num = x * y\n    den = 1 + x\n    aux = num/den\n    du[1] = -aux\n    du[2] = aux - a * (y * y)\n    du[3] = a * (y * y)\n    return du\nend","category":"section"},{"location":"tutorials/taylor_methods/gotchas/#How-are-solutions-obtained-with-Taylor-models-methods-plotted?","page":"Common gotchas","title":"How are solutions obtained with Taylor models methods plotted?","text":"Flowpipes computed using algorithm TMJets (or its variations), use Taylor model reach-set representations (TaylorModelReachSet), which define an implicit set in time and in space. Since exact visualization of such objects is difficult (and often unnecessary), we resort to an outer approximation with simpler sets. Either for plotting or performing set-based operations, we can overapproximate a TaylorModelReachSet with other set representations – usually, convex sets such as boxes or zonotopes–. The command overapproximate(sol, Zonotope) applies overapproximate(Ri, Zonotope) for each reach-set Ri in the solution sol.\n\nBy default, when plotting the solution obtained with such solvers, the zonotopic overapproximation of the flowpipe is used, with a single zonotope per Taylor model reach-set. Such approximation, while it is generally coarse, is often sufficient for visualization purposes.","category":"section"},{"location":"tutorials/taylor_methods/gotchas/#Equations-with-constant-terms-(BoundsError)","page":"Common gotchas","title":"Equations with constant terms (BoundsError)","text":"Equations that involve constant terms may give a BoundsError. This is a known bug (cf. issue #179) and it is related to cases in which the update rule for the right-hand side does not have the expected coefficient type. The current solution is to change terms like du[1] = 1.0 into du[1] = 1.0 + zero(u[1]), i.e. let Julia's promotion mechanism take care by adding the given numeric constant with the zero element of the type of u.\n\nExample. Consider the function f!:\n\n@taylorize function f!(du, u, p, t)\n    du[1] = u[3]^3 - u[2] + u[4]\n    du[2] = u[3]\n    du[3] = 2.0\n    du[4] = u[4]\n    return du\nend\n\nIntegrating this function will likely fail with a BoundsError. However, we can re-write it in this way:\n\n@taylorize function f!(du, u, p, t)\n    local two = 2.0 + zero(u[1])\n    du[1] = u[3]^3 - u[2] + u[4]\n    du[2] = u[3]\n    du[3] = two\n    du[4] = u[4]\n    return du\nend","category":"section"},{"location":"about/#About","page":"How to contribute","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"section"},{"location":"about/#Contributing","page":"How to contribute","title":"Contributing","text":"If you like this package, consider contributing! We welcome bug reports, examples that can be added to the documentation, or new feature proposals.\n\nBelow we list some conventions that we follow when contributing to this package. For specific guidelines on documentation see the JuliaReach Developer's Documentation.","category":"section"},{"location":"about/#Branches","page":"How to contribute","title":"Branches","text":"Each pull request (PR) should be pushed in a new branch with the name of the author followed by a descriptive name, e.g. mforets/my_feature. If the branch is associated to a previous discussion in an issue, we use the name of the issue for easier lookup, e.g. mforets/7.","category":"section"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)","page":"How to contribute","title":"Unit testing and continuous integration (CI)","text":"This project is synchronized with GitHub Actions such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to make all unit tests pass.\n\nTo run the unit tests locally, you can do:\n\njulia> using Pkg\n\njulia> Pkg.test(\"ReachabilityAnalysis\")\n\nWe also advise adding new unit tests when adding new features to ensure long-term support of your contributions.","category":"section"},{"location":"about/#Contributing-to-the-documentation","page":"How to contribute","title":"Contributing to the documentation","text":"This documentation is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. To build the documentation, run make.jl:\n\n$ julia --color=yes docs/make.jl","category":"section"},{"location":"man/benchmarks/repeatability/#Repeatability-evaluations","page":"Repeatability evaluations","title":"Repeatability evaluations","text":"Traditionally, re-creation of computational results in research work is a challenging task because details of the implementation are unavoidably absent in the paper. Some authors post their code and data to their websites, but there is little formal incentive to do so and no easy way to determine whether others can actually use the result. As a consequence, computational results often become non reproducible – even by the research group which originally produced them – after just a few years.\n\nMore recently, scientific conferences encourage and sometimes require that authors improve the reproducibility of their computational results by providing suitable reproducibility evaluation (RE) packages. Such RE are self-contained codes that can be used to run and reproduce the results from the paper in a host machine. Fortunately, the tools available for the Julia language are very convenenient to prepare and distribute RE packages. The following RE packages are available:\n\nARCH2020 NLN RE – Repeatability Evaluation package for the ARCH2020 Nonlinear Continuous and Hybrid Systems Competition.\nARCH2020 AFF RE – Repeatability Evaluation package for the ARCH2020 Linear and Hybrid Systems Competition.\nHSCC2019 RE – Repeatability Evaluation (RE) package for the paper JuliaReach: a Toolbox for Set-Based Reachability published at the HSCC'2019 conference.\nARCH2019 RE – Repeatability Evaluation package for the ARCH2019 Competition.\nARCH2018 RE – Repeatability Evaluation package for the ARCH2018 Competition.\n\nFor installation instructions, see the README file in each package. We have examples using virtual machines, and also using Docker containers for RE packages. The advantage of using a Docker container is that downloading the necessary requirements (including Julia itself) is an automated process.","category":"section"},{"location":"man/algorithms/HLBS25/#Reachability-of-parametric-linear-systems-(HLBS25)","page":"HLBS25","title":"Reachability of parametric linear systems (HLBS25)","text":"","category":"section"},{"location":"man/algorithms/HLBS25/#Method","page":"HLBS25","title":"Method","text":"This method computes the reachability analysis of linear systems with parametric uncertainty. The method is based on matrix zonotopes to represent the uncertain parameters of the system.","category":"section"},{"location":"generated_examples/SEIR/#SEIR","page":"Epidemic (SEIR) model","title":"SEIR","text":"note: Overview\nSystem type: Polynomial continuous system\nState dimension: 4\nApplication domain: Epidemiology","category":"section"},{"location":"generated_examples/SEIR/#Model-description","page":"Epidemic (SEIR) model","title":"Model description","text":"The SEIR model is an compartmental model. These try to predict things such as how a disease spreads, or the total number infected, or the duration of an epidemic, and to estimate various epidemiological parameters such as the reproductive number. The dynamics are described as follows:\n\nbeginaligned\n    dotS = β I S \n    dotE = β I S - α E \n    dotI = -γ I - α E \n    dotR = γ I\nendaligned\n\nwhere S is the stock of susceptible population, E is the stock of exposed population, I is the stock of infected, R is the stock of removed population (either by death or recovery), with S + E + I + R = N.\n\nusing ReachabilityAnalysis\n\n@taylorize function seir!(dx, x, p, t)\n    S, E, I, R, α, β, γ = x\n\n    βIS = β * (I * S)\n    αE = α * E\n    γI = γ * I\n\n    dx[1] = -βIS      # dS\n    dx[2] = βIS - αE  # dE\n    dx[3] = -γI + αE  # dI\n    dx[4] = γI        # dR\n\n    # uncertain parameters\n    dx[5] = zero(α)\n    dx[6] = zero(β)\n    dx[7] = zero(γ)\n    return dx\nend","category":"section"},{"location":"generated_examples/SEIR/#Specification","page":"Epidemic (SEIR) model","title":"Specification","text":"The initial condition is E₀ = 1e-4, x₀ = 1-E₀ E₀ 0 0, α = 02  001, β = 10  00, γ = 05  001, and p = α β γ. The time horizon is 200.\n\nE₀ = 1e-4\nx₀ = [1 - E₀, E₀, 0, 0]\nα = 0.2 ± 0.01\nβ = 1.0 ± 0.0\nγ = 0.5 ± 0.01\np = [α, β, γ]\nX0 = IntervalBox(vcat(x₀, p));\nprob = @ivp(x' = seir!(x), dim:7, x(0) ∈ X0);\nnothing #hide","category":"section"},{"location":"generated_examples/SEIR/#Analysis","page":"Epidemic (SEIR) model","title":"Analysis","text":"sol = solve(prob; T=200.0, alg=TMJets21a(; orderT=7, orderQ=1))\nsolz = overapproximate(sol, Zonotope);\nnothing #hide","category":"section"},{"location":"generated_examples/SEIR/#Results","page":"Epidemic (SEIR) model","title":"Results","text":"using Plots\nimport DisplayAs  #hide\n\nfig = plot(; legend=:outerright)\nplot!(fig, solz; vars=(0, 1), color=:blue, lw=0.0, lab=\"S\")\nplot!(fig, solz; vars=(0, 2), color=:green, lw=0.0, lab=\"E\")\nplot!(fig, solz; vars=(0, 3), color=:red, lw=0.0, lab=\"I\")\nplot!(fig, solz; vars=(0, 4), color=:grey, lw=0.0, lab=\"R\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"man/algorithms/LGG09/#Support-function-based-method-(LGG09)","page":"LGG09","title":"Support-function based method (LGG09)","text":"","category":"section"},{"location":"man/algorithms/LGG09/#Method","page":"LGG09","title":"Method","text":"In the following subsections we outline the method of Le Guernic and Girard [LG09] to solve linear set-based recurrences using support functions, first the homogeneous case and then the inhomogeneous case without wrapping effect. We also discuss the special case of real eigenvalues.","category":"section"},{"location":"man/algorithms/LGG09/#Homogeneous-case","page":"LGG09","title":"Homogeneous case","text":"Consider the set-based recurrence\n\nX_k+1 = Φ X_kqquad 0  k  N\n\nwhere Φ  mathbbR^ntimes n and X_0  mathbbR^n are given. By unrwapping the recurrence, X_k = Φ^k X_0 for all k  0. Let d  mathbbR^n be a given template direction. Using the property of support functions ρ(d A X) = ρ(A^T d X) for any matrix A and set X, we have that\n\nρ(d X_k) = ρ(d Φ^k X_0) = ρ((Φ^T)^k d X_0)\n\nIn this way we are able to reason with the sequence X_0 X_1 X_2  X_N by evaluating the support function of the initial set X_0 along the directions d Φ^T d (Φ^T)^2 d  (Φ^T)^N d.","category":"section"},{"location":"man/algorithms/LGG09/#Inhomogeneous-case","page":"LGG09","title":"Inhomogeneous case","text":"The inhomogeneous case generalizes the previous case by taking, at each step, the Minkowski sum with an element from the sequence V_0 V_1 V_2  V_N:\n\nX_k+1 = Φ X_k oplus V_kqquad 0  k  N\n\nLet us write such recurrence in the unrapped form,\n\nbeginaligned\nquad X_1 = Φ X_0 oplus V_0 1mm\nquad X_2 = Φ X_1 oplus V_1 = Φ^2 X_0 oplus Φ V_0 oplus V_1 1mm\nquad X_3 = Φ X_2 oplus V_2 = Φ^3 X_0 oplus Φ^2 V_0 oplus Φ V_1  oplus V_2 1mm\nquad vdots 1mm\nquad X_k = Φ^k X_0 oplus left( bigoplus_i=0^k-1 Φ^k-i-1 V_i right)\nendaligned\n\nwhere the big Minkowski sum is just an abbreviation for Φ^k-1 V_0 oplus Φ^k-2 V_1 oplus Φ^k-3 V_2 oplus  oplus Φ V_k-2 oplus V_k-1.\n\nLet d  mathbbR^n be a given template direction. Using the additive property of support functions, ρ(d X oplus Y) = ρ(d X) + ρ(d Y) for any sets X and Y, we have that\n\nbeginaligned\nquad ρ(d X_1) = ρ(Φ^T d X_0) + ρ(d V_0) 1mm\nquad ρ(d X_2) = ρ((Φ^T)^2 d X_0) + ρ(Φ^T d V_0) + ρ(d V_1) 1mm\nquad ρ(d X_3) = ρ((Φ^T)^3 d X_0) + ρ((Φ^T)^2 d V_0) + ρ(Φ^T d V_1) + ρ(d V_2) 1mm\nquad vdots 1mm\nquad ρ(d X_k) = ρ((Φ^T)^k d X_0) + sum_i=0^k-1 ρ( (Φ^T)^k-i-1 d  V_i)\nendaligned\n\nIn a similar fashion to the homogeneous case, the method allows to efficiently reason about the the sequence X_0 X_1 X_2  X_N by evaluating the support function of the initial set X_0 and the input sets V_k_k along the directions d Φ^T d (Φ^T)^2 d  (Φ^T)^N d. Implementation-wise, we update two sequences, one that accounts for the homogeneous term, and another sequence that accounts for the effect of the accumulated inputs.","category":"section"},{"location":"man/algorithms/LGG09/#Implementation-details","page":"LGG09","title":"Implementation details","text":"The reach-set representation used is a TemplateReachSet, which stores the directions used (vector of vectors) and the support function evaluated at each direction (matrix, see below). The set representation, set(R::TemplateReachSet), is either a polyhedron in constraint form (HPolyhedron), or a polytope (HPolytope) if the directions are bounding, i.e. the template directions define a bounded set.\n\nThe computed support function values can accessed directly through the field sf::SN of each template reach-set. Here sf is an array view of type ::Matrix{N}(undef, length(dirs), NSTEPS): each row corresponds to one of the template directions and each column corresponds to a fixed iteration index k  0.\n\nIf you use directions from the canonical basis of mathbbR^n, it is recommended to define LazySets.Arrays.SingleEntryVector or \"one-hot\" arrays as they are commonly called, because there are methods that dispatch on such type of arrays efficiently.","category":"section"},{"location":"man/algorithms/LGG09/#Parallel-formulation","page":"LGG09","title":"Parallel formulation","text":"The support functions of the sequence X_k_k along different directions can be computed in parallel. Indeed, if d_1 and d_2 are two given template directions, two different processes can independently compute ρ(d_1 X_k) and ρ(d_2 X_k) for all k = 0 1  N using the methods described above. Once both computations have finished, we can store the resulting support functions in the same array. Use the flag threaded=true to use this method.\n\nImplementation-wise the function _reach_homog_dir_LGG09! spawns different threads which populate the matrix ρℓ::Matrix{N}(undef, length(dirs), NSTEPS) with the computed values. Hence each thread computes a subset of distinct rows of ρℓ.","category":"section"},{"location":"man/algorithms/LGG09/#Real-eigenvalues","page":"LGG09","title":"Real eigenvalues","text":"If the spectrum of the state matrix only has real eigenvalues, the sequence of support functions can be computed efficiently if we work with a template consisting of eigenvectors of Φ^T. This idea is described in Le Guernic and Girard [LG09] and we recall it here for convenience.\n\nThe method stems from the fact that if (λ d) is an eigenvalue-eigenvector pair of the matrix Φ^T, with λ  mathbbR, then Φ^T d = λ d, and if we apply Φ^T on both sides of this identity, we get (Φ^T)^2 d = Φ^T (Φ^T d) = Φ^T(λ d) = λ^2 d. In more generality, it holds that (Φ^T)^k d  = λ^k d for all k  1. Applying this relation to the support function recurrence described above, we get for the general inhomogeneous and possibly time-varying inputs case:\n\nρ(d X_k) = ρ(λ^k d X_0) + sum_i=0^k-1 ρ(λ^k-i-1 d V_i)\n\nTo further simplify this formula, we analyze different cases of λ. If λ = 0, then ρ(d X_k) = ρ(d V_k) for all k  1, so we focus on either λ being positive or negative. To further simplify the computation of ρ(d X_k), we can use the property ρ(λ d X) = λ ρ(d X) if λ  0. We now consider the cases λ  0 and λ  0.\n\nCase λ  0. Then λ^k  0 for all k  1, and\n\nρ(d X_k) = λ^k ρ(d X_0) +  sum_i=0^k-1 λ^k-i-1 ρ(d V_i)\n\nWe are left with evaluating the support function only at ρ(d X_0)  and ρ(d V_i) to construct the full sequence ρ(d X_k)_k. Moreover, if the V_i's are constant we can extract them from the right-hand side sum and use that\n\nsum_i=0^k-1 λ^k-i-1 = 1 + λ +  + λ^k-1 = dfrac1 - λ^k1 - λ\n\nCase λ  0. Since λ^k = (-1)^k (-λ)^k and λ  0, then λ^k is positive if k is even, otherwise it is negative. So we can write:\n\nρ(d X_k) = (-λ)^k ρ((-1)^k d X_0) + sum_i=0^k-1 (-λ)^k-i-1 ρ((-1)^k-i-1 d V_i)\n\nThe main difference between this case and the previous one is that now we have to evaluate support functions ρ(pm d X_0) and ρ(pm d V_i). Again, simplification takes place if the V_i's are constant and such special case is considered in the implementation.","category":"section"},{"location":"tutorials/linear_methods/introduction/#Linear-reachability-methods","page":"Introduction","title":"Linear reachability methods","text":"This section begins by introducing the notion of reachable set (reach-set). We show how to visualize and perform set operations with them. Then we introduce flowpipes as the union of reach-sets and illustrate with examples how to perform different visualization and algebraic operations with flowpipes. Then we consider a simple set-propagation problem that consists of a two-dimensional rotation.\n\nAfter those preliminary sections, we discuss the notion of conservative time discretization for systems of linear differential equations of the form\n\n    x(t) = Ax(t)qquad x(0)  X_0  mathbbR^n\n\nfor all times t  0 T. Linear systems with non-deterministic inputs is discussed in another section of this manual. We also consider an invariant specification: x(t)  X for all times.\n\nThe final part of this section introduces support function techniques and discusses the helicopter model application. For ease of exposition, this section only considers. We also show how to introduce state-space invariants, i.e. to impose","category":"section"},{"location":"tutorials/linear_methods/introduction/#Quickstart-guide","page":"Introduction","title":"Quickstart guide","text":"The user interface to solve initial-value problems is quite simple.\n\nusing ReachabilityAnalysis\n\n# initial-value problem specification\np = @ivp(x' = -x, x(0) ∈ Interval(1, 2))\n\n# flowpipe computation\nsol = solve(p, T=5)\n\nnothing # hide\n\nHere we have solved the differential equation\n\nx(t) = -x(t)qquad x(0)  X_0 = 1 2  mathbbR\n\nfor t  0 5, whose solution is known to be the decaying exponential x(t) = x_0e^-t. Let's plot the result, which requires loading the Plots.jl package\n\nvariable index 0 denotes time).\n\nusing Plots\n\n# post-processing or plotting\nplot(sol, vars=(0, 1), xlab=\"t\", ylab=\"x(t)\")\n\nFor comparison we can plot the trajectories at the endpoints of the initial interval. The example also shows that the black line segments can be hidden by setting the lw=0 argument (for linewidth).\n\ntrange = range(0, 5, length=100)\n\nplot(sol, vars=(0, 1), xlab=\"t\", ylab=\"x(t)\", lw=0)\nplot!(trange, 1.0 * exp.(-trange), vars=(0, 1), c=:magenta, lab=\"\")\nplot!(trange, 2.0 * exp.(-trange), vars=(0, 1), c=:magenta, lab=\"\")\n\nThe user-facing interface is designed to be intuitive and interactive, and it is inspired by of other Julia packages such as OrdinaryDiffEq.jl. Moreover, the library internals are written in a modular and composable way, such that advanced users are able to modify and changed easily, or to compose with other algorithms, different steps of the solution process.\n\nIn the rest of this notebook we explore different problem specifications, different algorithm choices as well as some processing capabilities. As a preliminary, we introduce the concept of reach-set in the context of the toy model presented above.","category":"section"},{"location":"tutorials/linear_methods/introduction/#Introducing-reach-sets","page":"Introduction","title":"Introducing reach-sets","text":"Basically, a reach-set is a structure that holds a set and a time span associated to it. Here we pick the first reach-set and show that it is of an interval type.\n\n# solutions implement the array interface\nR = sol[1]\n\nNote that sol[1] works since solution structures implement Julia's array interface – meaning that slicing also works, and e.g. sol[end-3:end] returns the last three reach-sets computed.\n\nThe solution obtained by set propagation consists of a flowpipe, which is just an array of reach-sets, and behaves like their set union. Flowpipes are at the right level of abstraction concerning solutions obtained with set propagation methods.\n\nWe can plot the first reach-set as well.\n\ntrange = range(0, 5, length=100)\n\nplot(sol, vars=(0, 1), xlab=\"t\", ylab=\"x(t)\", lw=0)\nplot!(R, vars=(0, 1), xlab=\"t\", ylab=\"x(t)\", lw=0, alpha=1., c=:orange, lab=\"R = sol[1]\")\nplot!(trange, 1.0 * exp.(-trange), vars=(0, 1), c=:magenta, lab=\"\")\nplot!(trange, 2.0 * exp.(-trange), vars=(0, 1), c=:magenta, lab=\"\")\n\nWe can also plot the tenth reach-set in red:\n\nplot!(sol[10], vars=(0, 1), xlab=\"t\", ylab=\"x(t)\", lw=0, alpha=1., c=:red, lab=\"sol[10]\")\n\nThe type of reach-sets specifies its numeric type as well as the set representation used; in this case, an interval.\n\ntypeof(R)\n\nObserving the horizontal axis of the plots reveals that reach-sets have a non-zero along on the time axis. By construction, it is guaranteed that the flowpipe is an enclosure of the true solutions, i.e. no trajectory escapes each reach-set for a given time-span. The time span associated to a reach-set is obtained with the function tspan.\n\ntspan(R)\n\nActually, the algorithm that has been used to solve the problem has a fixed step size of δ = 005.\n\ntspan(sol[end]) # time-span of the final reach-set\n\nWe can check by extracting the algorithm information from the solution struct:\n\n# methods' step-size\nsol.alg.δ\n\nThe functions tstart and tend return the starting and final time of the reach-set.\n\ntstart(R)\n\ntend(R)\n\nThe set wrapped by R is obtained with set:\n\nset(R)\n\nWe see it is an interval (LazySets.Interval is just a thin wrapper around IntervalArithmetic.Interval; more on this in a note below).\n\nIt is interesting to observe that the infimum of sol[1] 0.9487, while we have specified that the initial interval is X_0 = 1 2. The explanation is that the computed reach-set contains the true solution for all intermediate times between 0 and 0.05 and for all initial states in X_0. Since the values of x(t) decrease in the time interval 0 005 the width of sol[1] should be sufficiently big as to enclose those variations. We can make a quick check:\n\n1.0 * exp(-0.05)\n\nwhich shows that R indeed is a correct enclosure of the solution for all points in the initial set. It is easy to check that by decreasing the step-size, the enclosure of the solution at 0 005 converges to the true value (from outside), and similarly for other time intervals.","category":"section"},{"location":"tutorials/linear_methods/introduction/#More-about-time-intervals","page":"Introduction","title":"More about time intervals","text":"The time span associated to a reach-sets is an interval satisfying the rules of interval arithmetic. We use IntervalArithmetic.jl to represent time intervals.\n\nReachabilityAnalysis.TimeInterval # alias\n\n# retrieve the time span associated to this reach-set\ntspan(R)\n\n# it is an interval (from IntervalArithmetic.jl)\ntypeof(tspan(R))\n\n\nTime intervals are represented using intervals from IntervalArithmetic.jl. This choice guarantees that all calculations involving time are carried out using rigorous floating-point calculations with interval arithmetic: all quantities are treated as intervals, which are propagated throughout a calculation. The final result is an interval that is guaranteed to contain the correct result, starting from the given initial data.\n\nIf desired, it is also work with set using interval elements:\n\nBint = BallInf(interval.(ones(2)), interval(0.2))\n\nFinally, note that if you create a reach-set by passing a time point, it is automatically converted to an interval:\n\nR = ReachSet(rand(BallInf, dim=5), 1.0)\n\ntspan(R)","category":"section"},{"location":"lib/algorithms/LGG09/#ReachabilityAnalysis.LGG09","page":"LGG09","title":"ReachabilityAnalysis.LGG09","text":"LGG09{N, AM, TN<:AbstractDirections} <: AbstractContinuousPost\n\nImplementation of Girard - Le Guernic algorithm for reachability analysis using support functions.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\ntemplate     – (alias: dirs) struct that holds the directions (either lazily or concretely)                   for each support function evaluation defining the template\nstatic       – (optional, default: false) if true, use statically sized arrays\nthreaded     – (optional, default: false) if true, use multi-threading                   to compute different template directions in parallel\nsparse       – (optional, default: false) if true, convert the matrix exponential                   obtained after discretization to a sparse matrix\ncache        – (optional, default: true) if true, use a cache for intermediate                   computations in the set recurrence loop\nvars         – (optional, default: missing) an integer or a vector of integers                   specifying the variables of interest to automatically construct a template                   using canonical directions; requires that n (or dim) is specified as well\n\nNotes\n\nThe type fields are:\n\nN        – number type of the step-size\nAM       – type of the approximation model\nTN       – type of the abstract directions that define the template\n\nThe flag threaded=true specifies that the support functions along different directions should be computed in parallel. See the section on Multi-threading for details on how to setup the number of threads.\n\nReferences\n\nThis is an implementation of the algorithm from Le Guernic and Girard [LG09].\n\nThese methods are described at length in the dissertation [LG09].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/LGG09/#ReachabilityAnalysis.reach_homog_krylov_LGG09!","page":"LGG09","title":"ReachabilityAnalysis.reach_homog_krylov_LGG09!","text":"reach_homog_krylov_LGG09!(out, Ω₀::LazySet, Aᵀδ::AbstractMatrix,\n                          ℓ::AbstractVector, NSTEPS;\n                          hermitian=false, m=min(30, size(Aᵀδ, 1)), tol=1e-7)\n\nAlgorithm\n\nWe compute the sequence:\n\n    ρ(ℓ Ω₀) ρ(ℓ Φ Ω₀) ρ(ℓ Φ^2 Ω₀) ρ(ℓ Φ^3 Ω₀) \n\nUsing Krylov subspace approximations to compute the action of Φ := exp(Aδ) over the direction ℓ.\n\nThe method is (see [BFF+18]):\n\nout[1] <- ρ(ℓ, Ω₀)\n\nout[2] <- ρ(ℓ, Φ Ω₀) = ρ(Φᵀ ℓ, Ω₀)\n\nout[3] <- ρ(ℓ, Φ^2 Ω₀) = ρ((Φᵀ)^2 ℓ, Ω₀)\n\nout[4] <- ρ(ℓ, Φ^3 Ω₀) = ρ((Φᵀ)^3 ℓ, Ω₀)\n\nand so on.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/set_representations/polyhedral_computations/#Concrete-polyhedra","page":"Polyhedral computations","title":"Concrete polyhedra","text":"","category":"section"},{"location":"tutorials/set_representations/polyhedral_computations/#Polyhedra-backends","page":"Polyhedral computations","title":"Polyhedra backends","text":"","category":"section"},{"location":"tutorials/set_representations/polyhedral_computations/#Limitations","page":"Polyhedral computations","title":"Limitations","text":"Computing with concrete polyhedra in high dimensions is generally expensive. In particular, converting between vertex and constraint representations (so-called dual representations) should be used only if it is strictly necessary. However, there are some operations that are cheap:\n\nIntersecting two (or more) sets in constraint representation, or whose constraints_list can be computed efficiently. Such computation only requires concatenating the constraints and removing redundant inequalities (operation that requires the solution of linear programs).\nTaking linear maps of sets in vertex representation, MX. This operation requires to map each vertex of X under the transformation M. Linear transformations can also be done efficiently in constraint representation provided that the matrix M is invertible. LazySets handles other cases (M not invertible, and the sets either in constraint or in vertex representation), but they are generally expensive in high dimensions. However, using specific classes of sets (e.g. zonotopes).","category":"section"},{"location":"tutorials/taylor_methods/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"This section provides a quickstart to the Taylor-models reachability method with a univariate oscillator as running example. It is a small example that mixes intervals, the sine function, and differential equations. It is easy to check that the function\n\nx(t) = x_0 expleft(cos(t) - 1right)qquad x_0  mathbbR\n\nsolves the following differential equation:\n\nx(t) = -x(t)  sin(t)qquad t  0\n\nStandard integration schemes fail to produce helpful solutions if the initial state is an interval. We illustrate this point by solving the given differential equation with the Tsit5 algorithm from OrdinaryDiffEq.jl suite.\n\nusing OrdinaryDiffEq, IntervalArithmetic\n\n# initial condition\nx₀ = [-1 .. 1]\n\n# define the problem\nfunction f(dx, x, p, t)\n    dx[1] = -x[1] * sin(t)\nend\n\n# pass to solvers\nprob = ODEProblem(f, x₀, (0.0, 2.0))\nsol = solve(prob, Tsit5(), adaptive=false, dt=0.05, reltol=1e-6)\nnothing # hide\n\nThere is no plot recipe readily available so we create it by hand using LazySets.jl.\n\nusing LazySets, Plots\nusing LazySets: Interval\n\nout = [Interval(sol.t[i]) × Interval(sol.u[i][1]) for i in 1:20]\n\nfig = plot(out, xlab=\"t\", ylab=\"x(t)\", lw=3.0, alpha=1., c=:black, marker=:none, lab=\"\", title=\"Standard integrator with an interval initial condition\")\n\nimport DisplayAs  # hide\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nThe divergence observed in the solution is due to using an algorithm which doesn't specialize for intervals hence suffers from dependency problems.\n\nHowever, specialized algorithms can handle this case without noticeable wrapping effect, producing a sequence of sets whose union covers the true solution for all initial points. We use the ReachabilityAnalysis.jl interface to the algorithm TMJets21a, which is itself implemented in TaylorModels.jl.\n\nusing ReachabilityAnalysis, Plots\n\n# define the model (same as before)\nfunction f(dx, x, p, t)\n    dx[1] = -x[1] * sin(1.0 * t)\nend\n\n# define the set of initial states\nX0 = -1 .. 1\n\n# define the initial-value problem\nprob = @ivp(x' = f(x), x(0) ∈ X0, dim=1)\n\n# solve it using a Taylor model method\nsol = solve(prob, alg=TMJets21a(abstol=1e-10), T=15)\n\n# visualize the solution in time\nfig = plot(sol, vars=(0, 1), xlab=\"t\", ylab=\"x(t)\", title=\"Specialized (Taylor-model based) integrator\")\n\nimport DisplayAs  # hide\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nIt is illustrative to plot the computed flowpipe and the known analytic solution for a range of initial conditions that cover the range of the initial interval X0 = -1 .. 1. We can do so by overlaying exact solutions taken uniformly from the initial interval.\n\nanalytic_sol(x0) = t -> x0 * exp(cos(t) - 1.0)\n\ndt = range(0, 15, length=100)\nx0vals = range(-1, 1, length=25)\n\nfig = plot()\nplot!(fig, sol, lw=0.0, vars=(0, 1), xlab=\"t\", ylab=\"x(t)\", title=\"Specialized (Taylor-model based) integrator\")\n[plot!(fig, dt, analytic_sol(x0).(dt), lab=\"\", c=:magenta, lw=2.0, xlab=\"t\", ylab=\"x(t)\") for x0 in x0vals]\nfig\n\nimport DisplayAs  # hide\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nReachabilityAnalysis.jl defines several methods to analyze the solution. For example, the number of reach-sets can be obtained using length (more generally, use numrsets for hybrid systems):\n\n# number of computed reach-sets\nlength(sol)\n\nSolutions implement the array interface hence it is possible to index them:\n\n# first reach-set of the flowpipe\nsol[1]\n\nNote that sol[1] is an expansion in time whose coefficients are polynomials in space. The associated time span can be obtained with tspan:\n\n# time span of this reach-set\ntspan(sol[1])\n\nSimilarly we can print the last reach-set:\n\nsol[end]\n\ntspan(sol[end])\n\nIt is also possible to filter solutions by the time variable using parentheses:\n\n# find the reach-set(s) that contain 1.0 in their time span\naux = sol(1.0)\n\ntspan(aux)\n\nFiltering by the time span also works with time intervals; in the following example, we obtain all reach-sets whose time span with the interval 1.0 .. 3.0 is non-empty:\n\nlength(sol(1.0 .. 3.0))\n\nOn the other hand, evaluating over a given time point or time interval can be achieved using the evaluate function:\n\n# evaluate over the full time interval ≈ [0, 0.100777]\nevaluate(sol[1], tspan(sol[1]))\n\n# evaluate over the final time point 0.10077670723811318\nevaluate(sol[1], tend(sol[1]))\n\n# evaluate the final reach-set at the final time point\nevaluate(sol[end], 15.0)\n\nFinally, note that the solution structure, apart from storing the resulting flowpipe, contains information about the algorithm that was used to obtain it:\n\nsol.alg\n\nThe type of reach-set representation as well as the set representation can be obtained using rsetrep and setrep respectively.\n\n# type of the reach-set representation\nrsetrep(sol)\n\n# type of the set representation\nsetrep(sol)\n\nThe following section discusses more details about those representations.","category":"section"},{"location":"lib/reachsets/#Reach-sets","page":"Reach-sets","title":"Reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#Abstract-interface","page":"Reach-sets","title":"Abstract interface","text":"The functions are available at the interface level.","category":"section"},{"location":"lib/reachsets/#Reachable-set","page":"Reach-sets","title":"Reachable set","text":"","category":"section"},{"location":"lib/reachsets/#Sparse-reachable-set","page":"Reach-sets","title":"Sparse reachable set","text":"","category":"section"},{"location":"lib/reachsets/#Taylor-model-reach-sets","page":"Reach-sets","title":"Taylor model reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#Template-reach-sets","page":"Reach-sets","title":"Template reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractReachSet","text":"AbstractReachSet{N}\n\nAbstract type for all reach-sets types.\n\nNotes\n\nA reach-set is a set representation X associated to a given time span Δt.\n\nIn its simplest form, we represent reach-sets with a struct that wraps the tuple (X, Δt), where X corresponds to a geometric set, eg. a polytope, and Δt is the interval with the time span associated to this reach-set.\n\nThis type is parametric in N. The parameter N represents for the type of numerical coefficient used in the representation (typically, N = Float64).\n\nAlthough concrete subtypes of AbstractReachSet may represent the set X in different ways, or carry additional information as an extra type field, they should all implement the AbstractReachSet interface to enable shared functionality for reach-set types. In particular, each concrete subtype should implement the following methods:\n\nset    – return the geometric set\nsetrep – return the type of the set representation\ntspan  – return the time interval span\ntstart – return the initial time\ntend   – return the final time\ndim    – return ambient dimension of the reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#LazySets.set-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"LazySets.set","text":"set(R::AbstractReachSet)\n\nReturn the geometric set represented by this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe set wrapped by the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.setrep-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.setrep","text":"setrep(R::AbstractReachSet)\n\nReturn the type of the set representation of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nType of the set representation of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tspan","text":"tspan(R::AbstractReachSet)\n\nReturn time span of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe interval representing the time span of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tstart","text":"tstart(R::AbstractReachSet)\n\nReturn the initial time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tend","text":"tend(R::AbstractReachSet)\n\nReturn the final time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the final time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#LazySets.API.dim-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"LazySets.API.dim","text":"dim(R::AbstractReachSet)\n\nReturn the ambient dimension of the reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nAn integer corresponding to the ambient dimension of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#Base.copy-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"Base.copy","text":"copy(R::AbstractReachSet)\n\nReturn a copy of the given reach-set.\n\nInput\n\nR  – reach-set\n\nOutput\n\nA new reach-set of the sam type and the same field values as R.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.shift-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.shift","text":"shift(fp::Flowpipe{N, <:AbstractReachSet}, t0::Number) where {N}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractLazyReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractLazyReachSet","text":"AbstractLazyReachSet{N} <: AbstractReachSet{N}\n\nAbstract type for all reach-set types that use a LazySet for the underlying set representation.\n\nNotes\n\nAn AbstractLazyReachSet is the interface for reach-sets such that the geometric set is represented by any subtype of LazySet.\n\nThis types implements the LazySets interface, namely support function (ρ), support vector (σ) and ambient dimension (dim) functions. Hence, these functions directly apply to concrete subtypes of an AbstractLazyReachSet. The set wrapped by this type is obtained through set(R).\n\nThe following functions should be implemented by any concrete subtype:\n\nreconstruct – create a new instance of the given reach-set with a different                  set representation but sharing the other fields, i.e. the same                  time span (and the same for other fields, if applicable)\n\nIn addition to the functions inherited from AbstractReachSet, the following are available:\n\nlinear_map  – concrete linear map of a reach-set\nproject     – projection of a reach-set\nshift       – time-shift of a reach-set\nvars        – tuple of integers associated to the variables of the given reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#LazySets.API.project-Union{Tuple{D}, Tuple{ReachabilityAnalysis.AbstractLazyReachSet, NTuple{D, Int64}}} where D","page":"Reach-sets","title":"LazySets.API.project","text":"project(R::AbstractLazyReachSet, variables::NTuple{D,Int};\n        check_vars::Bool=true) where {D}\n\nProjects a reach-set onto the subspace spanned by the given variables.\n\nInput\n\nR          – reach-set\nvars       – tuple of variables for the projection\ncheck_vars – (optional, default: true) if true, check that the given variable                 indices vars are a subset of the variables of R\n\nOutput\n\nA SparseReachSet whose variable indices are given by vars.\n\nThe type of the new reach-set depends on the type of the reach-set R:\n\nIf R contains a hyperrectangular set, the output is a hyperrectangle.\nIf R contains a zonotopic set, the output is a zonotope.\nOtherwise, the return type is a polytope either in constraint representation or in vertex representation, depending on the dimension and the properties of M. For details, see LazySets.project.\n\nNotes\n\nThis function can be used to project a reach-set onto a lower-dimensional sub-space. The projection is concrete, and it consists of mapping the reach-set X = set(R) to a new reach-set through to MX, where M is the projection matrix associated with the given variables vars.\n\nTo project onto the time variable, use the index 0. For instance, (0, 1) projects onto the time variable and the first variable in R.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.ReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.ReachSet","text":"ReachSet{N, ST<:LazySet{N}} <: AbstractLazyReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation.\n\nFields\n\nX  – set\nΔt – time interval\n\nNotes\n\nA ReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype LazySet. For efficiency reasons, ST should be concretely typed.\n\nBy assumption the coordinates in this reach-set are associated to the integers 1, …, n. The function vars returns such tuple.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#ReachabilityAnalysis.SparseReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.SparseReachSet","text":"SparseReachSet{N, ST<:LazySet{N}, D} <: AbstractReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation, together with a tuple of variables associated to this reach-set.\n\nFields\n\nX        – set\nΔt       – time interval\nvars – tuple of variable indices represented by the set X\n\nNotes\n\nA SparseReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype of LazySet (ideally, concrete). Moreover, this type also stores information about the variables (also named coordinates, or by abuse of notation, dimensions) corresponding to the set X.\n\nFor instance in the ambient space n=5, one may have a SparseReachSet whose variables tuple is vars = (4, 5, 6), i.e. representing a three-dimensional projection of the full-dimensional reach-set. In consequence, the dimension of X doesn't match the length of vars, in general\n\nIn this type, the parameter N represents the numerical type of the LazySet (typically, Float64), the type ST represents the set representation used, and D denotes the dimension of this sparse reach set. Note that, in contrast to ReachSet, for SparseReachSet the number of dimensions is part of the type information.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractTaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractTaylorModelReachSet","text":"AbstractTaylorModelReachSet{N}\n\nAbstract type for all reach sets types that represent a Taylor model.\n\nNotes\n\nThe parameter N refers to the numerical type of the representation.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#ReachabilityAnalysis.TaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TaylorModelReachSet","text":"TaylorModelReachSet{N, S} <: AbstractTaylorModelReachSet{N}\n\nReach-set representation consisting of a vector of taylor models in one variable (the \"time\" variable) whose coefficients are multivariate polynomials (the \"space\" variables).\n\nNotes\n\nThe parameters N and S refer to the numerical type of the representation (used for the Taylor model in time and Taylor series polynomials respectively). The space variables are assumed to be normalized to the interval [-1, 1]. It is assumed that the time domain is the same for all components.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#ReachabilityAnalysis.TemplateReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TemplateReachSet","text":"TemplateReachSet{N, VN, TN<:AbstractDirections{N, VN}, SN<:AbstractVector{N}} <: AbstractLazyReachSet{N}\n\nReach set that stores the support function of a set at a give set of directions.\n\nNotes\n\nThe struct has the following parameters:\n\nN  – refers to the numerical type of the representation.\nVN – refers to the vector type of the template\nTN – refers to the template type\nSN – vector type that holds the support function evaluations\n\nConcrete subtypes of AbstractDirections are defined in the LazySets library.\n\nThis reach-set implicitly represents a set by a set of directions and support functions. set(R::TemplateReachSet) returns a polyhedron in half-space representation.\n\nApart from the getter functions inherited from the AbstractReachSet interface, the following methods are available:\n\ndirections(R)           – return the set of directions normal to the faces of this reach-set\nsupport_functions(R)    – return the vector of support function evaluations\nsupport_functions(R, i) – return the i-th coordinate of the vector of support function evaluatons\n\n\n\n\n\n","category":"type"},{"location":"lib/distributed/#Distributed-computations","page":"Distributed computations","title":"Distributed computations","text":"This section of the manual gives additional pointers on making use of distributed computation within the library.\n\nPages = [\"distributed.md\"]\nDepth = 3","category":"section"},{"location":"lib/distributed/#Multi-threading","page":"Distributed computations","title":"Multi-threading","text":"Since version 1.3, Julia has built-in multi-threaded parallelism and we have applied such feature at different levels in the library:\n\nMulti-threaded implementations of reachability algorithms. This approach relies on the particular structure of each algorithm and hence it doesn't generalize to different algorithms. An example is the exploration of template directions in simultaneous with LGG09. Details are included in the documentation page of each algorithm.\nParallel solve, with split initial conditions. This approach applies to all algorithms, because we can always split an initial domain into smaller subdomains, and run solve on each of these regions in parallel. See Parallel solve below for details.\n\nJulia's documentation on multi-threading describes how to check the number of threads available in the current session, Threads.nthreads(), and how to control the number of threads e.g. by starting Julia with $ julia --threads 4 to use four threads. Please note that to make the number of threads persistent across different Julia sessions you should export an environment variable, export JULIA_NUM_THREADS=4 to be added in your .bashrc or .bash_profile files, or setting ENV[\"JULIA_NUM_THREADS\"]=4 in your .julia/config/startup.jl file.","category":"section"},{"location":"lib/distributed/#GPGPU-computing","page":"Distributed computations","title":"GPGPU computing","text":"The recommended entry point for using general-purpose graphical processing units (GPGPU) in Julia is the library CUDA.jl. The package exports an array type CuArray used as an abstraction to perform array operations on the GPU device; common linear algebra operations are readily available through dispatch on CuArray. Apart from convenient high-level syntax to do basic linear algebra on GPUs; more advanced kernel functions can be implemented as well as it is explained in the CUDA.jl documentation.","category":"section"},{"location":"lib/distributed/#Parallel-solve","page":"Distributed computations","title":"Parallel solve","text":"Reachability computations can be computed in parallel using Julia's built-in multithreaded parallelism. This feature is available formulating and solving an initial-value problem with an array of initial conditions.","category":"section"},{"location":"lib/distributed/#About-BLAS-threads","page":"Distributed computations","title":"About BLAS threads","text":"To control the number of threads used by your BLAS library, use the function BLAS.set_num_threads(n), where n is an integer. Furthermore, the function BLAS.get_num_threads() defined below will return the current value.\n\nNote. If you are using Julia v\"0.7-\" (run the command VERSION to find this), instead of Base.LinAlg below use LinearAlgebra, and this module should have been loaded in the current scope with using LinearAlgebra.\n\n#\n# This function is a part of Julia. License is MIT: https://julialang.org/license\n#\nfunction get_num_threads() # anonymous so it will be serialized when called\n    blas = Base.LinAlg.BLAS.vendor()\n    # Wrap in a try to catch unsupported blas versions\n    try\n        if blas == :openblas\n            return ccall((:openblas_get_num_threads, Base.libblas_name), Cint, ())\n        elseif blas == :openblas64\n            return ccall((:openblas_get_num_threads64_, Base.libblas_name), Cint, ())\n        elseif blas == :mkl\n            return ccall((:MKL_Get_Max_Num_Threads, Base.libblas_name), Cint, ())\n        end\n\n        # OSX BLAS looks at an environment variable\n        if Sys.isapple()\n            return ENV[\"VECLIB_MAXIMUM_THREADS\"]\n        end\n    end\n\n    return nothing\nend","category":"section"},{"location":"lib/distributed/#ReachabilityAnalysis._distribute","page":"Distributed computations","title":"ReachabilityAnalysis._distribute","text":"_distribute(ivp::InitialValueProblem{HS, ST};\n            intersection_method::AbstractIntersectionMethod=nothing,\n            check_invariant=false,\n            intersect_invariant=false,\n            ) where {HS<:HybridSystem, ST<:AdmissibleSet}\n\nDistribute the set of initial states to each mode of a hybrid system.\n\nInput\n\nsystem              – an initial value problem wrapping a mathematical system (hybrid)                          and a set of initial states\nintersection_method – method to perform the flowpipe-guard intersections\ncheck_invariant     – (optional, default: false) if false, only add those modes                          for which the intersection of the initial state with the invariant is non-empty\nintersect_invariant – (optional, default: false) if false, take the concrete intersection with the invariant\n\n(and possibly overapproximate to keep WaitingList concretely typed)\n\nOutput\n\nA new initial value problem with the same hybrid system but where the set of initial states is the list of tuples (state, X0), for each state in the hybrid system.\n\n\n\n\n\n","category":"function"},{"location":"bibliography/#all_ref","page":"Bibliography","title":"Bibliography","text":"This page includes references to the scientific works that we have applied throughout this library. Although the list is not meant to be exhaustive, we think it should give a solid starting place for those who want to explore further.\n\nIf you use ReachabilityAnalysis.jl for your own work, please consider citing the appropriate original reference(s). We provide the BibTeX entries in each case.\n\nIf you find that a reference here is missing, if you spot a typo or want to update a reference, do not hesitate to contact us by email, or open an issue. Sorting is alphabetic.\n\nM. Althoff. Reachability analysis and its application to the safety assessment of autonomous cars. Ph.D. Thesis, Technische Universität München (2010).\n\n\n\nM. Althoff. Reachability Analysis of Large Linear Systems With Uncertain Inputs                   in the Krylov Subspace. Transactions on Automatic Control 65, 477–492 (2020).\n\n\n\nM. Althoff, S. Bak, M. Forets, G. Frehse, N. Kochdumper, R. Ray, C. Schilling and S. Schupp. ARCH-COMP19 Category Report: Continuous and Hybrid Systems with                   Linear Continuous Dynamics. In: Applied Verification of Continuous and Hybrid Systems (ARCH), Vol. 61 of EPiC Series in Computing, edited by G. Frehse and M. Althoff (EasyChair, 2019); pp. 14–40.\n\n\n\nM. Althoff, G. Frehse and A. Girard. Set Propagation Techniques for Reachability Analysis. Annual Review of Control, Robotics, and Autonomous Systems 4, 369–395 (2021).\n\n\n\nM. Althoff, D. Grebenyuk and N. Kochdumper. Implementation of Taylor models in CORA 2018. In: Applied Verification of Continuous and Hybrid Systems (ARCH), Vol. 54 of EPiC Series in Computing, edited by G. Frehse, M. Althoff, S. Bogomolov and T. T. Johnson (EasyChair, 2018); pp. 145–173.\n\n\n\nM. Althoff, B. H. Krogh and O. Stursberg. Analyzing reachability of linear dynamic systems with parametric uncertainties. Modeling, Design, and Simulation of Systems with Uncertainties, 69–94 (2011).\n\n\n\nM. Althoff, O. Stursberg and M. Buss. Reachability analysis of linear systems with uncertain parameters                   and inputs. In: Conference on Decision and Control (CDC) (IEEE, 2007); pp. 726–732.\n\n\n\nA. C. Antoulas, D. C. Sorensen and S. Gugercin. A survey of model reduction methods for large-scale systems. Contemporary Mathematics 280, 193–220 (2001).\n\n\n\nR. W. Beard. Quadrotor dynamics and control. Technical Report 1325 (Brigham Young University, 2008).\n\n\n\nJ. Bezanson, A. Edelman, S. Karpinski and V. B. Shah. Julia: A Fresh Approach to Numerical Computing. SIAM Review 59, 65–98 (2017).\n\n\n\nS. Bogomolov, M. Forets, G. Frehse, F. Viry, A. Podelski and C. Schilling. Reach Set Approximation through Decomposition with Low-dimensional                   Sets and High-dimensional Matrices. In: Hybrid Systems: Computation and Control (HSCC), edited by M. Prandini and J. V. Deshmukh (ACM, 2018); pp. 41–50.\n\n\n\nL. P. Carloni, R. Passerone, A. Pinto and A. L. Sangiovanni-Vincentelli. Languages and Tools for Hybrid Systems Design. Foundations and Trends in Electronic Design Automation 1 (2006).\n\n\n\nN. Chan and S. Mitra. Verifying safety of an autonomous spacecraft rendezvous mission. In: Applied Verification of Continuous and Hybrid Systems (ARCH), Vol. 48 of EPiC Series in Computing, edited by G. Frehse and M. Althoff (EasyChair, 2017); pp. 20–32.\n\n\n\nX. Chen, E. Ábrahám and S. Sankaranarayanan. Flow: An Analyzer for Non-linear Hybrid Systems*. In: Computer Aided Verification (CAV), Vol. 8044 of LNCS, edited by N. Sharygina and H. Veith (Springer, 2013); pp. 258–263.\n\n\n\nC. Combastel. A state bounding observer based on zonotopes. In: European Control Conference (ECC) (IEEE, 2003); pp. 2589–2594.\n\n\n\nM. Forets and C. Schilling. Reachability of Weakly Nonlinear Systems Using Carleman Linearization. In: Reachability Problems (RP), Vol. 13035 of LNCS, edited by P. C. Bell, P. Totzke and I. Potapov (Springer, 2021); pp. 85–99.\n\n\n\nM. Forets and C. Schilling. Conservative Time Discretization: A Comparative Study. In: Integrated Formal Methods (iFM), Vol. 13274 of LNCS, edited by M. H. Beek and R. Monahan (Springer, 2022); pp. 149–167.\n\n\n\nG. Frehse, C. Le Guernic, A. Donzé, S. Cotton, R. Ray, O. Lebeltel, R. Ripado, A. Girard, T. Dang and O. Maler. SpaceEx: Scalable Verification of Hybrid Systems. In: Computer Aided Verification (CAV), Vol. 6806 of LNCS, edited by G. Gopalakrishnan and S. Qadeer (Springer, 2011); pp. 379–395.\n\n\n\nL. Geretti, J. A. Sandretto, M. Althoff, L. Benet, A. Chapoutot, X. Chen, P. Collins, M. Forets, D. Freire, F. Immler, N. Kochdumper, D. P. Sanders and C. Schilling. ARCH-COMP20 Category Report: Continuous and Hybrid Systems with                   Nonlinear Dynamics. In: Applied Verification of Continuous and Hybrid Systems (ARCH), Vol. 74 of EPiC Series in Computing (EasyChair, 2020); pp. 49–75.\n\n\n\nL. Geretti, J. A. Sandretto, M. Althoff, L. Benet, A. Chapoutot, P. Collins, P. S. Duggirala, M. Forets, E. Kim, U. Linares, D. P. Sanders, C. Schilling and M. Wetzlinger. ARCH-COMP21 Category Report: Continuous and Hybrid Systems with                   Nonlinear Dynamics. In: Applied Verification of Continuous and Hybrid Systems (ARCH), Vol. 80 of EPiC Series in Computing, edited by G. Frehse and M. Althoff (EasyChair, 2021); pp. 32–54.\n\n\n\nA. Girard. Reachability of Uncertain Linear Systems Using Zonotopes. In: Hybrid Systems: Computation and Control (HSCC), Vol. 3414 of LNCS, edited by M. Morari and L. Thiele (Springer, 2005); pp. 291–305.\n\n\n\nA. Girard and C. Le Guernic. Efficient reachability analysis for linear systems using support functions. IFAC Proceedings Volumes 41, 8966–8971 (2008).\n\n\n\nA. Girard, C. Le Guernic and O. Maler. Efficient Computation of Reachable Sets of Linear Time-Invariant Systems                   with Inputs. In: Hybrid Systems: Computation and Control (HSCC), Vol. 3927 of LNCS, edited by J. P. Hespanha and A. Tiwari (Springer, 2006); pp. 257–271.\n\n\n\nS. Gruenbacher, J. Cyranka, M. Lechner, M. A. Islam, S. A. Smolka and R. Grosu. Lagrangian Reachtubes: The Next Generation. In: Conference on Decision and Control (CDC) (IEEE, 2020); pp. 1556–1563.\n\n\n\nN. J. Higham. Functions of matrices - theory and computation (SIAM, 2008).\n\n\n\nY. Huang, E. Luo, S. Bak and Y. Sun. Reachability analysis for linear systems with uncertain parameters using polynomial zonotopes. Nonlinear Analysis: Hybrid Systems 56 (2025).\n\n\n\nC. A. Kluever. Dynamic Systems: Modeling, Simulation, and Control (John Wiley & Sons, 2020).\n\n\n\nS. Kopecz and A. Meister. On order conditions for modified Patankar–Runge–Kutta schemes. Applied Numerical Mathematics 123, 159–179 (2018).\n\n\n\nM. T. Laub and W. F. Loomis. A molecular network that produces spontaneous oscillations in excitable cells of Dictyostelium. Molecular Biology of the Cell 9, 3521–3532 (1998).\n\n\n\nC. Le Guernic and A. Girard. Reachability Analysis of Hybrid Systems Using Support Functions. In: Computer Aided Verification (CAV), Vol. 5643 of LNCS, edited by A. Bouajjani and O. Maler (Springer, 2009); pp. 540–554.\n\n\n\nC. Le Guernic and A. Girard. Reachability analysis of linear systems using support functions. Nonlinear Analysis: Hybrid Systems 4, 250–262 (2010). IFAC World Congress 2008.\n\n\n\nR. E. Moore. Automatic local coordinate transformations to reduce the growth of error bounds in interval computation of solutions of ordinary differential equations. Error in Digital Computation 2, 103–140 (1965).\n\n\n\nC. Schilling. Fundamental techniques for the scalable analysis of systems. Ph.D. Thesis, University of Freiburg, Germany (2018).\n\n\n\nT. Strathmann and J. Oehlerking. Verifying Properties of an Electro-Mechanical Braking System. In: Applied Verification of Continuous and Hybrid Systems (ARCH), Vol. 34 of EPiC Series in Computing, edited by G. Frehse and M. Althoff (EasyChair, 2015); pp. 49–56.\n\n\n\nR. Testylier and T. Dang. NLTOOLBOX: A Library for Reachability Computation of Nonlinear                   Dynamical Systems. In: Automated Technology for Verification and Analysis (ATVA), Vol. 8172 of LNCS, edited by D. V. Hung and M. Ogawa (Springer, 2013); pp. 469–473.\n\n\n\nH.-D. Tran, L. V. Nguyen and T. T. Johnson. Large-Scale Linear Systems from Order-Reduction. In: Applied Verification of Continuous and Hybrid Systems (ARCH), Vol. 43 of EPiC Series in Computing, edited by G. Frehse and M. Althoff (EasyChair, 2016); pp. 60–67.\n\n\n\nX. Yang and J. K. Scott. A comparison of zonotope order reduction techniques. Automatica 95, 378–384 (2018).\n\n\n\n\n\nR. Alur, C. Courcoubetis, N. Halbwachs, T. A. Henzinger, P.-H. Ho, X. Nicollin, A. Olivero, J. Sifakis and S. Yovine. The Algorithmic Analysis of Hybrid Systems. Theoretical Computer Science 138, 3–34 (1995).\n\n\n\nS. Bogomolov, M. Forets, G. Frehse, K. Potomkin and C. Schilling. Reachability Analysis of Linear Hybrid Systems via Block Decomposition. Transactions on Computer-Aided Design of Integrated Circuits and Systems 39, 4018–4029 (2020).\n\n\n\nX. Chen. Reachability Analysis of Non-Linear Hybrid Systems Using Taylor Models. Ph.D. Thesis, RWTH Aachen, Germany (2015).\n\n\n\nG. Frehse. Scalable Verification of Hybrid Systems (Verimag, 2016).\n\n\n\nG. Frehse and R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support                   Functions. In: Analysis and Design of Hybrid Systems (ADHS), Vol. 45 no. 9 of IFAC Proceedings Volumes, edited by M. Heemels and B. D. Schutter (Elsevier, 2012); pp. 94–101.\n\n\n\nA. Girard. Algorithmic Analysis of Hybrid Systems. Ph.D. Thesis, Grenoble Institute of Technology, France (2004).\n\n\n\nA. Girard. Computational Approaches to Analysis and Control of Hybrid Systems (University of Grenoble, 2013).\n\n\n\nV. S. Hakim and M. J. Bekooij. Reachability Analysis of Hybrid Automata with Clocked Linear Dynamics. In: Software and Compilers for Embedded Systems (SCOPES), edited by S. Stuijk (ACM, 2019); pp. 27–36.\n\n\n\nM. Joldes. Rigorous Polynomial Approximations and Applications. Ph.D. Thesis, École normale supérieure de Lyon, France (2011).\n\n\n\nN. Kekatos. Formal Verification of Cyber-Physical Systems in the Industrial Model-Based                   Design Process. Ph.D. Thesis, Grenoble Alpes University, France (2018).\n\n\n\nC. Le Guernic. Reachability Analysis of Hybrid Systems with Linear Continuous Dynamics. Ph.D. Thesis, Joseph Fourier University, Grenoble, France (2009).\n\n\n\nR. Ray. Reachability Analysis of Hybrid Systems using Support Functions. Ph.D. Thesis, Grenoble Alpes University, France (2012).\n\n\n\nA. Rocca. Formal methods for modelling and validation of biological models. Ph.D. Thesis, Grenoble Alpes University, France (2018).\n\n\n\nS. Schupp. State set representations and their usage in the reachability analysis of hybrid systems. Ph.D. Thesis, RWTH Aachen, Germany (2019).\n\n\n\nB. Xue, M. Fränzle and N. Zhan. Under-Approximating Reach Sets for Polynomial Continuous Systems. In: Hybrid Systems: Computation and Control (HSCC), edited by M. Prandini and J. V. Deshmukh (ACM, 2018); pp. 51–60.\n\n\n\n","category":"section"},{"location":"generated_examples/EMBrake/#Electromechanical-brake","page":"Electromechanical brake","title":"Electromechanical brake","text":"note: Overview\nSystem type: Linear clocked hybrid system\nState dimension: 4\nApplication domain: Mechanical engineering","category":"section"},{"location":"generated_examples/EMBrake/#Model-description","page":"Electromechanical brake","title":"Model description","text":"This system models an electromechanical brake, which works as in the following image.\n\n(Image: )\n\nThe system is described by linear differential equations:\n\nbeginaligned\n    dotx(t) = Ax(t) + Bu(t)qquad u(t)  mathcalU \n    y(t) = Cx(t)\nendaligned\n\nA hybrid-automaton model is depicted below.\n\n(Image: )\n\nThere are two versions of this benchmark:\n\nTime-varying inputs: The inputs can change arbitrarily over time:  forall t u(t)  mathcalU.\nConstant inputs: The inputs are only uncertain in the initial value, and  constant over time: u(0)  mathcalU, dotu(t) = 0\n\nusing ReachabilityAnalysis, SparseArrays","category":"section"},{"location":"generated_examples/EMBrake/#Common-functionality-between-model-variants","page":"Electromechanical brake","title":"Common functionality between model variants","text":"The following code is shared between all model variants.\n\nfunction embrake_common(; A, Tsample, ζ, x0)\n    # continuous system\n    EMbrake = @system(x' = A * x)\n\n    # initial condition\n    X₀ = Singleton([0.0, 0, 0, 0])\n\n    # reset map\n    Ar = sparse([1, 2, 3, 4, 4], [1, 2, 2, 2, 4], [1.0, 1.0, -1.0, -Tsample, 1.0], 4, 4)\n    br = sparsevec([3, 4], [x0, Tsample * x0], 4)\n    reset_map(X) = Ar * X + br\n\n    # hybrid system with clocked affine dynamics\n    ha = HACLD1(EMbrake, reset_map, Tsample, ζ)\n    return IVP(ha, X₀)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/EMBrake/#Fixed-parameters","page":"Electromechanical brake","title":"Fixed parameters","text":"The model without parameter variation is defined below.\n\nfunction embrake_no_pv(; Tsample=1.E-4, ζ=1e-6, x0=0.05)\n    # model's constants\n    L = 1.e-3\n    KP = 10000.0\n    KI = 1000.0\n    R = 0.5\n    K = 0.02\n    drot = 0.1\n    i = 113.1167\n\n    # state variables: [I, x, xe, xc]\n    A = Matrix([-(R + K^2 / drot)/L 0 KP/L KI/L;\n                K / i/drot 0 0 0;\n                0 0 0 0;\n                0 0 0 0])\n\n    return embrake_common(; A=A, Tsample=Tsample, ζ=ζ, x0=x0)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/EMBrake/#Parameter-variation","page":"Electromechanical brake","title":"Parameter variation","text":"The model with parameter variation described below consists of changing only one coefficient, which corresponds to the Flow* settings in Strathmann and Oehlerking [SO15].\n\nfunction embrake_pv_1(; Tsample=1.E-4, ζ=1e-6, Δ=3.0, x0=0.05)\n    # model's constants\n    L = 1.e-3\n    KP = 10000.0\n    KI = 1000.0\n    R = 0.5\n    K = 0.02\n    drot = 0.1\n    i = 113.1167\n    p = 504.0 + (-Δ .. Δ)\n\n    # state variables: [I, x, xe, xc]\n    A = IntervalMatrix([-p 0 KP/L KI/L;\n                        K / i/drot 0 0 0;\n                        0 0 0 0;\n                        0 0 0 0])\n\n    return embrake_common(; A=A, Tsample=Tsample, ζ=ζ, x0=x0)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/EMBrake/#Extended-parameter-variation","page":"Electromechanical brake","title":"Extended parameter variation","text":"In the following model, considered in Strathmann and Oehlerking [SO15], we vary all constants by χ% with respect to their nominal values. The variation percentage defaults to 5%.\n\nfunction embrake_pv_2(; Tsample=1.E-4, ζ=1e-6, x0=0.05, χ=5.0)\n    # model's constants\n    Δ = -χ / 100 .. χ / 100\n    L = 1.e-3 * (1 + Δ)\n    KP = 10000.0 * (1 + Δ)\n    KI = 1000.0 * (1 + Δ)\n    R = 0.5 * (1 + Δ)\n    K = 0.02 * (1 + Δ)\n    drot = 0.1 * (1 + Δ)\n    i = 113.1167 * (1 + Δ)\n\n    # state variables: [I, x, xe, xc]\n    A = IntervalMatrix([-(R + K^2 / drot)/L 0 KP/L KI/L;\n                        K / i/drot 0 0 0;\n                        0 0 0 0;\n                        0 0 0 0])\n\n    return embrake_common(; A=A, Tsample=Tsample, ζ=ζ, x0=x0)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/SquareWaveOscillator/#Square-Wave-Oscillator","page":"Square wave oscillator","title":"Square Wave Oscillator","text":"note: Overview\nSystem type: Linear hybrid system\nState dimension: 1\nApplication domain: Electronics","category":"section"},{"location":"generated_examples/SquareWaveOscillator/#Model-description","page":"Square wave oscillator","title":"Model description","text":"using ReachabilityAnalysis, Symbolics\n\nfunction multistable_oscillator(; X0=Interval(0.0, 0.05),\n                                V₊=+13.5, V₋=-13.5,\n                                R=20.E3, C=5.5556E-8,\n                                R1=20.E3, R2=20.E3)\n    @variables x\n    τ = 1 / (R * C)\n    α = R2 / (R1 + R2)\n    A = -τ\n    automaton = GraphAutomaton(2)\n\n    b = (τ / α) * V₊\n    I₊ = HalfSpace(x <= α * V₊)\n    m1 = @system(x' = A * x + b, x ∈ I₊)\n\n    b = (τ / α) * V₋\n    I₋ = HalfSpace(x >= α * V₋)\n    m2 = @system(x' = A * x + b, x ∈ I₋)\n\n    add_transition!(automaton, 1, 2, 1)\n    g1 = Hyperplane(x == α * V₊)\n    r1 = ConstrainedIdentityMap(1, g1)\n\n    add_transition!(automaton, 2, 1, 2)\n    g2 = Hyperplane(x == α * V₋)\n    r2 = ConstrainedIdentityMap(1, g2)\n\n    modes = [m1, m2]\n    resetmaps = [r1, r2]\n    H = HybridSystem(automaton, modes, resetmaps)\n\n    # initial condition in mode 1\n    X0e = [(1, X0)]\n    return IVP(H, X0e)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/SquareWaveOscillator/#Specification","page":"Square wave oscillator","title":"Specification","text":"prob = multistable_oscillator();\nnothing #hide","category":"section"},{"location":"generated_examples/SquareWaveOscillator/#Analysis","page":"Square wave oscillator","title":"Analysis","text":"sol = solve(prob; T=100e-4, alg=INT(; δ=1.E-6), fixpoint_check=false);\nnothing #hide\n\nBelow we print the automaton location of each flowpipe segment:\n\nlocation.(sol)'","category":"section"},{"location":"generated_examples/SquareWaveOscillator/#Results","page":"Square wave oscillator","title":"Results","text":"using Plots\nimport DisplayAs  #hide\n\nold_ztol = LazySets._ztol(Float64)\nLazySets.set_ztol(Float64, 1e-8);  # use higher precision for the plots\n\nfig = plot(sol; vars=(0, 1), xlab=\"t\", ylab=\"v-\")\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/SquareWaveOscillator/#Analyzing-the-first-transition","page":"Square wave oscillator","title":"Analyzing the first transition","text":"Let us analyze the first transition in detail. If we plot the last ten reach sets of the first flowpipe, we observe that only the last three actually intersect with the guard:\n\nfig = plot(sol[1][(end - 10):end]; vars=(0, 1), xlab=\"t\", ylab=\"v-\")\nplot!(fig, x -> 6.75; xlims=(3.1e-4, 3.3e-4), lab=\"Guard\", lw=2.0, color=:red)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nWe now cluster those reach sets into a single hyperrectangle:\n\nXc = cluster(sol[1], [318, 319, 320], BoxClustering(1));\nnothing #hide\n\nPlotting this set matches with the flowpipe after the jump:\n\nfig = plot(sol[1][(end - 10):end]; vars=(0, 1))\nplot!(fig, sol[2][1:10]; vars=(0, 1))\nplot!(fig, x -> 6.75; xlims=(3.1e-4, 3.3e-4), lab=\"Guard\", lw=2.0, color=:red)\nplot!(fig, Xc[1]; vars=(0, 1), c=:grey)\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/SquareWaveOscillator/#Fixpoint-check","page":"Square wave oscillator","title":"Fixpoint check","text":"Finally, we note that the algorithm can find an invariant of the system after the first period. To activate this check, pass the fixpoint_check=true flag to the solve function. The computation terminates as soon as the last reach set is contained in a previously explored starting set.\n\nsol = solve(prob; T=100e-4, alg=INT(; δ=1.E-6), fixpoint_check=true)\ntspan(sol)\n\nfig = plot(sol; vars=(0, 1), xlab=\"t\", ylab=\"v-\")\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nLazySets.set_ztol(Float64, old_ztol);  # reset precision\nnothing #hide","category":"section"},{"location":"lib/algorithms/HLBS25/#HLBS25","page":"HLBS25","title":"HLBS25","text":"","category":"section"},{"location":"lib/algorithms/HLBS25/#ReachabilityAnalysis.HLBS25","page":"HLBS25","title":"ReachabilityAnalysis.HLBS25","text":"HLBS25{N, AM, RM, R} <: AbstractContinuousPost\n\nImplementation of the reachability algorithm for linear systems with parametric uncertainty using matrix zonotopes by Huang et al. [HLBS25].\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: CorrectionHullMatrixZonotope)                       model for the discretization of the initial value problem\ntaylor_order     – (optional, default: 5) order of the Taylor series                       expansion of the matrix exponential for each step\nmax_order        – (optional, default: 5) maximum order of the reach set\nreduction_method – (optional, default: LazySets.GIR05() zonotope                       order reduction method used\nrecursive        – (optional, default: false) if true, compute the                       Taylor series expansion of the matrix zonotope                       exponential map recursively\n\nNotes\n\nThe recursive option is used to compute the Taylor expansion of the matrix zonotope exponential map. If recursive == true, each term of the Taylor expansion is computed recursively (e.g., A^2 P = A (A P)).\n\nIf recursive == false, the Taylor expansion is computed by overapproximating the matrix zonotope exponential  map, producing a single matrix that represents the exponential.\n\n\n\n\n\n","category":"type"},{"location":"generated_examples/TransmissionLine/#Transmission-line-circuit","page":"Transmission line","title":"Transmission line circuit","text":"note: Overview\nSystem type: Linear continuous system\nState dimension: parametric, typically between 4 to 40\nApplication domain: Power systems stability\n\nWe consider the transmission line model used in Althoff et al. [AKS11]. The RLC circuit of the transmission line is shown below. In the circuit, U_in is the voltage at the sending end, and U_out is the voltage at the receiving end.\n\n(Image: )","category":"section"},{"location":"generated_examples/TransmissionLine/#Model-description","page":"Transmission line","title":"Model description","text":"For reference to understand this model, we refer to standard textbooks on electrical circuits. The electrical elements law for resistors (R), inductors (L), and capacitors (C) are studied, for instance, in Kluever [Klu20], Chapter 3.\n\nLet's assume that the circuit consists of η  2 nodes. There are η dynamic equations for the capacitor voltages and η dynamic equations for the circuit currents. Therefore, the state vector can be represented as\n\n    x = U_1 U_2  U_η I_1 I_2  I_η^T\n\nand the state dimension is 2η.","category":"section"},{"location":"generated_examples/TransmissionLine/#Analysis-of-the-first-node","page":"Transmission line","title":"Analysis of the first node","text":"When writing the equations for the voltages and currents, we should pay attention to the sign choices in the given circuit, which do not exactly match the convention in text books (in the sense that the U_1s positive terminal is at the bottom, as indicated by the arrows). Let R_d denote the driver resistance's current. By Kirchhoff's voltage law,\n\n    U_in = R_d I_1 + LI_1 - U_1\n\nTherefore,\n\n    boxedI_1 = dfracU_in + U_1L - dfracR_dLI_1\n\nBy Kirchhoff's current law, and if I_1 C denotes the current through the capacitor C, connected to the first node,\n\n   I_1 = I_2 + I_C 1\n\nand\n\nI_C 1 = -CU_1\n\nHence\n\n   boxedU_1 = dfracI_2 - I_1C","category":"section"},{"location":"generated_examples/TransmissionLine/#Analysis-of-the-intermediate-nodes","page":"Transmission line","title":"Analysis of the intermediate nodes","text":"The intermediate nodes' equations are obtained in a similar fashion. For instance, for the second loop one has\n\n    -U_1 = RI_2 + LI_2 - U_2  I_2 = dfracU_2-U_1L - dfracRLI_2\n\nfor the current's equation, and\n\n   I_2 C = I_2 - I_3  U_2 = dfracI_3 - I_2C\n\nfor the voltage's equation.\n\nGeneralizing to arbitrary l = 2 ldots η - 1 is trivial and gives:\n\n    boxedI_l = dfracU_l - U_l-1L - dfracRLI_l \n    boxedU_l = dfracI_l+1 - I_lC","category":"section"},{"location":"generated_examples/TransmissionLine/#Analysis-of-the-last-node","page":"Transmission line","title":"Analysis of the last node","text":"The last node corresponds to the case l = η.\n\n    boxedI_η = dfracU_η - U_η-1L - dfracRLI_η \n    boxedU_out = U_out = - dfracI_ηC","category":"section"},{"location":"generated_examples/TransmissionLine/#System-of-linear-differential-equations","page":"Transmission line","title":"System of linear differential equations","text":"Recall that the stateset is mathbbR^2η, where the state variables are x = U_1 U_2 ldots U_η I_1 I_2 ldots I_η^T. The system can be written as a block-diagonal system of linear differential equations,\n\n    x(t) = Ax(t) + BU_in(t)\n\nusing the results in the previous section.\n\nThe coefficients matrix A can be written as a block-diagonal matrix. There are useful constructors in the base package LinearAlgebra that greatly simplify building matrices with special shape, as in our case, such as diagonal and band matrices, with the types Diagonal and Bidiagonal.\n\nWe consider the case of η = 20 nodes as in Althoff et al. [AKS11], such that the system has n = 40 state variables.\n\nusing ReachabilityAnalysis, LinearAlgebra, SparseArrays\n\nfunction tline(; η=3, R=1.00, Rd=10.0, L=1e-10, C=1e-13 * 4.00)\n    A₁₁ = zeros(η, η)\n    A₁₂ = Bidiagonal(fill(-1 / C, η), fill(1 / C, η - 1), :U)\n    A₂₁ = Bidiagonal(fill(1 / L, η), fill(-1 / L, η - 1), :L)\n    A₂₂ = Diagonal(vcat(-Rd / L, fill(-R / L, η - 1)))\n    A = [A₁₁ A₁₂; A₂₁ A₂₂]\n    B = sparse([η + 1], [1], 1 / L, 2η, 1)\n    return A, B\nend\n\nη = 20\nn = 2η\nA, B = tline(; η=η);\nnothing #hide\n\nWe can visualize the structure of the sparse coefficients matrix A for the case η = 20 with a spy plot:\n\nusing Plots\nimport DisplayAs  #hide\n\nfig = spy(A; legend=nothing, markersize=2.0, title=\"Sparsity pattern of A\",\n          xlab=\"columns\", ylab=\"rows\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nNotice that the matrix coefficients are rather large. Hence it is convenient to rescale the system for numerical stability. Let α  0 be a scaling factor, and let tildex(t) = x(α t). By the chain rule,\n\n    tildex(t) = α x(α t) = α A x(α t) + α B U_in(α t)\n    = tildeA tildex(t) + tildeB tildeU_in(t)\n\nwhere tildeA = α A and tildeB = α B.\n\nfunction scale!(s, α=1.0)\n    s.A .*= α\n    s.B .*= α\n    return s\nend;\nnothing #hide\n\nNote that, under this transformation, the time horizon has to be transformed as well, to tildeT = α T.","category":"section"},{"location":"generated_examples/TransmissionLine/#Specification","page":"Transmission line","title":"Specification","text":"The transmission line parameters used in this model are displayed in the following table.\n\nresistance in [Ω] driver resistance in [Ω] Inductance in [H] Capacitance in [F]\nR = 1.00 Rdriver = 10.0 L = 1e−10 C = 4e−13\n\nThe steady state is obtained by zeroing the left-hand side of the differential equation, which gives\n\n   0 = x = Ax_ + Bu_0  x_ = -A^-1 B u_0\n\nThe initial set under consideration corresponds to the steady state for input voltages U_in ss = -02 02. Moreover, an uncertainty is added so that the initial currents are also uncertain. The set of initial states is then\n\n   x(0)  mathcalX_0 = -A^-1 B  U_in ss oplus (0001)\n\nwhere (ϵ) is the infinity-norm ball centered in the origin with radius ϵ.\n\nThe time horizon is chosen as T = 07 nanoseconds. We consider a scaling factor α = 10^-9.\n\nWe are interested in the step response to an input voltage U_in(t) arbitrarily varying over the domain U_in = 099 101 for all t  0 T.\n\nUin_ss = Interval(-0.2, 0.2)\n□(ϵ) = BallInf(zeros(n), ϵ)\nX0 = -inv(Matrix(A)) * B * Uin_ss ⊕ □(0.001)\n\nUin = Interval(0.99, 1.01)\ns = @system(x' = A * x + B * u, x ∈ Universe(n), u ∈ Uin)\nα = 1e-9\nscale!(s, α)\n\nprob = InitialValueProblem(s, X0);\nnothing #hide","category":"section"},{"location":"generated_examples/TransmissionLine/#Analysis","page":"Transmission line","title":"Analysis","text":"We solve the system using a step size δ = 1e-3 and the BOX algorithm.\n\nsol = solve(prob; T=0.7, alg=BOX(; δ=1e-3));\nnothing #hide\n\nTo get the variable U_out, we have to project onto the η-th coordinate and invert the sign of the flowpipe.\n\nUout_vs_t = @. (-1.0) * project(sol, η);\nnothing #hide","category":"section"},{"location":"generated_examples/TransmissionLine/#Results","page":"Transmission line","title":"Results","text":"fig = plot(Uout_vs_t; vars=(0, η), c=:blue, xlab=\"t\", ylab=\"Uout\", alpha=0.5, lw=0.5)\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\ntip: Technical note\nSince we are only interested in the behavior of U_out, we could use an algorithm based on the support function (see, e.g., Girard and Le Guernic [GL08], which can be used as LGG09 in this library), or the decomposition-based algorithm BFFPSV18 with the options alg=BFFPSV18(δ=1e-3, dim=statedim(P), vars=[η])). These options will use an interval (1D) decomposition of the state space and only compute the flowpipe associated with variable η.","category":"section"},{"location":"man/algorithms/INT/#One-dimensional-set-propagation-(INT)","page":"INT","title":"One-dimensional set propagation (INT)","text":"","category":"section"},{"location":"man/algorithms/INT/#Method","page":"INT","title":"Method","text":"","category":"section"},{"location":"man/algorithms/INT/#Examples","page":"INT","title":"Examples","text":"","category":"section"},{"location":"lib/algorithms/ASB07/#ReachabilityAnalysis.ASB07","page":"ASB07","title":"ReachabilityAnalysis.ASB07","text":"ASB07{N, AM, RM, S, R} <: AbstractContinuousPost\n\nImplementation of Althoff - Stursberg - Buss algorithm for reachability of linear systems with uncertain parameters and inputs using zonotopes.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: CorrectionHull(; order=10, exp=:interval))                       approximation model;                       see Notes below for possible options\nmax_order        – (optional, default: 5) maximum zonotope order\nreduction_method – (optional, default: GIR05()) zonotope order reduction method used\nstatic           – (optional, default: false) if true, convert the problem data                       to statically sized arrays\nrecursive        – (optional default: true) if true, use the implementation that                       recursively computes each reach-set; otherwise, use the implementation                       that unwraps the sequence until the initial set\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – type of the approximation model\nRM – type associated to the reduction method\nS  – value type associated to the static option\nR  – value type associated to the recursive option\n\nThe sole parameter which doesn't have a default value is the step-size, associated to the type parameter N.\n\nThe default approximation model is\n\napprox_model=CorrectionHull(order=10, exp=:base)\n\nHere, CorrectionHull refers to an implementation of the interval matrix approximation method described in Althoff et al. [ASB07]. For technicalities on interval matrix operations, we refer to the package IntervalMatrices.jl.\n\nReferences\n\nThe main ideas behind this algorithm can be found in Althoff et al. [ASB07]. These methods are discussed at length in the dissertation [Alt10].\n\nRegarding the zonotope order reduction methods, we refer to Combastel [Com03] and Girard [Gir05] and the review article [YS18].\n\n\n\n\n\n","category":"type"},{"location":"generated_examples/Brusselator/#Brusselator","page":"Brusselator","title":"Brusselator","text":"note: Overview\nSystem type: Polynomial continuous system\nState dimension: 2\nApplication domain: Chemical kinetics","category":"section"},{"location":"generated_examples/Brusselator/#Model-description","page":"Brusselator","title":"Model description","text":"A chemical reaction is said to be autocatalytic if one of the reaction products is also a catalyst for the same or a coupled reaction. We refer to Wikipedia for details.\n\nThe Brusselator is a mathematical model for a class of autocatalytic reactions. The dynamics of the Brusselator is given by the following two-dimensional differential equations.\n\nbeginaligned\n    dotx = A + x^2  y - B  x - x \n    doty = B  x - x^2  y\nendaligned\n\nThe numerical values for the model's constants (in their respective units) are A = 1 B = 15.\n\nusing ReachabilityAnalysis\n\n@taylorize function brusselator!(du, u, p, t)\n    local A = 1.0\n    local B = 1.5\n    local B1 = B + 1\n\n    x, y = u\n\n    x²y = x^2 * y\n    du[1] = A + x²y - B1 * x\n    du[2] = B * x - x²y\n    return du\nend\n\ntip: Performance tip\nThe auxiliary variables B1 and x²y improve the performance of @taylorize.","category":"section"},{"location":"generated_examples/Brusselator/#Specification","page":"Brusselator","title":"Specification","text":"The initial set is x  08 1, y  0 02. The time horizon is 18. These settings are taken from Chen et al. [CAS13].\n\nU₀ = (0.8 .. 1.0) × (0.0 .. 0.2)\nprob = @ivp(u' = brusselator!(u), u(0) ∈ U₀, dim:2)\n\nT = 18.0;\nnothing #hide","category":"section"},{"location":"generated_examples/Brusselator/#Analysis","page":"Brusselator","title":"Analysis","text":"We use the TMJets algorithm with sixth-order expansion in time and second-order expansion in the spatial variables.\n\nalg = TMJets21a(; orderT=6, orderQ=2)\nsol = solve(prob; T=T, alg=alg);\nnothing #hide","category":"section"},{"location":"generated_examples/Brusselator/#Results","page":"Brusselator","title":"Results","text":"using Plots\nimport DisplayAs  #hide\n\nfig = plot(sol; vars=(1, 2), xlab=\"x\", ylab=\"y\", lw=0.2, color=:blue,\n           lab=\"Flowpipe\", legend=:bottomright)\nplot!(fig, U₀; color=:orange, lab=\"U₀\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nWe observe that the system converges to the equilibrium point (10 15).\n\nBelow we plot the projected flowpipes over time.\n\nfig = plot(sol; vars=(0, 1), xlab=\"t\", lw=0.2, color=:blue, lab=\"x(t)\", legend=:bottomright)\nplot!(fig, sol; vars=(0, 2), lw=0.2, color=:red, lab=\"y(t)\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"generated_examples/Brusselator/#Changing-the-initial-volume","page":"Brusselator","title":"Changing the initial volume","text":"The model was considered in Gruenbacher et al. [GCL+20], but using a different set of initial states and a time horizon 30. Let us parametrize the initial states as a square centered at x = y = 1 and radius r  0:\n\nU0(r) = BallInf([1.0, 1.0], r);\nnothing #hide\n\nThe parametric initial-value problem is defined accordingly.\n\nbruss(r) = @ivp(u' = brusselator!(u), u(0) ∈ U0(r), dim:2);\nnothing #hide\n\nFirst we solve for r = 001:\n\nsol_01 = solve(bruss(0.01); T=30.0, alg=alg);\nnothing #hide\n\nold_ztol = LazySets._ztol(Float64)\nLazySets.set_ztol(Float64, 1e-15)  # use higher precision for the plots\n\nfig = plot(sol_01; vars=(1, 2), xlab=\"x\", ylab=\"y\", lw=0.2, color=:blue, lab=\"Flowpipe (r = 0.01)\",\n           legend=:bottomright)\nplot!(fig, U0(0.01); color=:orange, lab=\"Uo\", xlims=(0.6, 1.3))\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nWe observe that the wrapping effect is controlled and the flowpipe does not blow up even for the large time horizon T = 300. Next we plot the flowpipe zoomed to the last portion and compare r = 001 with a larger set of initial states, r = 01.\n\nsol_1 = solve(bruss(0.1); T=30.0, alg=alg);\nnothing #hide\n\nfig = plot(; xlab=\"x\", ylab=\"y\", xlims=(0.9, 1.05), ylims=(1.43, 1.57), legend=:bottomright)\nplot!(fig, sol_1; vars=(1, 2), lw=0.2, color=:red, lab=\"r = 0.1\", alpha=0.4)\nplot!(fig, sol_01; vars=(1, 2), lw=0.2, color=:blue, lab=\"r = 0.01\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nLazySets.set_ztol(Float64, old_ztol);  # reset precision\nnothing #hide\n\nThe volume at time T = 90 can be (over)estimated by evaluating the flowpipe and computing the volume of a hyperrectangular overapproximation:\n\nvol_01 = volume(set(overapproximate(sol_01(9.0), Hyperrectangle)))\n\nvol_1 = volume(set(overapproximate(sol_1(9.0), Hyperrectangle)))","category":"section"},{"location":"lib/clustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"lib/clustering/#Abstract-interface","page":"Clustering","title":"Abstract interface","text":"","category":"section"},{"location":"lib/clustering/#No-clustering","page":"Clustering","title":"No clustering","text":"The following methods are available.","category":"section"},{"location":"lib/clustering/#Lazy-convexification","page":"Clustering","title":"Lazy convexification","text":"","category":"section"},{"location":"lib/clustering/#Box-clustering","page":"Clustering","title":"Box clustering","text":"","category":"section"},{"location":"lib/clustering/#Zonotope-clustering","page":"Clustering","title":"Zonotope clustering","text":"","category":"section"},{"location":"lib/clustering/#Lazy-union","page":"Clustering","title":"Lazy union","text":"","category":"section"},{"location":"lib/clustering/#ReachabilityAnalysis.AbstractClusteringMethod","page":"Clustering","title":"ReachabilityAnalysis.AbstractClusteringMethod","text":"AbstractClusteringMethod{P}\n\nAbstract supertype for all clustering types, with partition of type P.\n\nNotes\n\nA clustering method defines a function which maps reach-sets to one or several reach-sets. The mapping can possibly be over-approximative, i.e. such that the set union of the input reach-sets is included in the set union of the output reach-sets.\n\nBy taking the convex hull of the input reach-sets one can reduce the number of outputs sets to a single one, overapproximately. This is the method that corresponds to the LazyClustering type. However, in some cases it is convenient to do other types of transformations, such as:\n\nReturn several reach-sets that are obtained by grouping the input in a way defined by a partition. For example, a vector of ten input sets can be clustered in two groups of five sets each, or five groups of two sets each, etc.\nUse different set representations such as boxes or zonotopes.\nFurther post-process the output of the convexification by splitting into smaller sets, eg. box splitting.\n\nEach concrete subtype of AbstractClusteringMethod has a parameter P that defines what type of clustering strategy is applied. The method should be accessed with the partition getter function.\n\nThe following strategies are implemented at the interface level:\n\nIf P is of type Missing: no partition is applied\nIf P is of type integer: the partition corresponds to grouping the into the given integer                            number of sets (or as close as possible)\nIf P is of type vector of vectors: the given partition is applied\n\nExamples\n\nLazyClustering([1:2, 3:10]) groups the first two reach-sets in one cluster and the third to tenth reach-sets in another cluster.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/#ReachabilityAnalysis.NoClustering","page":"Clustering","title":"ReachabilityAnalysis.NoClustering","text":"NoClustering{P} <: AbstractClusteringMethod{P}\n\nNo-op clustering method.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/#ReachabilityAnalysis.LazyClustering","page":"Clustering","title":"ReachabilityAnalysis.LazyClustering","text":"LazyClustering{P} <: AbstractClusteringMethod{P}\n\nCluster according to the given partition by applying a lazy representation of the convex hull.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/#ReachabilityAnalysis.BoxClustering","page":"Clustering","title":"ReachabilityAnalysis.BoxClustering","text":"BoxClustering{PI, PO} <: AbstractClusteringMethod{P}\n\nNotes\n\nThis method first takes a lazy convex hull for the given partition, then computes a tight hyperrectangular approximation for each element in the partition.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/#ReachabilityAnalysis.ZonotopeClustering","page":"Clustering","title":"ReachabilityAnalysis.ZonotopeClustering","text":"ZonotopeClustering{P} <: AbstractClusteringMethod{P}\n\nNotes\n\nThis method first takes a lazy convex hull for the given partition, then computes a zonotope overapproximation of the convex hull.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/#ReachabilityAnalysis.UnionClustering","page":"Clustering","title":"ReachabilityAnalysis.UnionClustering","text":"UnionClustering{P} <: AbstractClusteringMethod{P}\n\nCluster according to the given partition by applying a lazy representation of the set union.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/VREP/#Vertex-representation-propagator-(VREP)","page":"VREP","title":"Vertex representation propagator (VREP)","text":"","category":"section"},{"location":"man/algorithms/VREP/#Method","page":"VREP","title":"Method","text":"This algorithm solves the recurrence relation\n\nX_k+1 = Φ X_k oplus V_k\n\nusing the vertex representation of the sets involved. If the system is homogeneous, i.e. V_k =  for all k  0, then the number of vertices of the sequence doesn't increase. On the other hand, the number of vertices of X_k increases hence the method requires doing some conservative reduction strategy.\n\nThe method is aimed towards small dimensional systems – typically n  15 – which show a substantial benefit by using heap-allocated statically sized arrays through the StaticArrays.jl package. To use static arrays, pass the option static=true. Optionally, a dimension field can be passed to the VREP algorithm constructor too using the dim keyword argument. (It is sometimes useful that Julia is able to infer the set representation, or type, of the output flowpipe based only on the algorithm choice, but since the length of a vector is stored as type information for the case of static arrays, it has to be given in advance.)","category":"section"},{"location":"man/algorithms/VREP/#Specifying-the-backend","page":"VREP","title":"Specifying the backend","text":"If the dimension of the system is two, VREP uses efficient algorithms for convex polygons (e.g. convex hull, Minkowski sum) implemented in LazySets.jl. On the other hand, for systems of dimension higher than two, concrete polyhedral computations use the Polyhedra.jl library which itself relies on specific backends, which can be specified with the backend keyword argument in the VREP algorithm constructor. Such backend is used in the discretization phase. Actually, Polyhedra.jl features a default solver (hence it doesn't require additional packages apart from Polyhedra.jl itself), although for efficiency reasons we suggest to use CDDLib.jl. For example, to use CDDLib in a 4-dimensional system, do\n\nusing ReachabilityAnalysis, Polyhedra, CDDLib\n\n# ... define model ...\n# prob = @ivp(...)\nalg = VREP(δ=1e-3, static=true, dim=4, backend=CDDLib.Library())\nsolve(prob, tspan=(0.0, 1.0), alg=alg)\n\nOther backends are available e.g. QHull.jl.","category":"section"},{"location":"generated_examples/Building/#Building","page":"Building model","title":"Building","text":"note: Overview\nSystem type: Linear continuous system\nState dimension: 48\nApplication domain: Mechanical engineering","category":"section"},{"location":"generated_examples/Building/#Model-description","page":"Building model","title":"Model description","text":"The model corresponds to a building (the Los Angeles University Hospital) with 8 floors, each having 3 degrees of freedom, namely displacements in x and y directions, and rotation [ASG01]. These 24 variables evolve according to\n\n    Mddotq(t) + Cdotq(t) + Kq(t) = vu(t)\n\nwhere u(t) is the input. This system can be put into a traditional state-space form of order 48 by defining x = (q dotq)^T. We are interested in the motion of the first coordinate q_1(t), hence we choose v = (1 0 ldots 0)^T and the output y(t) = dotq_1(t) = x_25(t). In canonical form,\n\nbeginaligned\n    dotx(t) = Ax(t) + Bu(t) qquad u(t)  mathcalU \n    y(t) = C x(t)\nendaligned\n\nwhere x(t)  mathbbR^48 is the state vector, mathcalU  mathbbR is the input set, and A  mathbbR^48  48 and B  mathbbR^48  1 are matrices given in the file building.jld2. Here y(t) is the output with C  mathbbR^1  48 being the projection onto the coordinate 25.\n\nThere are two versions of this benchmark:\n\nTime-varying inputs: The inputs can change arbitrarily over time:  forall t u(t)  mathcalU.\nConstant inputs: The inputs are only uncertain in the initial value, and  constant over time: u(0)  mathcalU, dotu(t)= 0\n\nIn both cases, the input set mathcalU is the interval 08 10, and the initial states are taken from Tran et al. [TNJ16], Table 2.2.\n\nusing ReachabilityAnalysis, JLD2, ReachabilityBase.CurrentPath\nusing ReachabilityBase.Arrays: SingleEntryVector\nusing ReachabilityAnalysis: add_dimension\n\nconst x25 = SingleEntryVector(25, 48, 1.0)\nconst x25e = SingleEntryVector(25, 49, 1.0)\n\npath = @current_path(\"Building\", \"building.jld2\")\n\nfunction building_common()\n    @load path A B\n\n    c = [fill(0.000225, 10); fill(0.0, 38)]\n    r = [fill(0.000025, 10); fill(0.0, 14); 0.0001; fill(0.0, 23)]\n    X0 = Hyperrectangle(c, r)\n\n    U = Interval(0.8, 1.0)\n\n    return A, B, X0, U\nend\n\nfunction building_BLDF01()\n    A, B, X0, U = building_common()\n    n = size(A, 1)\n    S = @system(x' = A * x + B * u, u ∈ U, x ∈ Universe(n))\n    prob_BLDF01 = InitialValueProblem(S, X0)\n    return prob_BLDF01\nend\n\nfunction building_BLDC01()\n    A, B, X0, U = building_common()\n    n = size(A, 1)\n    Ae = add_dimension(A)\n    Ae[1:n, end] = B\n    prob_BLDC01 = @ivp(x' = Ae * x, x(0) ∈ X0 × U)\n    return prob_BLDC01\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/Building/#Specification","page":"Building model","title":"Specification","text":"The verification goal is to show that the displacement y_1 of the top floor of the building remains below a given bound. In addition to the safety specification from the original benchmark, there are two UNSAT instances that serve as sanity checks to ensure that the model and the tool work as intended. But there is a caveat: In principle, verifying an UNSAT instance only makes sense formally if a witness is provided (counterexample, underapproximation, etc.). We instead run the tool with the same accuracy settings on an SAT-UNSAT pair of instances. The SAT instance demonstrates that the overapproximation is not too coarse, and the UNSAT instance indicates that the overapproximation is indeed conservative.\n\nBDS01: Bounded time, safe property: For all t  0 20,  y_1(t)  51  10^-3. This property is assumed to be satisfied.\nBDU01: Bounded time, unsafe property: For all t  0 20,  y_1(t)  4  10^-3. This property is assumed to be violated. Property  BDU01 serves as a sanity check. A tool should be run with the same accuracy  settings on BLDF01-BDS01 and BLDF01-BDU01, returning UNSAT on the former  and SAT on the latter.\nBDU02: Bounded time, unsafe property: The forbidden states are  y_1(t)  -078  10^-3 wedge t = 20. This property is assumed to  be violated for BLDF01 and satisfied for BLDC01. Property BDU02 serves as a  sanity check to confirm that time-varying inputs are taken into account. A  tool should be run with the same accuracy settings on BLDF01-BDU02 and  BLDC01-BDU02, returning UNSAT on the former and SAT on the latter.","category":"section"},{"location":"generated_examples/Building/#Analysis-and-results","page":"Building model","title":"Analysis & results","text":"For the discrete-time analysis we use a step size of 001.\n\nusing Plots\nimport DisplayAs  #hide","category":"section"},{"location":"generated_examples/Building/#BLDF01","page":"Building model","title":"BLDF01","text":"prob_BLDF01 = building_BLDF01();\nnothing #hide","category":"section"},{"location":"generated_examples/Building/#Dense-time","page":"Building model","title":"Dense time","text":"sol_BLDF01_dense = solve(prob_BLDF01; T=20.0,\n                         alg=LGG09(; δ=0.004, vars=(25), n=48))\n\nfig = plot(sol_BLDF01_dense; vars=(0, 25), linecolor=:blue, color=:blue,\n           alpha=0.8, lw=1.0, xlab=\"t\", ylab=\"x25\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nSafety properties:\n\n@assert ρ(x25, sol_BLDF01_dense) <= 5.1e-3 \"the property should be proven\"  # BLDF01 - BDS01\n@assert !(ρ(x25, sol_BLDF01_dense) <= 4e-3) \"the property should not be proven\"  # BLDF01 - BDU01\nρ(x25, sol_BLDF01_dense)\n\n@assert !(ρ(x25, sol_BLDF01_dense(20.0)) <= -0.78e-3) \"the property should not be proven\"  # BLDF01 - BDU02\nρ(x25, sol_BLDF01_dense(20.0))","category":"section"},{"location":"generated_examples/Building/#Discrete-time","page":"Building model","title":"Discrete time","text":"sol_BLDF01_discrete = solve(prob_BLDF01; T=20.0,\n                            alg=LGG09(; δ=0.01, vars=(25), n=48, approx_model=NoBloating()));\n\nfig = plot(sol_BLDF01_discrete; vars=(0, 25), linecolor=:blue, color=:blue,\n           alpha=0.8, lw=1.0, xlab=\"t\", ylab=\"x25\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nSafety properties:\n\n@assert ρ(x25, sol_BLDF01_discrete) <= 5.1e-3 \"the property should be proven\"  # BLDF01 - BDS01\n@assert !(ρ(x25, sol_BLDF01_discrete) <= 4e-3) \"the property should not be proven\"  # BLDF01 - BDU01\nρ(x25, sol_BLDF01_discrete)\n\n@assert !(ρ(x25, sol_BLDF01_discrete(20.0)) <= -0.78e-3) \"the property should not be proven\"  # BLDF01 - BDU02\nρ(x25, sol_BLDF01_discrete(20.0))","category":"section"},{"location":"generated_examples/Building/#BLDC01","page":"Building model","title":"BLDC01","text":"prob_BLDC01 = building_BLDC01();\nnothing #hide","category":"section"},{"location":"generated_examples/Building/#Dense-time-2","page":"Building model","title":"Dense time","text":"sol_BLDC01_dense = solve(prob_BLDC01; T=20.0, alg=LGG09(; δ=0.005, vars=(25), n=49))\n\nfig = plot(sol_BLDC01_dense; vars=(0, 25), linecolor=:blue, color=:blue,\n           alpha=0.8, lw=1.0, xlab=\"t\", ylab=\"x25\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nSafety properties\n\n@assert ρ(x25e, sol_BLDC01_dense) <= 5.1e-3 \"the property should be proven\"  # BLDC01 - BDS01\n@assert !(ρ(x25e, sol_BLDC01_dense) <= 4e-3) \"the property should not be proven\"  # BLDC01 - BDU01\nρ(x25e, sol_BLDC01_dense)\n\n@assert !(ρ(x25e, sol_BLDC01_dense(20.0)) <= -0.78e-3) \"the property should not be proven\"  # BLDC01 - BDU02\nρ(x25, sol_BLDF01_discrete(20.0))","category":"section"},{"location":"generated_examples/Building/#Discrete-time-2","page":"Building model","title":"Discrete time","text":"sol_BLDC01_discrete = solve(prob_BLDC01; T=20.0,\n                            alg=LGG09(; δ=0.01, vars=(25), n=49, approx_model=NoBloating()))\n\nfig = plot(sol_BLDC01_discrete; vars=(0, 25), linecolor=:blue, color=:blue,\n           alpha=0.8, lw=1.0, xlab=\"t\", ylab=\"x25\")\n\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nSafety properties\n\n@assert ρ(x25e, sol_BLDC01_discrete) <= 5.1e-3 \"the property should be proven\" # BLDC01 - BDS01\n@assert !(ρ(x25e, sol_BLDC01_discrete) <= 4e-3) \"the property should not be proven\" # BLDC01 - BDU01\nρ(x25e, sol_BLDC01_discrete)\n\n@assert !(ρ(x25e, sol_BLDC01_discrete(20.0)) <= -0.78e-3) \"the property should not be proven\" # BLDC01 - BDU02\nρ(x25e, sol_BLDC01_discrete(20.0))","category":"section"},{"location":"lib/algorithms/A20/#ReachabilityAnalysis.A20","page":"A20","title":"ReachabilityAnalysis.A20","text":"A20{N} <: AbstractContinuousPost\n\nImplementation of the reachability method for large linear systems with uncertain inputs in the Krylov subspace from Althoff [Alt20].\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: FirstOrderZonotope()) approximation model\nmax_order    – (optional, default: 5) maximum zonotope order\n\nReferences\n\nSee Althoff [Alt20] and references therein.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/CARLIN/#CARLIN","page":"CARLIN","title":"CARLIN","text":"","category":"section"},{"location":"lib/algorithms/CARLIN/#ReachabilityAnalysis.CARLIN","page":"CARLIN","title":"ReachabilityAnalysis.CARLIN","text":"CARLIN <: AbstractContinuousPost\n\nImplementation of the reachability method using Carleman linearization from Forets and Schilling [FS21].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/CARLIN/#ReachabilityAnalysis.kron_pow","page":"CARLIN","title":"ReachabilityAnalysis.kron_pow","text":"kron_pow(x::IA.Interval, pow::Int)\n\nGiven an interval x and an integer pow, compute x^pow.\n\nInput\n\nx   – interval\npow – integer\n\nOutput\n\nAn interval enclosure of x^pow.\n\nExamples\n\njulia> [kron_pow(2 .. 3, i) for i in 1:3]\n3-element Array{IntervalArithmetic.Interval{Float64},1}:\n  [2, 3]\n  [4, 9]\n [8, 27]\n\n\n\n\n\nkron_pow(x::Interval, pow::Int)\n\nGiven an interval x and an integer pow, compute x^pow.\n\nInput\n\nx   – interval\npow – integer\n\nOutput\n\nAn interval enclosure of x^pow as a LazySets Interval.\n\n\n\n\n\nkron_pow(H::AbstractHyperrectangle, pow::Int)\n\nGiven hyperrectangular set H and an integer pow, compute the Kronecker power H^{⊗ pow}.\n\nInput\n\nH   – hyperrectangular set\npow – integer power\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nWe compute H^{⊗ pow} where H is a hyperrectangular set by working with H as a product of intervals.\n\nSee also kron_pow which requires DynamicPolynomials.jl.\n\n\n\n\n\nkron_pow(x::Vector{<:AbstractVariable}, pow::Int)\n\nCompute the higher order concrete Kronecker power: x ⊗ x ⊗ ... ⊗ x, pow times for a vector of symbolic monomials.\n\nInput\n\nx   – polynomial variable\npow – integer\n\nOutput\n\nVector of multivariate monomial corresponding to x^{⊗ pow}.\n\nExamples\n\njulia> using DynamicPolynomials\n\njulia> @polyvar x[1:2]\n(PolyVar{true}[x₁, x₂],)\n\njulia> x\n2-element Array{PolyVar{true},1}:\n x₁\n x₂\n\njulia> kron_pow(x, 2)\n4-element Array{Monomial{true},1}:\n x₁²\n x₁x₂\n x₁x₂\n x₂²\n\n\n\n\n\n","category":"function"},{"location":"lib/algorithms/CARLIN/#ReachabilityAnalysis.kron_pow_stack","page":"CARLIN","title":"ReachabilityAnalysis.kron_pow_stack","text":"kron_pow_stack(x::IA.Interval, pow::Int)\n\nReturn a hyperrectangle with the interval powers [x, x^2, …, x^pow].\n\nInput\n\nx   – interval\npow – integer power\n\nOutput\n\nA hyperrectangle such that the i-th dimension is the interval x^i.\n\n\n\n\n\nkron_pow_stack(x::Interval, pow::Int)\n\nReturn a hyperrectangle with the interval powers [x, x^2, …, x^pow].\n\nInput\n\nx   – interval\npow – integer power\n\nOutput\n\nA hyperrectangle such that the i-th dimension is the interval x^i.\n\n\n\n\n\nkron_pow_stack(H::AbstractHyperrectangle, pow::Int)\n\nReturn the Cartesian product array H  H^2    H^pow where H is a hyperrectangular set and H^ i is the i-th Kronecker power of H.\n\nInput\n\nH   – hyperrectangular set\npow – integer power\n\nOutput\n\nA Cartesian product array of hyperrectangles.\n\n\n\n\n\n","category":"function"},{"location":"generated_examples/Spacecraft/#Spacecraft","page":"Spacecraft","title":"Spacecraft","text":"note: Overview\nSystem type: Nonlinear hybrid system\nState dimension: 4 + 1\nApplication domain: Flight dynamics, switched controllers","category":"section"},{"location":"generated_examples/Spacecraft/#Model-description","page":"Spacecraft","title":"Model description","text":"Spacecraft rendezvous is a perfect use case for formal veriﬁcation of hybrid systems with nonlinear dynamics since mission failure can cost lives and is extremely expensive. This benchmark is taken from Chan and Mitra [CM17] but adapted to the settings of ARCH-COMP [GSA+20].\n\nThe nonlinear differential equations describe the two-dimensional, planar motion of the space-craft on an orbital plane towards a space station:\n\nbeginaligned\n    dotx = v_x \n    doty = v_y \n    dotv_x = n^2x + 2nv_y + dfracμr^2 - dfracμr_c^3 (r +x) + dfracu_xm_c \n    dotv_y = n^2y - 2nv_x - dfracμr_c^3y + dfracu_ym_c\nendaligned\n\nThe model consists of a 2D position (relative to the target) x, y [m], time t [min], as well as horizontal and vertical velocity v_x, v_y [m / min]. The parameters are µ = 3986  10^14  60^2 [m^3 / min^2], r = 42164  10^3 [m], m_c = 500 [kg], n = sqrtdfracμr^3 and r_c = sqrt(r + x)^2 + y^2.\n\nThe hybrid nature of this benchmark originates from a switched controller. In particular, the modes are approaching (x  1000 100 [m]), rendezvous attempt (x  100 [m]), and aborting. A transition to mode aborting occurs nondeterministically at t  120 150 [min].\n\nThe linear feedback controllers for the diﬀerent modes are deﬁned as binomu_xu_y = K_1 s for mode approaching, and binomu_xu_y = K_2 s for mode rendezvous attempt, where s = (x y v_x v_y)^T is the vector of system states.  In the mode aborting, the system is uncontrolled: binomu_xu_y = binom00. The feedback matrices K_i were determined with an LQR-approach applied to the linearized system dynamics, which resulted in the following numerical values:\n\nbeginaligned\n    K_1 = beginpmatrix\n        288287  01005  14499754  00046 \n        0087  332562  000462  14515013\n    endpmatrix \n    K_2 = beginpmatrix\n        2880288  01312  96149898  0 \n        01312  288  0  96149883\n    endpmatrix\nendaligned\n\nusing ReachabilityAnalysis  # !jl\n\nconst μ = 3.986e14 * 60^2\nconst r = 42164.0e3\nconst r² = r^2\nconst mc = 500.0\nconst n² = μ / r^3\nconst n = sqrt(n²)\n\nconst two_n = 2 * n\nconst μ_r² = μ / r²\n\nconst K₁ = [-28.8287 0.1005 -1449.9754 0.0046 0.0;\n            -0.087 -33.2562 0.00462 -1451.5013 0.0]\nconst K₂ = [-288.0288 0.1312 -9614.9898 0.0 0.0;\n            -0.1312 -288.0 0.0 -9614.9883 0.0]\n\nconst K₁mc = K₁ / mc\nconst K₂mc = K₂ / mc\n\nfunction mymul!(v, A, x)  # helper function for matrix-vector multiplication\n    @inbounds for ind in eachindex(v)\n        v[ind] = zero(x[1])\n        for jind in eachindex(x)\n            v[ind] += A[ind, jind] * x[jind]\n        end\n    end\n    return nothing\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/Spacecraft/#Dynamics-in-the-*approaching*-mode","page":"Spacecraft","title":"Dynamics in the approaching mode","text":"@taylorize function spacecraft_approaching!(du, u, p, time)\n    x, y, vx, vy, t = u\n\n    rx = r + x\n    rx² = rx^2\n    y² = y^2\n    rc = sqrt(rx² + y²)\n    rc³ = rc^3\n    μ_rc³ = μ / rc³\n\n    uxy = Vector{typeof(x)}(undef, 2)\n    mymul!(uxy, K₁mc, u)\n\n    # x' = vx\n    du[1] = vx\n\n    # y' = vy\n    du[2] = vy\n\n    # vx' = n²x + 2n*vy + μ/(r^2) - μ/(rc^3)*(r+x) + ux/mc\n    du[3] = (n² * x + two_n * vy) + ((μ_r² - μ_rc³ * rx) + uxy[1])\n\n    # vy' = n²y - 2n*vx - μ/(rc^3)y + uy/mc\n    du[4] = (n² * y - two_n * vx) - (μ_rc³ * y - uxy[2])\n\n    # t' = 1\n    du[5] = one(t)\n\n    return du\nend","category":"section"},{"location":"generated_examples/Spacecraft/#Dynamics-in-the-*rendezvous-attempt*-mode","page":"Spacecraft","title":"Dynamics in the rendezvous attempt mode","text":"@taylorize function spacecraft_attempt!(du, u, p, time)\n    x, y, vx, vy, t = u\n\n    rx = r + x\n    rx² = rx^2\n    y² = y^2\n    rc = sqrt(rx² + y²)\n    rc³ = rc^3\n    μ_rc³ = μ / rc³\n\n    uxy = Vector{typeof(x)}(undef, 2)\n    mymul!(uxy, K₂mc, u)\n\n    # x' = vx\n    du[1] = vx\n\n    # y' = vy\n    du[2] = vy\n\n    # vx' = n²x + 2n*vy + μ/(r^2) - μ/(rc^3)*(r+x) + ux/mc\n    du[3] = (n² * x + two_n * vy) + ((μ_r² - μ_rc³ * rx) + uxy[1])\n\n    # vy' = n²y - 2n*vx - μ/(rc^3)y + uy/mc\n    du[4] = (n² * y - two_n * vx) - (μ_rc³ * y - uxy[2])\n\n    # t' = 1\n    du[5] = one(t)\n\n    return du\nend","category":"section"},{"location":"generated_examples/Spacecraft/#Dynamics-in-the-*aborting*-mode","page":"Spacecraft","title":"Dynamics in the aborting mode","text":"@taylorize function spacecraft_aborting!(du, u, p, time)\n    x, y, vx, vy, t = u\n\n    rx = r + x\n    rx² = rx^2\n    y² = y^2\n    rc = sqrt(rx² + y²)\n    rc³ = rc^3\n    μ_rc³ = μ / rc³\n\n    # x' = vx\n    du[1] = vx\n\n    # y' = vy\n    du[2] = vy\n\n    # vx' = n²x + 2n*vy + μ/(r^2) - μ/(rc^3)*(r+x)\n    du[3] = (n² * x + two_n * vy) + (μ_r² - μ_rc³ * rx)\n\n    # vy' = n²y - 2n*vx - μ/(rc^3)y\n    du[4] = (n² * y - two_n * vx) - μ_rc³ * y\n\n    # t' = 1\n    du[5] = one(t)\n\n    return du\nend","category":"section"},{"location":"generated_examples/Spacecraft/#Hybrid-system","page":"Spacecraft","title":"Hybrid system","text":"To model the system as a hybrid automaton, it is useful to work with symbolic state variables.\n\nusing Symbolics\n\nconst var = @variables x y vx vy t\n\nfunction spacecraft(; abort_time=(120.0, 150.0))\n    n = 4 + 1  # number of variables\n    t_abort_lower, t_abort_upper = abort_time\n\n    automaton = GraphAutomaton(3)\n\n    # mode 1 (approaching)\n    invariant = HalfSpace(x <= -100, var)\n    approaching = @system(x' = spacecraft_approaching!(x), dim:5, x ∈ invariant)\n\n    # mode 2 (rendezvous attempt)\n    invariant = HalfSpace(x >= -100, var)\n    attempt = @system(x' = spacecraft_attempt!(x), dim:5, x ∈ invariant)\n\n    # mode 3 (aborting)\n    invariant = Universe(n)\n    aborting = @system(x' = spacecraft_aborting!(x), dim:5, x ∈ invariant)\n\n    # transition \"approach\" -> \"rendezvous attempt\"\n    add_transition!(automaton, 1, 2, 1)\n    guard = HalfSpace(x >= -100, var)\n    t1 = @map(x -> x, dim:n, x ∈ guard)\n\n    # transition \"approach\" -> \"abort\"\n    add_transition!(automaton, 1, 3, 2)\n    guard_time = HPolyhedron([t >= t_abort_lower, t <= t_abort_upper], var)\n    t2 = @map(x -> x, dim:n, x ∈ guard_time)\n\n    # transition \"rendezvous attempt\" -> \"abort\"\n    add_transition!(automaton, 2, 3, 3)\n    t3 = @map(x -> x, dim:n, x ∈ guard_time)\n\n    H = HybridSystem(; automaton=automaton,\n                     modes=[approaching, attempt, aborting],\n                     resetmaps=[t1, t2, t3])\n\n    # initial condition in mode 1\n    X0 = Hyperrectangle([-900.0, -400, 0, 0, 0], [25.0, 25, 0, 0, 0])\n    init = [(1, X0)]\n\n    return InitialValueProblem(H, init)\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/Spacecraft/#Specification","page":"Spacecraft","title":"Specification","text":"The spacecraft starts from the initial set x  925 875 [m], y  425 375 [m], vx = 0 [m/min], and vy = 0 [m/min]. For the considered time horizon of t  0 200 [min], the following speciﬁcations have to be satisﬁed:\n\nLine-of-sight: In mode rendezvous attempt, the spacecraft has to stay inside the line-of-sight cone L = binomxy  (x  100)  (y  x tan(30))  (y  x tan(30)).\nCollision avoidance: In mode aborting, the spacecraft has to avoid a collision with the target, which is modeled as a box B with 02 [m] edge length and the center placed at the origin.\nVelocity constraint: In mode rendezvous attempt, the absolute velocity has to stay below 33 [m/min]: sqrtv^2_x + v^2_y  33 [m/min].\n\nnote: Remark on velocity constraint\nIn the original benchmark [CM17], the constraint on the velocity was set to 0.05 m/s, but it can be shown (by a counterexample) that this constraint cannot be satisﬁed. We therefore use the relaxed constraint to 0055 [m/s] = 33 [m/min].\n\nconst tan30 = tand(30)\n\nLineOfSightCone = HPolyhedron([x >= -100, y >= x * tan30, -y >= x * tan30], var)\n\ntarget = BallInf(zeros(2), 0.2)\n\nfunction line_of_sight(sol)\n    all_idx = findall(x -> x == 2, location.(sol))  # \"rendezvous attempt\" mode\n    for idx in all_idx\n        if !all(set(R) ⊆ LineOfSightCone for R in sol[idx][2:end])\n            return false\n        end\n    end\n    return true\nend\n\nfunction collision_avoidance(sol)\n    all_idx = findall(x -> x == 3, location.(sol))  # \"aborting\" mode\n    for idx in all_idx\n        if !all(isdisjoint(set(Projection(R, [1, 2])), target) for R in sol[idx])\n            (set(Projection(R, [1, 2])) for R in sol[idx])\n            return false\n        end\n    end\n    return true\nend\n\nfunction absolute_velocity(R)\n    vx, vy = 3, 4\n    vx2 = set(overapproximate(project(R; vars=(vx,)), Interval))\n    vy2 = set(overapproximate(project(R; vars=(vy,)), Interval))\n    return sqrt(vx2.dat + vy2.dat)\nend\n\nfunction velocity_constraint(sol)\n    all_idx = findall(x -> x == 2, location.(sol))  # \"rendezvous attempt\" mode\n    for idx in all_idx\n        # maximum velocity measured in m/min\n        if !all(absolute_velocity(R) < 0.055 * 60.0 for R in sol[idx])\n            return false\n        end\n    end\n    return true\nend;\nnothing #hide","category":"section"},{"location":"generated_examples/Spacecraft/#Analysis","page":"Spacecraft","title":"Analysis","text":"The transition to the aborting mode is handled by clustering the flowpipe into 25 boxes.\n\nfunction solve_spacecraft(prob; k=25, s=missing)\n    # transition from mode 1 to mode 2\n    sol12 = solve(prob;\n                  tspan=(0.0, 200.0),\n                  alg=TMJets21a(; abstol=1e-5, maxsteps=10_000, orderT=5, orderQ=1,\n                                disjointness=BoxEnclosure()),\n                  max_jumps=1,\n                  intersect_source_invariant=false,\n                  intersection_method=TemplateHullIntersection(BoxDirections(5)),\n                  clustering_method=LazyClustering(1),\n                  disjointness_method=BoxEnclosure())\n    sol12jump = overapproximate(sol12[2](120 .. 150), Zonotope)\n    t0 = tstart(sol12jump[1])\n    sol12jump_c = cluster(sol12jump, 1:length(sol12jump), BoxClustering(k, s))\n\n    # transition from mode 2 to mode 3\n    H = system(prob)\n    sol3 = solve(IVP(mode(H, 3), [set(X) for X in sol12jump_c]);\n                 tspan=(t0, 200.0),\n                 alg=TMJets21a(; abstol=1e-10, orderT=7, orderQ=1, disjointness=BoxEnclosure()))\n    d = Dict{Symbol,Any}(:loc_id => 3)\n    F12 = [fp for fp in sol12.F]\n    F23 = [Flowpipe(fp.Xk, d) for fp in sol3.F]\n    return HybridFlowpipe(vcat(F12, F23))\nend\n\nprob = spacecraft()\nsol = solve_spacecraft(prob; k=25, s=missing)\nsolz = overapproximate(sol, Zonotope);\nnothing #hide\n\nNow we verify the specification. Verifying the collision avoidance requires more effort, so here we do not manage to prove this property.\n\n@assert line_of_sight(solz) \"the property should be proven\"\n@assert !collision_avoidance(solz) \"the property cannot be proven with these settings\"\n@assert velocity_constraint(solz) \"the property should be proven\"","category":"section"},{"location":"generated_examples/Spacecraft/#Results","page":"Spacecraft","title":"Results","text":"using Plots, Plots.PlotMeasures, LaTeXStrings\nimport DisplayAs  #hide\n\nfig = plot(solz; vars=(1, 2), xlab=\"x\", ylab=\"y\")\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  #hide\n\nNote that in the previous plot, it is not specified which reach set corresponds to which mode. After finding the location (mode of the hybrid system) associated to each reach set of the solution, we can plot each one using different colors. The plotting code is more sophisticated than before, and is an example of finer control of the options used to plot the flowpipes.\n\nidx_approaching = findall(x -> x == 1, location.(solz))\nidx_attempt = findall(x -> x == 2, location.(solz))\nidx_aborting = findall(x -> x == 3, location.(solz))\n\nfig = plot(; legend=:bottomright, tickfont=font(10, \"Times\"), guidefontsize=15,\n           xlab=L\"x\", ylab=L\"y\", lw=0.0, xtick=[-750, -500, -250, 0, 250.0],\n           ytick=[-400, -300, -200, -100, 0.0], xlims=(-1000.0, 400.0), ylims=(-450.0, 0.0),\n           size=(600, 600), bottom_margin=6mm, left_margin=2mm, right_margin=4mm, top_margin=3mm)\n\nplot!(fig, solz[idx_approaching[1]]; vars=(1, 2), lw=0.0, color=:lightgreen, alpha=1,\n      lab=\"Approaching\")\nfor k in idx_approaching[2:end]\n    plot!(fig, solz[k]; vars=(1, 2), lw=0.0, color=:lightgreen, alpha=1)\nend\n\nplot!(fig, solz[idx_attempt[1]]; vars=(1, 2), lw=0.0, color=:red, alpha=1, lab=\"Attempt\")\nfor k in idx_attempt[2:end]\n    plot!(fig, solz[k]; vars=(1, 2), lw=0.0, color=:red, alpha=1)\nend\n\nplot!(fig, solz[idx_aborting[1]]; vars=(1, 2), lw=0.0, color=:cyan, alpha=1, lab=\"Aborting\")\nfor k in idx_aborting[2:end]\n    plot!(fig, solz[k]; vars=(1, 2), lw=0.0, color=:cyan, alpha=1)\nend\n\nfig\n\nfig = DisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"lib/algorithms/QINT/#ReachabilityAnalysis.QINT","page":"QINT","title":"ReachabilityAnalysis.QINT","text":"QINT{N, AM} <: AbstractContinuousPost\n\nReachability method for one-dimensional quadratic ODEs with non-deterministic inputs.\n\nFields\n\nThe type fields are:\n\nN   – number type of the step-size\nAM  – type of the approximation model\n\nNotes\n\n\n\n\n\n","category":"type"},{"location":"man/faq/#Frequently-Asked-Questions-(FAQ)","page":"Frequently Asked Questions (FAQ)","title":"Frequently Asked Questions (FAQ)","text":"","category":"section"},{"location":"man/faq/#General-questions","page":"Frequently Asked Questions (FAQ)","title":"General questions","text":"","category":"section"},{"location":"man/faq/#What-are-good-introductory-papers-on-the-subject?","page":"Frequently Asked Questions (FAQ)","title":"What are good introductory papers on the subject?","text":"An elementary introduction to the principles of set-based numerical integration can be found in Oded Maler's article Computing Reachable Sets: An Introduction. For an introduction to hybrid systems reachability we recommend the lecture notes of Prof. Goran Frehse, Formal Verification of Piecewise Affine Hybrid Systems (DigiCosme Spring School, Paris, May 2016). Most up-to-date material related to reachability analysis can be found in journals, conference articles or in PhD theses. For a comprehensive review of different set propagation techniques for linear, nonlinear and hybrid systems see Althoff et al. [AFG21]. The article also contains a discussion of successful applications of reachability analysis to real-world problems. We refer to the References section of this manual for further links to the relevant literature.","category":"section"},{"location":"man/faq/#Are-there-other-tools-that-perform-reachability-analysis?","page":"Frequently Asked Questions (FAQ)","title":"Are there other tools that perform reachability analysis?","text":"The wiki Related Tools contains an extensive list of pointers related to reachability analysis tools for dynamical systems. Languages and tools for hybrid systems design are described in the review article [CPPS06] (a bit outdated with respect to the tools since it is of 2006).\n\nA subset of such tools has participated in recent editions of the Friendly Competition for Applied Reachability of Continuous and Hybrid Systems, ARCH-COMP. In alphabetic order: Ariadne, CORA, C2E2, DynIbex, Flow*, HyDRA, Hylaa, Isabelle/HOL-ODE-Numerics, SpaceEx and XSpeed. A paragraph describing each tool's main characteristics can be found in the ARCH-COMP articles for each category (AFF for linear and NLN for nonlinear).\n\nThe IEEE Control Systems Society (CSS) has a Technical Committee on Hybrid Systems that is dedicated to providing informational forums, meetings for technical discussion, and information over the web to researchers in the IEEE CSS who are interested in the field of hybrid systems and its applications. A list of actively-maintained tools for the analysis and synthesis of hybrid systems, compiled by members of such committee, can be found here.","category":"section"},{"location":"man/faq/#Why-did-you-choose-Julia-to-write-this-library?","page":"Frequently Asked Questions (FAQ)","title":"Why did you choose Julia to write this library?","text":"The language choice when programming for research purposes usually depends on the developers' background knowledge which directly impacts convenience during development and output performance in the final product. On the one hand, compiled languages such as C++ offer high performance, but the compilation overhead is inconvenient for prototyping. On the other hand, interpreted languages such as Python offer an interactive session for convenient prototyping, but these languages fall behind in performance or need to extend the code to work with another lower-layer program such as Numba or Cython (known as the two-language problem). A compromise between the two worlds are just-in-time (JIT) compiled languages such as MATLAB. Last but not least, the ecosystem of libraries available and the user base is also an important consideration.\n\nIn our case, we began to develop the JuliaReach stack in 2017 and quickly adopted the language when it was at its v0.5 [v1]. Julia is a general-purpose programming language but it was conceived with high-performance scientific computing in mind, and it reconciles the two advantages of compiled and interpreted languages described above, as it comes with an interactive read-evaluate-print loop (REPL) front-end, but is JIT compiled to achieve performance that is competitive with compiled languages such as C [BEKS17]. A distinctive feature of Julia is multiple dispatch (i.e., the function to execute is chosen based on each argument type), which allows to write efficient machine code based on a given type, e.g., of the set. As additional features, Julia is platform independent, has an efficient interface to C and FORTRAN, is supported in Jupyter notebooks (the \"Ju\" in Jupyter is for Julia) and well-suited for parallel computing. Julia has a determined and quickly-growing community, especially for scientific tools (see the JuliaLang Community webpage). All this makes Julia an interesting programming language for writing a library for reachability analysis.","category":"section"},{"location":"man/faq/#What-is-the-wrapping-effect?","page":"Frequently Asked Questions (FAQ)","title":"What is the wrapping effect?","text":"Quoting the famous paper Moore [Moo65]:\n\nUnder the flow itself a box is carried after certain time into a set of points which will in general not remain a box excepted for a few simple flows.\n\nThe wrapping effect is associated to error propagation that arises from the inability of a set representation to accurately abstract some properties of system under study. Wrapping-free methods only exist for linear systems. Nonlinear reachability methods control, but do not totally elimitate, the wrapping effect in different ways.\n\nAs a simple illustration of the wrapping effect, consider the image of a box through a rotation in discrete time-steps. Box enclosures (full line) introduce a strong wrapping effect. On the other hand, had we represented the sequence using zonotopes (dashed lines), the result would be exact, i.e. without wrapping, since the image of a hyperrectangular set under an affine map is a zonotope.\n\nusing LazySets, Plots\n\nR(θ) = [cos(θ) -sin(θ); sin(θ) cos(θ)]\n\nB = BallInf(ones(2), 0.1)\nB′ = R(π/4) * B\nB′′ = R(π/2) * B\n\n□B = box_approximation(B)\n□B′ = box_approximation(B′)\n□B′′ = box_approximation(R(π/4) * □B′)\n\nfig = plot(B, ratio=1, lw=2.0, style=:dash)\nplot!(B′, lw=2.0, style=:dash)\nplot!(B′′, lw=2.0, style=:dash)\n\nplot!(□B, lw=2.0, style=:solid)\nplot!(□B′, lw=2.0, style=:solid)\nplot!(□B′′, lw=2.0, style=:solid)\n\nimport DisplayAs  # hide\nDisplayAs.Text(DisplayAs.PNG(fig))  # hide","category":"section"},{"location":"man/faq/#Does-reachability-solve-for-the-vertices-of-the-set?","page":"Frequently Asked Questions (FAQ)","title":"Does reachability solve for the vertices of the set?","text":"","category":"section"},{"location":"man/faq/#What-happens-if-you-consider-a-chaotic-system?","page":"Frequently Asked Questions (FAQ)","title":"What happens if you consider a chaotic system?","text":"","category":"section"},{"location":"man/faq/#Can-reachability-analysis-be-used-to-solve-large-problems?","page":"Frequently Asked Questions (FAQ)","title":"Can reachability analysis be used to solve large problems?","text":"","category":"section"},{"location":"man/faq/#Solving-capabilities","page":"Frequently Asked Questions (FAQ)","title":"Solving capabilities","text":"","category":"section"},{"location":"man/faq/#How-can-I-visualize-trajectories?","page":"Frequently Asked Questions (FAQ)","title":"How can I visualize trajectories?","text":"It is often necessary to plot a \"bunch\" of trajectories starting from a set of initial conditions. The parallel ensemble simulations capabilities from the Julia OrdinaryDiffEq.jl suite can be used to numerically simulate a given number of trajectories and it counts with state-of-the-art algorithms for stiff and non-stiff ODEs as well as many other advanced features, such as distributed computing, multi-threading and GPU support. See EnsembleAlgorithms for details.\n\nAs a simple example consider the scalar ODE x(t) = 101x(t) with initial condition on the interval x(0)  0 05. To solve it using ensemble simulations, pass the ensemble=true keyword argument to the solve function (if the library OrdinaryDiffEq was not loaded in your current session, an error is triggered). The number of trajectories can be specified with the trajectories keyword argument.\n\nusing ReachabilityAnalysis, OrdinaryDiffEq\n\n# formulate initial-value problem\nprob = @ivp(x' = 1.01x, x(0) ∈ 0 .. 0.5)\n\n# solve the flowpipe using a default algorithm, and also compute trajectories\nsol = solve(prob, tspan=(0.0, 1.0), ensemble=true, trajectories=250)\n\n# plot flowpipe and the ensemble solution\nusing Plots\n\nfig = plot(sol, vars=(0, 1), linewidth=0.2, xlab=\"t\", ylab=\"x(t)\")\nplot!(ensemble(sol), vars=(0, 1), linealpha=1.0)\n\nimport DisplayAs  # hide\nDisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nPlease note that the latency (compilation time) of the first using line is long, typically one minute with Julia v1.5.3.","category":"section"},{"location":"man/faq/#Can-I-solve-a-for-a-single-initial-condition?","page":"Frequently Asked Questions (FAQ)","title":"Can I solve a for a single initial condition?","text":"To solve for a single initial condition, i.e. a \"point\", use Singleton as the initial set (singleton means a set with one element). For example, here we plot the free vibration solution of a standard single degree of freedom system without physical damping,\n\n    x(t) + 4x(t) = 0 qquad x(0) = 1qquad x(0) = 0\n\nIn this initial-value problem, the initial condition is given as a point that we can model as X0 = Singleton([1.0, 0.0]), where we associate the first coordinate to position, x(t), and the second coordinate to velocity, x'(t).\n\nnote: Note\nUsual Julia vectors such as X0 = [1.0, 0.0] are also valid input, and are treated as a singleton. It is also valid to use tuples in second order systems, e.g. prob = @ivp(X' = A * X, X(0) ∈ ([1.0], [0.0])).\n\nBelow we plot the flowpipe for the same initial condition and different step sizes.\n\nusing ReachabilityAnalysis, Plots\n\n# x' = v\n# v' = -4x\nA = [0 1; -4. 0]\nX0 = Singleton([1.0, 0.0])\nprob = @ivp(X' = A * X, X(0) ∈ X0)\n\nf(ΔT) = solve(prob, tspan=(0.0, 5.0), alg=GLGM06(δ=ΔT))\n\nfig = plot(f(0.3), vars=(0, 1), lab=\"ΔT=0.3\", color=:yellow)\nplot!(f(0.1), vars=(0, 1), lab=\"ΔT=0.1\", color=:lightblue)\nplot!(f(0.05), vars=(0, 1), xlab=\"time\", ylab=\"x(t)\", lab=\"ΔT=0.05\", color=:green)\n\ndom = 0:0.01:5.0\nplot!(dom, cos.(2.0 * dom), lab=\"Analytic\", color=:magenta)\n\nimport DisplayAs  # hide\nDisplayAs.Text(DisplayAs.PNG(fig))  # hide","category":"section"},{"location":"man/faq/#Why-do-I-see-boxes-for-single-initial-conditions?","page":"Frequently Asked Questions (FAQ)","title":"Why do I see boxes for single initial conditions?","text":"As it is seen in the question Can I solve a for a single initial condition?, even if the initial condition is a singleton, the obtained flowpipe is a sequence of boxes in the x-t plane, i.e. we obtain sets with non-zero width both in time and in space. This behavior may seem confusing at first, because the initial conditions where deterministic. The catch is that reach-sets represents a set of states reachable over a time interval, that certainly contains the exact solution for the time-span associated to the reach-set, tspan(R). The projection of the flowpipe on the time axis thus returns a sequence of intervals, their width being the step size of the method (in case the method has fixed step size). When we take the Cartesian product of each time span with the projection of the flowpipe in x(t), we obtain a box.\n\nIf we consider two different step-sizes, the area of the boxes shrinks. It is known theoretically that the flowpipe converges, in Hausdorff norm, to the exact flowpipe. The plot below illustrates the convergence for aspects for two different step sizes, ΔT=0.1 and ΔT=0.05, evaluating the solution around the time point 3.0. The projection onto x(t) (vertical axis) shows that dividing the step size by half, we can more accurately know the exact value of the solution, and the width of the boxes intersecting the time point 3.0 decrease by a factor 2.5x.\n\nfig = plot(f(0.1)(3.0), vars=(0, 1), xlab=\"time\", ylab=\"x(t)\", lab=\"ΔT=0.1\", color=:lightblue)\n\nI(Δt, t) = -ρ([-1.0, 0.0], f(Δt)(t)) .. ρ([1.0, 0.0], f(Δt)(t)) |> Interval\n\nI01 = I(0.1, 3.0)\nplot!(y -> max(I01), xlims=(2.9, 3.1), lw=3.0, style=:dash, color=:lightblue, lab=\"Δx = $(I01.dat)\")\nplot!(y -> min(I01), xlims=(2.9, 3.1), lw=3.0, style=:dash, color=:lightblue, lab=\"\")\nplot!(f(0.05)(3.0), vars=(0, 1), xlab=\"time\", ylab=\"x(t)\", lab=\"ΔT=0.05\", color=:green)\n\nI005 = I(0.05, 3.0)\nplot!(y -> max(I005), xlims=(2.9, 3.1), lw=3.0, style=:dash, color=:green, lab=\"Δx = $(I005.dat)\")\nplot!(y -> min(I005), xlims=(2.9, 3.1), lw=3.0, style=:dash, color=:green, lab=\"\")\n\ndom = 2.9:0.01:3.1\nplot!(dom, cos.(2.0 * dom), lab=\"Analytic\", color=:magenta, legend=:bottomright)\n\nimport DisplayAs  # hide\nDisplayAs.Text(DisplayAs.PNG(fig))  # hide","category":"section"},{"location":"man/faq/#Why-do-some-trajectories-escape-the-flowpipe?","page":"Frequently Asked Questions (FAQ)","title":"Why do some trajectories escape the flowpipe?","text":"","category":"section"},{"location":"man/faq/#Can-I-compute-solutions-using-parallel-programming?","page":"Frequently Asked Questions (FAQ)","title":"Can I compute solutions using parallel programming?","text":"Yes. You can compute multiple flowpipes in parallel by defining an initial-value problem with an array of initial conditions. This methods uses Julia's multithreaded parallelism, so you have to set the number of threads to use before starting Julia. The following example illustrates this point. For further details we refer to the section Distributed computations.\n\nusing ReachabilityAnalysis, Plots\n\nA = [0.0 1.0; -1.0 0.0]\n\nB = [BallInf([0,0.] .+ k, 0.1) for k in 1:5]\nprob = @ivp(x' = A * x, x(0) ∈ B)\n\n# multi-threaded solve\nsol = solve(prob, T=12.0, alg=GLGM06(δ=0.02));\nfig = plot(sol, vars=(0, 2), c=:red, alpha=.5, lw=0.2, xlab=\"t\", ylab=\"y\")\n\nimport DisplayAs  # hide\nDisplayAs.Text(DisplayAs.PNG(fig))  # hide\n\nOn the other hand, please note that in the example of above, you can compute with a single integration the flowpipe corresponding to the convex hull of the elements in the array B.\n\nprob = @ivp(x' = A * x, x(0) ∈ ConvexHullArray(B))\nsol = solve(prob, T=12.0, alg=GLGM06(δ=0.02, approx_model=Forward()));\nplot!(sol, vars=(0, 2), c=:lightgreen, alpha=.5, lw=0.2, xlab=\"t\", ylab=\"y\")\n\nimport DisplayAs  # hide\nDisplayAs.Text(DisplayAs.PNG(fig))  # hide","category":"section"},{"location":"man/faq/#Modeling-questions","page":"Frequently Asked Questions (FAQ)","title":"Modeling questions","text":"","category":"section"},{"location":"man/faq/#Can-I-use-ODE-solvers-with-interval-initial-conditions?","page":"Frequently Asked Questions (FAQ)","title":"Can I use ODE solvers with interval initial conditions?","text":"Although it is in principle possible to use ODE solvers for interval initial conditions, standard ODE solvers from packages like OrdinaryDiffEq.jl are designed to work with point-valued (deterministic) initial conditions. To handle sets of initial conditions, you have several options:\n\nEnsemble simulations: Use the ensemble capabilities (see How can I visualize trajectories?) to simulate multiple trajectories from points sampled within the interval. This gives you trajectory-based approximations but not rigorous set enclosures.\nReachability analysis: Use the reachability algorithms provided by this package (e.g., GLGM06, TMJets, LGG09) which are specifically designed to propagate sets of initial conditions and compute rigorous enclosures of all reachable states. Taylor model-based methods like TMJets employ rigorous interval arithmetic to handle interval initial conditions directly while controlling the wrapping effect.\n\nFor rigorous verification and safety analysis, reachability methods are preferred over sampling-based approaches as they provide guaranteed enclosures of all possible behaviors.","category":"section"},{"location":"man/faq/#How-do-I-use-the-@taylorize-macro?","page":"Frequently Asked Questions (FAQ)","title":"How do I use the @taylorize macro?","text":"The section Some common gotchas of the user manual details do's and dont's for the @taylorize macro to speedup reachability computations using Taylor models.","category":"section"},{"location":"man/faq/#A-note-on-interval-types","page":"Frequently Asked Questions (FAQ)","title":"A note on interval types","text":"When using intervals as set representation, ReachabilityAnalysis.jl relies on rigorous floating-point arithmetic implemented in pure Julia in the library IntervalArithmetic.jl (we often use const IA = IntervalArithmetic as an abbreviation). The main struct defined in the library is IA.Interval (and the corresponding multi-dimensional interval is IA.IntervalBox). Internally, the set LazySets.Interval is wrapper-type of IA.Interval and these two types should not be confused, although our user APIs extensively use duck typing, in the sense that x(0) ∈ 0 .. 1 (IA.Interval type) and x(0) ∈ Interval(0, 1) are valid.\n\nOn a technical level, the reason to have LazySets.Interval as a wrapper type of IA.Interval is that Julia doesn't allow multiple inheritance, but it was a design choice that intervals should belong to the LazySets type hierarchy.","category":"section"},{"location":"man/faq/#References","page":"Frequently Asked Questions (FAQ)","title":"References","text":"[v1]: Version 1.0 of the language was released in August 2018; see this blog post.","category":"section"},{"location":"lib/flowpipes/#Flowpipes","page":"Flowpipes","title":"Flowpipes","text":"","category":"section"},{"location":"lib/flowpipes/#Abstract-interface","page":"Flowpipes","title":"Abstract interface","text":"The following functions are available at the interface level.","category":"section"},{"location":"lib/flowpipes/#Flowpipe","page":"Flowpipes","title":"Flowpipe","text":"The following methods are available.","category":"section"},{"location":"lib/flowpipes/#Hybrid-flowpipe","page":"Flowpipes","title":"Hybrid flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#Mixed-flowpipe","page":"Flowpipes","title":"Mixed flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#Shifted-flowpipe","page":"Flowpipes","title":"Shifted flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#Mapped-flowpipe","page":"Flowpipes","title":"Mapped flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#ReachabilityAnalysis.AbstractFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.AbstractFlowpipe","text":"AbstractFlowpipe\n\nAbstract type representing a flowpipe.\n\nNotes\n\nA flowpipe is the set union of an array of reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#LazySets.API.ρ-Tuple{AbstractVector, ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.API.ρ","text":"LazySets.ρ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support function of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.API.σ-Tuple{AbstractVector, ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.API.σ","text":"LazySets.σ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support vector of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.API.dim-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.API.dim","text":"LazySets.dim(fp::AbstractFlowpipe)\n\nInput\n\nfp – flowpipe\n\nOutput\n\nAn integer representing the ambient dimension of the flowpipe.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.set-Tuple{ReachabilityAnalysis.AbstractFlowpipe, Integer}","page":"Flowpipes","title":"LazySets.set","text":"set(fp::AbstractFlowpipe, ind::Integer)\n\nReturn the geometric set represented by this flowpipe at the given index.\n\nInput\n\nfp  – flowpipe\nind – index (from 1 to length(flowpipe))\n\nOutput\n\nThe set wrapped by the flowpipe at the given index.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.set-Tuple{ReachabilityAnalysis.AbstractFlowpipe, AbstractVector}","page":"Flowpipes","title":"LazySets.set","text":"set(fp::AbstractFlowpipe, ind::AbstractVector)\n\nReturn the union of set represented by this flowpipe at the given indices.\n\nInput\n\nfp  – flowpipe\nind – vector of indices\n\nOutput\n\nThe set union stored in the flowpipe at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.set-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.set","text":"set(fp::AbstractFlowpipe)\n\nReturn the geometric set represented by this flowpipe as the union of reach-sets.\n\nInput\n\nfp  – flowpipe\n\nOutput\n\nThe set union of the array of reach-sets of the flowpipe.\n\nNotes\n\nTo retrieve the array of sets stored in the flowpipe use array(fp). To get a set at a particular index, use set(F[ind]) or set(F, ind).\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tstart","text":"tstart(fp::AbstractFlowpipe)\n\nReturn the initial time of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the initial time of the first reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tend","text":"tend(fp::AbstractFlowpipe)\n\nReturn the final time of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the final time of the last reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tspan","text":"tspan(fp::AbstractFlowpipe)\n\nReturn time span of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nThe interval representing the time span of the given flowpipe. The fallback is computed as (tstart(fp), tend(fp)), see tstart(::AbstractFlowpipe) and tend(::AbstractFlowpipe) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.vars-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.vars","text":"vars(fp::AbstractFlowpipe)\n\nReturn the tuple of variable indices of the flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nTuple of integers with the variable indices of the flowpipe, typically 1 2  n where n is the dimension of the flowpipe.\n\nNotes\n\nThe fallback implementation assumes first reach-set is representative.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.Flowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.Flowpipe","text":"Flowpipe{N, RT<:AbstractReachSet{N}, VRT<:AbstractVector{RT}} <: AbstractFlowpipe\n\nType that wraps a flowpipe, which is an iterable collection of reach-sets that behaves like their set union.\n\nFields\n\nXk  – array of reach-sets\next – extension dictionary; field used by extensions\n\nNotes\n\nThe dimension of the flowpipe corresponds to the dimension of the underlying reach-sets; in this type, it is is assumed that the dimension is the same for the different reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#ReachabilityAnalysis.location-Tuple{Flowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.location","text":"location(F::Flowpipe)\n\nReturn the location of a flowpipe within a hybrid system, or missing if it is not defined.\n\nInput\n\nF – flowpipe\n\nOutput\n\nThe :loc_id value of stored in the flowpipe's extension field.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.shift","page":"Flowpipes","title":"ReachabilityAnalysis.shift","text":"shift(R::AbstractReachSet, t0::Number)\n\nPerform a time-shift of the given reach-set.\n\nInput\n\nR  – reach-set\nt0 – number that corresponds to the time-shift\n\nOutput\n\nA new reach-set of the same type of R such that its time-span has been shifted by t0.\n\n\n\n\n\nshift(fp::Flowpipe{N, <:AbstractReachSet}, t0::Number) where {N}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#ReachabilityAnalysis.HybridFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.HybridFlowpipe","text":"HybridFlowpipe{N,RT<:AbstractReachSet{N},FT<:AbstractFlowpipe} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same type, such that they are contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThe evaluation functions (in time) for this type do not assume that the flowpipes are contiguous in time. That is, the final time of the i-th flowpipe does not match the start time of the i+1-th flowpipe.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#ReachabilityAnalysis.MixedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.MixedFlowpipe","text":"MixedFlowpipe{N,RT<:AbstractReachSet{N},FT<:AbstractFlowpipe} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same time, such that they are not necessarily contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThis type does not assume that the flowpipes are contiguous in time.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#ReachabilityAnalysis.ShiftedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.ShiftedFlowpipe","text":"ShiftedFlowpipe{FT<:AbstractFlowpipe, NT<:Number} <: AbstractFlowpipe\n\nType that lazily represents a flowpipe that has been shifted in time.\n\nFields\n\nF  – original flowpipe\nt0 – time shift\n\nNotes\n\nThis type can wrap any concrete subtype of AbstractFlowpipe, and the extra field t0 is such that the time spans of each reach-set in F are shifted by the amount t0 (which should be a subtype of Number).\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#ReachabilityAnalysis.MappedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.MappedFlowpipe","text":"MappedFlowpipe{FT<:AbstractFlowpipe, ST} <: AbstractFlowpipe\n\nFields\n\nF    – flowpipe\nfunc – function representing the map\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/BFFPSV18/#Decomposition-based-method-(BFFPSV18)","page":"BFFPSV18","title":"Decomposition-based method (BFFPSV18)","text":"","category":"section"},{"location":"man/algorithms/BFFPSV18/#Method","page":"BFFPSV18","title":"Method","text":"We overapproximate the reachable states of an affine system by solving a set-based recurrence. The key idea is that we first decompose the system into (low-dimensional) subsystems and later compose the results as a Cartesian product. Thus we have to solve many cheap problems instead of one hard problem. Since solving the recurrence scales superlinearly with the dimension, this approach is very scalable. To represent sets of states, we use the LazySets package which provides exact but lazy (i.e. symbolic) representations of common sets.","category":"section"},{"location":"man/algorithms/BFFPSV18/#Decomposition-error","page":"BFFPSV18","title":"Decomposition error","text":"Decomposition typically involves a loss in precision, and so does this approach. The good thing is that we can decompose the recurrence as well, which allows us to analyze each of the subsystems independently by only referring to the initial states of the other subsystems. Consequently, there are two main sources for precision loss:\n\nDecomposition of the initial states: If two subsystems are interdependent initially.\nRepresentation of the reachable states as a Cartesian product: If two subsystems are interdependent in the dynamics.\nRepresentation of the reachable states in general: The reachable states of affine systems cannot be represented precisely in all cases. This is a problem that all approaches suffer from. We overapproximate the reachable states by (unions of) convex polytopes.","category":"section"},{"location":"man/algorithms/BFFPSV18/#Safety-verification","page":"BFFPSV18","title":"Safety verification","text":"The problem of checking a safety property can be reduced to a reachability problem. We provide special support for this reduction by inlining the property check into the reachable states computation. This has two benefits:\n\nWe fail fast when the property is violated in our abstraction.\nThe check is usually cheaper than computing the full reachable states. This is because we are often only interested in an upper or lower bound of a variable.","category":"section"},{"location":"tutorials/taylor_methods/domain_splitting/#Domain-splitting","page":"Domain splitting","title":"Domain splitting","text":"A common technique to reduce wrapping effects is to split the set of initial states. If an initial-value problem has been setup with an array of sets, then the flowpipe starting from each initial set scomputed in parallel, using Julia's built-in multithreaded support.\n\nnote: Note\nTo turn off multithreading, pass the multithreaded=false option flag to solve method. It is true by default.\n\nnote: Note\nTo change the number of threads being used, change the THREADS flag in . . .","category":"section"}]
}
